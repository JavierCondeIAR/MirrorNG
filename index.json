{
  "Guides/Sync/SyncDictionary.html": {
    "href": "Guides/Sync/SyncDictionary.html",
    "title": "SyncDictionary",
    "keywords": "SyncDictionary A SyncDictionary is an associative array containing an unordered list of key, value pairs. Keys and values can be of the following types: Basic type (byte, int, float, string, UInt64, etc) Built-in Unity math type (Vector3, Quaternion, etc) NetworkIdentity Game object with a NetworkIdentity component attached. Struct with any of the above SyncDictionary works much like SyncLists : when you make a change on the server the change is propagated to all clients and the Callback is called. To use it, create a class that derives from SyncDictionary for your specific type. This is necessary because the Weaver will add methods to that class. Then add a field to your NetworkBehaviour class. Note that by the time you subscribe to the callback, the dictionary will already be initialized, so you will not get a call for the initial data, only updates. Note SyncDictionaries must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. Simple Example using UnityEngine; using Mirror; [System.Serializable] public struct Item { public string name; public int hitPoints; public int durability; } [System.Serializable] public class SyncDictionaryStringItem : SyncDictionary<string, Item> {} public class ExamplePlayer : NetworkBehaviour { [SerializeField] public readonly SyncDictionaryStringItem Equipment = new SyncDictionaryStringItem(); public override void OnStartServer() { Equipment.Add(\"head\", new Item { name = \"Helmet\", hitPoints = 10, durability = 20 }); Equipment.Add(\"body\", new Item { name = \"Epic Armor\", hitPoints = 50, durability = 50 }); Equipment.Add(\"feet\", new Item { name = \"Sneakers\", hitPoints = 3, durability = 40 }); Equipment.Add(\"hands\", new Item { name = \"Sword\", hitPoints = 30, durability = 15 }); } public override void OnStartClient() { // Equipment is already populated with anything the server set up // but we can subscribe to the callback in case it is updated later on Equipment.Callback += OnEquipmentChange; } void OnEquipmentChange(SyncDictionaryStringItem.Operation op, string key, Item item) { // equipment changed, perhaps update the gameobject Debug.Log(op + \" - \" + key); } } By default, SyncDictionary uses a Dictionary to store it's data. If you want to use a different IDictionary implementation such as SortedList or SortedDictionary , add a constructor to your SyncDictionary implementation and pass a dictionary to the base class. For example: [System.Serializable] public class SyncDictionaryStringItem : SyncDictionary<string, Item> { public SyncDictionaryStringItem() : base (new SortedList<string,Item>()) {} } public class ExamplePlayer : NetworkBehaviour { [SerializeField] public readonly SyncDictionaryStringItem Equipment = new SyncDictionaryStringItem(); }"
  },
  "Guides/Sync/SyncVars.html": {
    "href": "Guides/Sync/SyncVars.html",
    "title": "SyncVars",
    "keywords": "SyncVars SyncVars are properties of classes that inherit from NetworkBehaviour, which are synchronized from the server to clients. When a game object is spawned, or a new player joins a game in progress, they are sent the latest state of all SyncVars on networked objects that are visible to them. Use the SyncVar custom attribute to specify which variables in your script you want to synchronize. The state of SyncVars is applied to game objects on clients before OnStartClient() is called, so the state of the object is always up-to-date inside OnStartClient() . SyncVars can use any type supported by Mirror . You can have up to 64 SyncVars on a single NetworkBehaviour script, including SyncLists (see next section, below). The server automatically sends SyncVar updates when the value of a SyncVar changes, so you do not need to track when they change or send information about the changes yourself. Changing a value in the inspector will not trigger an update. The SyncVar hook attribute can be used to specify a method to be called when the SyncVar changes value on the client. SyncVar Example Let's say we have a networked object with a script called Enemy: public class Enemy : NetworkBehaviour { [SyncVar] public int health = 100; void OnMouseUp() { NetworkIdentity ni = NetworkClient.connection.identity; PlayerController pc = ni.GetComponent<PlayerController>(); pc.currentTarget = gameObject; } } The PlayerController might look like this: public class PlayerController : NetworkBehaviour { public GameObject currentTarget; void Update() { if (isLocalPlayer) if (currentTarget != null) if (currentTarget.tag == \"Enemy\") if (Input.GetKeyDown(KeyCode.X)) CmdShoot(currentTarget); } [Command] public void CmdShoot(GameObject enemy) { // Do your own shot validation here because this runs on the server enemy.GetComponent<Enemy>().health -= 5; } } In this example, when a Player clicks on an Enemy, the networked enemy game object is assigned to PlayerController.currentTarget . When the player presses X, with a correct target selected, that target is passed through a Command, which runs on the server, to decrement the health SyncVar. All clients will be updated with that new value. You can then have a UI on the enemy to show the current value. Class inheritance SyncVars work with class inheritance. Consider this example: class Pet : NetworkBehaviour { [SyncVar] String name; } class Cat : Pet { [SyncVar] public Color32 color; } You can attach the Cat component to your cat prefab, and it will synchronize both it's name and color . Warning Both Cat and Pet should be in the same assembly. If they are in separate assemblies, make sure not to change name from inside Cat directly, add a method to Pet instead."
  },
  "Guides/Sync/SyncLists.html": {
    "href": "Guides/Sync/SyncLists.html",
    "title": "SyncLists",
    "keywords": "SyncLists SyncLists are array based lists similar to C# List<T> that synchronize their contents from the server to the clients. A SyncList can contain any supported mirror type . Differences with HLAPI HLAPI also supports SyncLists, but we have redesigned them to better suit our needs. Some of the key differences include: In HLAPI, SyncLists were synchronized immediately when they changed. If you add 10 elements, that means 10 separate messages. Mirror synchronizes SyncLists with the SyncVars. The 10 elements and other SyncVars are batched together into a single message. Mirror also respects the sync interval when synchronizing lists. In HLAPI if you want a list of structs, you have to use SyncListStruct<MyStructure> , we changed it to just SyncList<MyStructure> In HLAPI the Callback is a delegate. In Mirror we changed it to an event, so that you can add many subscribers. In HLAPI the Callback tells you the operation and index. In Mirror, the callback also receives an item. We made this change so that we could tell what item was removed. Usage Create a class that derives from SyncList for your specific type. This is necessary because Mirror will add methods to that class with the weaver. Then add a SyncList field to your NetworkBehaviour class. For example: [System.Serializable] public struct Item { public string name; public int amount; public Color32 color; } [System.Serializable] public class SyncListItem : SyncList<Item> {} public class Player : NetworkBehaviour { readonly SyncListItem inventory = new SyncListItem(); public int coins = 100; [Command] public void CmdPurchase(string itemName) { if (coins > 10) { coins -= 10; Item item = new Item { name = \"Sword\", amount = 3, color = new Color32(125, 125, 125, 255) }; // during next synchronization, all clients will see the item inventory.Add(item); } } } There are some ready made SyncLists you can use: SyncListString SyncListFloat SyncListInt SyncListUInt SyncListBool You can also detect when a SyncList changes in the client or server. This is useful for refreshing your character when you add equipment or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart , or OnServerStart for that. Note that by the time you subscribe, the list will already be initialized, so you will not get a call for the initial data, only updates. Note SyncLists must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. class Player : NetworkBehaviour { readonly SyncListItem inventory = new SyncListItem(); // this will add the delegates on both server and client. // Use OnStartClient instead if you just want the client to act upon updates void Start() { inventory.Callback += OnInventoryUpdated; } void OnInventoryUpdated(SyncListItem.Operation op, int index, Item oldItem, Item newItem) { switch (op) { case SyncListItem.Operation.OP_ADD: // index is where it got added in the list // item is the new item break; case SyncListItem.Operation.OP_CLEAR: // list got cleared break; case SyncListItem.Operation.OP_INSERT: // index is where it got added in the list // item is the new item break; case SyncListItem.Operation.OP_REMOVEAT: // index is where it got removed in the list // item is the item that was removed break; case SyncListItem.Operation.OP_SET: // index is the index of the item that was updated // item is the previous item break; } } } By default, SyncList uses a List to store it's data. If you want to use a different list implementation, add a constructor and pass the list implementation to the parent constructor. For example: class SyncListItem : SyncList<Item> { public SyncListItem() : base(new MyIList<Item>()) {} }"
  },
  "Guides/Sync/SyncEvent.html": {
    "href": "Guides/Sync/SyncEvent.html",
    "title": "SyncEvent",
    "keywords": "SyncEvent This is an attribute that can be put on events in NetworkBehaviour classes to allow them to be invoked on client when the event is called on the server. SyncEvent events are called by user code on the server, and then invoked on corresponding client objects on clients connected to the server. The arguments to the Event call are serialized across the network, so that the client event is invoked with the same values as the method on the server. These events must begin with the prefix \"Event\". using UnityEngine; using Mirror; public class DamageClass : NetworkBehaviour { public delegate void TakeDamageDelegate(int amount, float dir); [SyncEvent] public event TakeDamageDelegate EventTakeDamage; [Command] public void CmdDoMe(int val) { EventTakeDamage(val, 1.0f); } } public class Other : NetworkBehaviour { public DamageClass damager; int health = 100; void Start() { if (NetworkClient.active) damager.EventTakeDamage += TakeDamage; } public void TakeDamage(int amount, float dir) { health -= amount; } } SyncEvents allow networked actions to be propagated to other scripts attached to the object. In the example above, the Other class registers for the TakeDamage event on the DamageClass. When the event happens on the DamageClass on the server, the TakeDamage() method will be invoked on the Other class on the client object. This allows modular network aware systems to be created, that can be extended by new scripts that respond to the events generated by them."
  },
  "Guides/Sync/SyncSortedSet.html": {
    "href": "Guides/Sync/SyncSortedSet.html",
    "title": "SyncSortedSet",
    "keywords": "SyncSortedSet SyncSortedSet are sets similar to C# SortedSet<T> that synchronize their contents from the server to the clients. Unlike SyncHashSets, all elements in a SyncSortedSet are sorted when they are inserted. Please note this has some performance implications. A SyncSortedSet can contain any supported mirror type Usage Create a class that derives from SyncSortedSet for your specific type. This is necessary because Mirror will add methods to that class with the weaver. Then add a SyncSortedSet field to your NetworkBehaviour class. For example: class Player : NetworkBehaviour { class SyncSkillSet : SyncSortedSet<string> {} readonly SyncSkillSet skills = new SyncSkillSet(); int skillPoints = 10; [Command] public void CmdLearnSkill(string skillName) { if (skillPoints > 1) { skillPoints--; skills.Add(skillName); } } } You can also detect when a SyncSortedSet changes. This is useful for refreshing your character in the client or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart or OnServerStart for that. Note that by the time you subscribe, the set will already be initialized, so you will not get a call for the initial data, only updates. Note SyncSets must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. class Player : NetworkBehaviour { class SyncSetBuffs : SyncSortedSet<string> {}; readonly SyncSetBuffs buffs = new SyncSetBuffs(); // this will add the delegate on the client. // Use OnStartServer instead if you want it on the server public override void OnStartClient() { buffs.Callback += OnBuffsChanged; } void OnBuffsChanged(SyncSetBuffs.Operation op, string buff) { switch (op) { case SyncSetBuffs.Operation.OP_ADD: // we added a buff, draw an icon on the character break; case SyncSetBuffs.Operation.OP_CLEAR: // clear all buffs from the character break; case SyncSetBuffs.Operation.OP_REMOVE: // We removed a buff from the character break; } } }"
  },
  "Guides/Sync/SyncHashSet.html": {
    "href": "Guides/Sync/SyncHashSet.html",
    "title": "SyncHashSet",
    "keywords": "SyncHashSet SyncHashSet are sets similar to C# HashSet<T> that synchronize their contents from the server to the clients. A SyncHashSet can contain any supported mirror type Usage Create a class that derives from SyncHashSet for your specific type. This is necessary because Mirror will add methods to that class with the weaver. Then add a SyncHashSet field to your NetworkBehaviour class. For example: [System.Serializable] public class SyncSkillSet : SyncHashSet<string> {} public class Player : NetworkBehaviour { [SerializeField] readonly SyncSkillSet skills = new SyncSkillSet(); int skillPoints = 10; [Command] public void CmdLearnSkill(string skillName) { if (skillPoints > 1) { skillPoints--; skills.Add(skillName); } } } You can also detect when a SyncHashSet changes. This is useful for refreshing your character in the client or determining when you need to update your database. Subscribe to the Callback event typically during Start , OnClientStart or OnServerStart for that. Note that by the time you subscribe, the set will already be initialized, so you will not get a call for the initial data, only updates. Note SyncSets must be initialized in the constructor, not in Startxxx(). You can make them readonly to ensure correct usage. [System.Serializable] public class SyncSetBuffs : SyncHashSet<string> {}; public class Player : NetworkBehaviour { [SerializeField] public readonly SyncSetBuffs buffs = new SyncSetBuffs(); // this will add the delegate on the client. // Use OnStartServer instead if you want it on the server public override void OnStartClient() { buffs.Callback += OnBuffsChanged; } void OnBuffsChanged(SyncSetBuffs.Operation op, string buff) { switch (op) { case SyncSetBuffs.Operation.OP_ADD: // we added a buff, draw an icon on the character break; case SyncSetBuffs.Operation.OP_CLEAR: // clear all buffs from the character break; case SyncSetBuffs.Operation.OP_REMOVE: // We removed a buff from the character break; } } }"
  },
  "Guides/Sync/SyncVarHook.html": {
    "href": "Guides/Sync/SyncVarHook.html",
    "title": "SyncVar Hook",
    "keywords": "SyncVar Hook The hook attribute can be used to specify a function to be called when the SyncVar changes value on the client. The Hook method must have two parameters of the same type as the SyncVar property. One for the old value, one for the new value. The Hook is always called after the property value is set. You don't need to set it yourself. The Hook only fires for changed values, and changing a value in the inspector will not trigger an update. As of version 11.1.4 (March 2020) and later, hooks can be virtual methods and overriden in a derived class. Below is a simple example of assigning a random color to each player when they're spawned on the server. All clients will see all players in the correct colors, even if they join later. Note: The signature for hook methods was changed in version 9.0 (Feb 2020) to having 2 parameters (old and new values). If you're on an older version, hook methods just have one parameter (new value). using UnityEngine; using Mirror; public class PlayerController : NetworkBehaviour { [SyncVar(hook = nameof(SetColor))] Color playerColor = Color.black; // Unity makes a clone of the Material every time GetComponent<Renderer>().material is used. // Cache it here and Destroy it in OnDestroy to prevent a memory leak. Material cachedMaterial; public override void OnStartServer() { base.OnStartServer(); playerColor = Random.ColorHSV(0f, 1f, 1f, 1f, 0.5f, 1f); } void SetColor(Color oldColor, Color newColor) { if (cachedMaterial == null) cachedMaterial = GetComponent<Renderer>().material; cachedMaterial.color = newColor; } void OnDestroy() { Destroy(cachedMaterial); } }"
  },
  "Guides/GameObjects/index.html": {
    "href": "Guides/GameObjects/index.html",
    "title": "Networked Game Objects",
    "keywords": "Networked Game Objects Networked game objects are game objects which are controlled and synchronized by Mirror’s networking system. Using synchronized networked game objects, you can create a shared experience for all the players who are playing an instance of your game. They see and hear the same events and actions - even though that may be from their own unique viewpoints within your game. Multiplayer games in Mirror are typically built using Scenes that contain a mix of networked game objects and regular (non-networked) game objects. The networked game objects are those which move or change during gameplay in a way that needs to be synchronized across all users who are playing the game together. Non-networked game objects are those which either don’t move or change at all during gameplay (for example, static obstacles like rocks or fences), or game objects which have movement or changes that don’t need to be synchronized across players (for example, a gently swaying tree or clouds passing by in the background of your game). A networked game object is one which has a Network Identity component attached. However, a Network Identity component alone is not enough for your game object to be functional and active in your multiplayer game. The Network Identity component is the starting point for synchronization, and it allows the Network Manager to synchronize the creation and destruction of the game object, but other than that, it does not specify which properties of your game object should be synchronized. What exactly should be synchronized on each networked game object depends on the type of game you are making, and what each game object’s purpose is. Some examples of what you might want to synchronize are: The position and rotation of moving game objects such as the players and non-player characters. The animation state of an animated game object The value of a variable, for example how much time is left in the current round of a game, or how much energy a player has. Some of these things can be automatically synchronized by Mirror. The synchronized creation and destruction of networked game objects is managed by the NetworkManager, and is known as Spawning. You can use the Network Transform component to synchronize the position and rotation of a game object, and you can use the Network Animator component to synchronize the animation of a game object. To synchronize other properties of a networked game object, you need to use scripting. See State Synchronization for more information about this."
  },
  "Guides/GameObjects/SceneObjects.html": {
    "href": "Guides/GameObjects/SceneObjects.html",
    "title": "Scene Game Objects",
    "keywords": "Scene Game Objects There are two types of networked game objects in Mirror’s multiplayer system: Those that are created dynamically at runtime Those that are saved as part of a Scene Game objects that are created dynamically at runtime use the multiplayer Spawning system, and the prefabs they are instantiated from must be registered in the Network Manager’s list of networked game object prefabs. However, networked game objects that you save as part of a Scene (and therefore already exist in the Scene when it is loaded) are handled differently. These game objects are loaded as part of the Scene on both the client and server, and exist at runtime before any spawn messages are sent by the multiplayer system. When the Scene is loaded, all networked game objects in the Scene are disabled on both the client and the server. Then, when the Scene is fully loaded, the Network Manager automatically processes the Scene’s networked game objects, registering them all (and therefore causing them to be synchronized across clients), and enabling them, as if they were spawned at runtime. Networked game objects will not be enabled until a client has requested a Player object. Saving networked game objects in your Scene (rather than dynamically spawning them after the scene has loaded) has some benefits: They are loaded with the level, so there will be no pause at runtime. They can have specific modifications that differ from prefabs Other game object instances in the Scene can reference them, which can avoid you having to use code to finding the game objects and make references to them up at runtime. When the Network Manager spawns the networked Scene game objects, those game objects behave like dynamically spawned game objects. Mirror sends them updates and ClientRPC calls. If a Scene game object is destroyed on the server before a client joins the game, then it is never enabled on new clients that join. When a client connects, the client is sent an ObjectSpawnScene spawn message for each of the Scene game objects that exist on the server, that are visible to that client. This message causes the game object on the client to be enabled, and has the latest state of that game object from the server in it. This means that only game objects that are visible to the client, and not destroyed on the server, are activated on the client. Like regular non-Scene game objects, these Scene game objects are started with the latest state when the client joins the game."
  },
  "Guides/GameObjects/PickupDropChild.html": {
    "href": "Guides/GameObjects/PickupDropChild.html",
    "title": "Pickups, Drops, and Child Objects",
    "keywords": "Pickups, Drops, and Child Objects Frequently the question comes up about how to handle objects that are attached as children of the player prefab that all clients need to know about and synchronize, such as which weapon is equipped, picking up networked scene objects, and players dropping objects into the scene. Mirror cannot support multiple Network Identity components within an object hierarchy. Since the Player object must have a Network Identity, none of its descendant objects can have one. Child Objects Let's start with the simple case of a single attachment point that is somewhere down the hierarchy of our Player, such as a hand at the end of an arm. In a script that inherits from NetworkBehaviour on the Player Prefab, we'd have a GameObject reference where the attachment point can be assigned in the inspector, a SyncVar enum with various choices of what the player is holding, and and a Hook for the SyncVar to swap out the art of the held item based on the new value. In the image below, Kyle has an empty game object, RightHand , added to the wrist, and some prefabs to be equipped (Ball, Box, Cylinder), and a Player Equip script to handle them. NOTE : The item prefabs are art only ...they have no scripts, and they must not have networking components. They can have monobehaviour-based scripts, of course, which can be referenced and called from ClientRpc's on the player prefab. The inspector shows RightHand assigned in 2 places, the Player Equip script, as well as the target of the Network Transform Child component, so we could adjust the relative position of the attachment point (not the art) for all clients as needed. Below is the Player Equip script to handle the changing of the equipped item, and some notes for consideration: While we could just have all the art items attached at design time and just enable / disable them based on the enum, this doesn't scale well to a lot of items and if they have scripts on them for how they behave in the game, such as animations, special effects, etc. it could get ugly pretty fast, so this example locally instantiates and destroys instead as a design choice. The example makes no effort to deal with position offset between the item and the attach point, e.g. having the grip or handle of an item align with the hand. This is best dealt with in a monobehaviour script on the item that has public fields for the local position and rotation that can be set in the designer and a bit of code in Start to apply those values in local coordinates relative to the parent attach point. using UnityEngine; using System.Collections; using Mirror; public enum EquippedItem : byte { nothing, ball, box, cylinder } public class PlayerEquip : NetworkBehaviour { public GameObject sceneObjectPrefab; public GameObject rightHand; public GameObject ballPrefab; public GameObject boxPrefab; public GameObject cylinderPrefab; [SyncVar(hook = nameof(OnChangeEquipment))] public EquippedItem equippedItem; void OnChangeEquipment(EquippedItem oldEquippedItem, EquippedItem newEquippedItem) { StartCoroutine(ChangeEquipment(newEquippedItem)); } // Since Destroy is delayed to the end of the current frame, we use a coroutine // to clear out any child objects before instantiating the new one IEnumerator ChangeEquipment(EquippedItem newEquippedItem) { while (rightHand.transform.childCount > 0) { Destroy(rightHand.transform.GetChild(0).gameObject); yield return null; } switch (newEquippedItem) { case EquippedItem.ball: Instantiate(ballPrefab, rightHand.transform); break; case EquippedItem.box: Instantiate(boxPrefab, rightHand.transform); break; case EquippedItem.cylinder: Instantiate(cylinderPrefab, rightHand.transform); break; } } void Update() { if (!isLocalPlayer) return; if (Input.GetKeyDown(KeyCode.Alpha0) && equippedItem != EquippedItem.nothing) CmdChangeEquippedItem(EquippedItem.nothing); if (Input.GetKeyDown(KeyCode.Alpha1) && equippedItem != EquippedItem.ball) CmdChangeEquippedItem(EquippedItem.ball); if (Input.GetKeyDown(KeyCode.Alpha2) && equippedItem != EquippedItem.box) CmdChangeEquippedItem(EquippedItem.box); if (Input.GetKeyDown(KeyCode.Alpha3) && equippedItem != EquippedItem.cylinder) CmdChangeEquippedItem(EquippedItem.cylinder); } [Command] void CmdChangeEquippedItem(EquippedItem selectedItem) { equippedItem = selectedItem; } } Dropping Items Now that we can equip the items, we need a way to drop the current item into the world as a networked item. Remember that, as child art, the item prefabs have no networking components on them at all. First, let's add one more Input to the Update method above, and a CmdDropItem method: void Update() { if (!isLocalPlayer) return; if (Input.GetKeyDown(KeyCode.Alpha0) && equippedItem != EquippedItem.nothing) CmdChangeEquippedItem(EquippedItem.nothing); if (Input.GetKeyDown(KeyCode.Alpha1) && equippedItem != EquippedItem.ball) CmdChangeEquippedItem(EquippedItem.ball); if (Input.GetKeyDown(KeyCode.Alpha2) && equippedItem != EquippedItem.box) CmdChangeEquippedItem(EquippedItem.box); if (Input.GetKeyDown(KeyCode.Alpha3) && equippedItem != EquippedItem.cylinder) CmdChangeEquippedItem(EquippedItem.cylinder); if (Input.GetKeyDown(KeyCode.X) && equippedItem != EquippedItem.nothing) CmdDropItem(); } [Command] void CmdDropItem() { // Instantiate the scene object on the server Vector3 pos = rightHand.transform.position; Quaternion rot = rightHand.transform.rotation; GameObject newSceneObject = Instantiate(sceneObjectPrefab, pos, rot); // set the RigidBody as non-kinematic on the server only (isKinematic = true in prefab) newSceneObject.GetComponent<Rigidbody>().isKinematic = false; SceneObject sceneObject = newSceneObject.GetComponent<SceneObject>(); // set the child object on the server sceneObject.SetEquippedItem(equippedItem); // set the SyncVar on the scene object for clients sceneObject.equippedItem = equippedItem; // set the player's SyncVar to nothing so clients will destroy the equipped child item equippedItem = EquippedItem.nothing; // Spawn the scene object on the network for all to see NetworkServer.Spawn(newSceneObject); } In the image above, there's a sceneObjectPrefab field that is assigned to a prefab that will act as a container for our item prefabs. The SceneObject prefab has a SceneObject script with a SyncVar like the Player Equip script, and a SetEquippedItem method that takes the shared enum value as a parameter. using UnityEngine; using System.Collections; using Mirror; public class SceneObject : NetworkBehaviour { [SyncVar(hook = nameof(OnChangeEquipment))] public EquippedItem equippedItem; public GameObject ballPrefab; public GameObject boxPrefab; public GameObject cylinderPrefab; void OnChangeEquipment(EquippedItem oldEquippedItem, EquippedItem newEquippedItem) { StartCoroutine(ChangeEquipment(newEquippedItem)); } // Since Destroy is delayed to the end of the current frame, we use a coroutine // to clear out any child objects before instantiating the new one IEnumerator ChangeEquipment(EquippedItem newEquippedItem) { while (transform.childCount > 0) { Destroy(transform.GetChild(0).gameObject); yield return null; } // Use the new value, not the SyncVar property value SetEquippedItem(newEquippedItem); } // SetEquippedItem is called on the client from OnChangeEquipment (above), // and on the server from CmdDropItem in the PlayerEquip script. public void SetEquippedItem(EquippedItem newEquippedItem) { switch (newEquippedItem) { case EquippedItem.ball: Instantiate(ballPrefab, transform); break; case EquippedItem.box: Instantiate(boxPrefab, transform); break; case EquippedItem.cylinder: Instantiate(cylinderPrefab, transform); break; } } } In the run-time image below, the Ball(Clone) is attached to the RightHand object, and the Box(Clone) is attached to the SceneObject(Clone), which is shown in the inspector. The art prefabs have simple colliders on them (sphere, box, capsule). If your art item has a mesh collider, it must be marked as Convex to work with the RigidBody on the SceneObject container. Pickup Items Now that we have a box dropped in the scene, we need to pick it up again. To do that, a CmdPickupItem method is added to the Player Equip script: // CmdPickupItem is public because it's called from a script on the SceneObject [Command] public void CmdPickupItem(GameObject sceneObject) { // set the player's SyncVar so clients can show the equipped item equippedItem = sceneObject.GetComponent<SceneObject>().equippedItem; // Destroy the scene object NetworkServer.Destroy(sceneObject); } This method is simply called from OnMouseDown in the Scene Object script: void OnMouseDown() { NetworkClient.connection.identity.GetComponent<PlayerEquip>().CmdPickupItem(gameObject); } Since the SceneObject(Clone) is networked, we can pass it directly through to CmdPickupItem on the player object to set the equipped item SyncVar and destroy the scene object. For this entire example, the only prefab that needs to be registered with Network Manager besides the Player is the SceneObject prefab."
  },
  "General/Deprecations.html": {
    "href": "General/Deprecations.html",
    "title": "Deprecations",
    "keywords": "Deprecations Certain features of Unity Networking (UNet) were removed from Mirror or modified for various reasons. This page will identify all changed and removed features, properties, and methods, the reason for change or removal, and possible alternatives. Note: Some changes in this document may apply to an upcoming release to the Asset Store. Match Namespace & Host Migration As part of the Unity Services, this entire namespace was removed. It didn't work well to begin with, and was incredibly complex to be part of the core networking package. We expect this, along with other back-end services, will be provided through standalone apps that have integration to Mirror. Network Server Simple This was too complex and impractical to maintain for what little it did, and was removed. There are much easier ways to make a basic listen server, with or without one of our transports. Couch Co-Op The core networking was greatly simplified by removing this low-hanging fruit. It was buggy, and too convoluted to be worth fixing. For those that need something like this, consider defining a non-visible player prefab as a message conduit that spawns actual player prefabs with client authority. All inputs would route through the conduit prefab to control the player objects. Message Types The MsgType enumeration was removed. All message types are generated dynamically. Use Send<T> instead. Network Transform Network Transform was significantly simplified so that it only syncs position, rotation and scale. Rigidbody support was removed. We may create a new NetworkRigidbody component that will be server authoritative with physics simulation and interpolation. Network Animator Network Animator was also simplified, as it batches all Animator parameters into a single update message. SyncVar Hook Parameters SyncVar property values are now updated before the hook is called, and hooks now require two parameters of the same type as the property: oldValue and newValue SyncListSTRUCT Use SyncList<YourSpecialStruct> instead. SyncList Operations OP_REMOVE was replaced by OP_REMOVEAT OP_DIRTY was replaced by OP_SET SyncIDictionary Operations OP_DIRTY was replaced by OP_SET Quality of Service Flags In classic UNet, QoS Flags were used to determine how packets got to the remote end. For example, if you needed a packet to be prioritized in the queue, you would specify a high priority flag which the Unity LLAPI would then receive and deal with appropriately. Unfortunately, this caused a lot of extra work for the transport layer and some of the QoS flags did not work as intended due to buggy code that relied on too much magic. In Mirror, QoS flags were replaced with a \"Channels\" system. This system paves the way for future Mirror improvements, so you can send data on different channels - for example, you could have all game activity on channel 0, while in-game text chat is sent on channel 1 and voice chat is sent on channel 2. In the future, it may be possible to assign a transport system per channel, allowing one to have a TCP transport for critical game network data on channel 0, while in-game text and voice chat is running on a UDP transport in parallel on channel 1. Some transports, such as Ignorance , also provide legacy compatibility for those attached to QoS flags. The currently defined channels are: Channels.DefaultReliable = 0 Channels.DefaultUnreliable = 1 Currently, Mirror using it's default TCP transport will always send everything over a reliable channel. There is no way to bypass this behaviour without using a third-party transport, since TCP is always reliable. Other transports may support other channel sending methods. Changes by Class NetworkManager networkPort Removed as part of separating Transports to components. Not all transports use ports, but those that do have a field for it. See Transports for more info. IsHeadless() Use isHeadless instead, as it's a property now. client Use NetworkClient directly, it will be made static soon. For example, use NetworkClient.Send(message) instead of NetworkManager.client.Send(message) . IsClientConnected() Use static property NetworkClient.isConnected instead. onlineScene and offlineScene These store full paths now, so use SceneManager.GetActiveScene().path instead. OnStartClient(NetworkClient client) Override OnStartClient() instead since all NetworkClient methods are static now. OnClientChangeScene(string newSceneName) Override OnClientChangeScene(string newSceneName, SceneOperation sceneOperation, bool customHandling) instead. OnClientChangeScene(string newSceneName, SceneOperation sceneOperation) Override OnClientChangeScene(string newSceneName, SceneOperation sceneOperation, bool customHandling) instead. OnServerAddPlayer(NetworkConnection conn, AddPlayerMessage extraMessage) Override OnServerAddPlayer(NetworkConnection conn) instead. See Custom Player Spawn Guide for details. NetworkRoomManager OnRoomServerCreateGamePlayer(NetworkConnection conn) Use OnRoomServerCreateGamePlayer(NetworkConnection conn, GameObject roomPlayer) instead. OnRoomServerSceneLoadedForPlayer(GameObject roomPlayer, GameObject gamePlayer) Use OnRoomServerSceneLoadedForPlayer(NetworkConnection conn, GameObject roomPlayer, GameObject gamePlayer) instead. NetworkIdentity clientAuthorityOwner Use connectionToClient instead GetSceneIdenity Use GetSceneIdentity instead (typo in original name) RemoveClientAuthority(NetworkConnection conn) NetworkConnection parameter is no longer needed and nothing is returned Local Player Authority checkbox This checkbox is no longer needed, and we simplified how Authority works in Mirror. NetworkBehaviour sendInterval attribute Use NetworkBehaviour.syncInterval field instead. Can be modified in the Inspector too. List<SyncObject> m_SyncObjects Use List<SyncObject> syncObjects instead. OnSetLocalVisibility(bool visible) Override OnSetHostVisibility(bool visible) instead. In Mirror 12, OnRebuildObservers , OnCheckObserver , and OnSetHostVisibility were moved to a separate class called NetworkVisibility In Mirror 12, NetworkBehaviour.OnNetworkDestroy was renamed to NetworkBehaviour.OnStopClient . NetworkConnection hostId Removed because it's not needed ever since we removed LLAPI as default. It's always 0 for regular connections and -1 for local connections. Use connection.GetType() == typeof(NetworkConnection) to check if it's a regular or local connection. isConnected Removed because it's pointless. A NetworkConnection is always connected. InvokeHandlerNoData(int msgType) Use InvokeHandler<T> instead. playerController renamed to identity since that's what it is: the NetworkIdentity for the connection. If you need to convert a project after this change, Visual Studio / VS Code can help...read more here . RegisterHandler(short msgType, NetworkMessageDelegate handler) Use NetworkServer.RegisterHandler<T>() or NetworkClient.RegisterHandler<T>() instead. UnregisterHandler(short msgType) Use NetworkServer.UnregisterHandler<T>() or NetworkClient.UnregisterHandler<T>() instead. Send(int msgType, MessageBase msg, int channelId = Channels.DefaultReliable) Use Send<T>(msg, channelId) instead. NetworkServer FindLocalObject(uint netId) Use NetworkIdentity.spawned[netId].gameObject instead. RegisterHandler(int msgType, NetworkMessageDelegate handler) Use RegisterHandler<T>(T msg) instead. RegisterHandler(MsgType msgType, NetworkMessageDelegate handler) Use RegisterHandler<T>(T msg) instead. UnregisterHandler(int msgType) Use UnregisterHandler<T>(T msg) instead. UnregisterHandler(MsgType msgType) Use UnregisterHandler<T>(T msg) instead. SendToAll(int msgType, MessageBase msg, int channelId = Channels.DefaultReliable) Use SendToAll<T>(T msg, int channelId = Channels.DefaultReliable) instead. SendToClient(int connectionId, int msgType, MessageBase msg) Use NetworkConnection.Send<T>(T msg, int channelId = Channels.DefaultReliable) instead. SendToClient<T>(int connectionId, T msg) Use NetworkConnection.Send<T>(T msg, int channelId = Channels.DefaultReliable) instead. SendToClientOfPlayer(NetworkIdentity identity, int msgType, MessageBase msg) Use SendToClientOfPlayer<T>(NetworkIdentity identity, T msg, int channelId = Channels.DefaultReliable) instead. SendToReady(NetworkIdentity identity, short msgType, MessageBase msg, int channelId = Channels.DefaultReliable) Use SendToReady<T>(NetworkIdentity identity, T msg, int channelId = Channels.DefaultReliable) instead. SpawnWithClientAuthority(GameObject obj, GameObject player) Use Spawn(GameObject, GameObject) instead. SpawnWithClientAuthority(GameObject obj, NetworkConnection ownerConnection) Use Spawn(obj, connection) instead. SpawnWithClientAuthority(GameObject obj, Guid assetId, NetworkConnection ownerConnection) Use Spawn(obj, assetId, connection) instead NetworkClient NetworkClient singleton Use NetworkClient directly. Singleton isn't needed anymore as all functions are static now. Example: NetworkClient.Send(message) instead of NetworkClient.singleton.Send(message) . allClients Use NetworkClient directly instead. There is always exactly one client. GetRTT() Use NetworkTime.rtt instead. RegisterHandler(int msgType, NetworkMessageDelegate handler) Use RegisterHandler<T>(T msg) instead. RegisterHandler(MsgType msgType, NetworkMessageDelegate handler) Use RegisterHandler<T>(T msg) instead. UnregisterHandler(int msgType) Use UnregisterHandler<T>(T msg) instead. UnregisterHandler(MsgType msgType) Use UnregisterHandler<T>(T msg) instead. Send(short msgType, MessageBase msg) Use Send<T>(T msg, int channelId = Channels.DefaultReliable) with no message id instead ShutdownAll() Use Shutdown() instead. There is only one client. ClientScene FindLocalObject(uint netId) Use NetworkIdentity.spawned[netId] instead. Messages Basic messages of simple types were all removed as unnecessary bloat. You can create your own message classes instead. StringMessage ByteMessage BytesMessage IntegerMessage DoubleMessage EmptyMessage NetworkWriter Write(bool value) Use WriteBoolean instead. Write(byte value) Use WriteByte instead. Write(sbyte value) Use WriteSByte instead. Write(short value) Use WriteInt16 instead. Write(ushort value) Use WriteUInt16 instead. Write(int value) Use WriteInt32 instead. Write(uint value) Use WriteUInt32 instead. Write(long value) Use WriteInt64 instead. Write(ulong value) Use WriteUInt64 instead. Write(float value) Use WriteSingle instead. Write(double value) Use WriteDouble instead. Write(decimal value) Use WriteDecimal instead. Write(string value) Use WriteString instead. Write(char value) Use WriteChar instead. Write(Vector2 value) Use WriteVector2 instead. Write(Vector2Int value) Use WriteVector2Int instead. Write(Vector3 value) Use WriteVector3 instead. Write(Vector3Int value) Use WriteVector3Int instead. Write(Vector4 value) Use WriteVector4 instead. Write(Color value) Use WriteColor instead. Write(Color32 value) Use WriteColor32 instead. Write(Guid value) Use WriteGuid instead. Write(Transform value) Use WriteTransform instead. Write(Quaternion value) Use WriteQuaternion instead. Write(Rect value) Use WriteRect instead. Write(Plane value) Use WritePlane instead. Write(Ray value) Use WriteRay instead. Write(Matrix4x4 value) Use WriteMatrix4x4 instead. Write(NetworkIdentity value) Use WriteNetworkIdentity instead. Write(GameObject value) Use WriteGameObject instead. Write(byte[] buffer, int offset, int count) Use WriteBytes instead. Transport GetConnectionInfo(int connectionId, out string address) Use ServerGetClientAddress(int connectionId) instead. TelepathyTransport MaxMessageSize Use MaxMessageSizeFromClient or MaxMessageSizeFromServer instead."
  },
  "General/PlayerControllerToIdentity.html": {
    "href": "General/PlayerControllerToIdentity.html",
    "title": "Changing playerController to identity",
    "keywords": "Changing playerController to identity If you need to fix up a project after NetworkConnection.playerController was changed to identity these instructions should be helpful. Open your Unity project and look for Assets/Mirror/Runtime/ NetworkConnection : Open this file in Visual Studio or Visual Code from Unity and look for these lines: The line numbers could be off a bit if minor file changes happen above them after this document was written. Comment the last line shown: // public NetworkIdentity identity { get; internal set; } Double-click and then right-click playerController and select Rename: Change playerController to identity and click Apply: Visual Studio will now have applied the change throughout your project, but you're not done yet! Without using the replace feature this time, simply retype the name back to playerController and un-comment the last line in the code image that you commented out in step 3. Your code should now look like the code image again. Save your work!"
  },
  "Transports/Telepathy.html": {
    "href": "Transports/Telepathy.html",
    "title": "Telepathy Transport",
    "keywords": "Telepathy Transport Simple, message based, MMO Scale TCP networking in C#. And no magic. Telepathy was designed with the KISS Principle in mind. Telepathy is fast and extremely reliable, designed for MMO scale Networking. Telepathy uses framing, so anything sent will be received the same way. Telepathy is raw C# and can be used in Unity3D too. Telepathy is available on GitHub What makes Telepathy special? Telepathy was originally designed for uMMORPG after 3 years in UDP hell. We needed a library that is: Stable & Bug free: Telepathy uses only 400 lines of code. There is no magic. High performance: Telepathy can handle thousands of connections and packages. Concurrent: Telepathy uses one thread per connection. It can make heavy use of multi core processors. Simple: Telepathy takes care of everything. All you need to do is call Connect/GetNextMessage/Disconnect. Message based: if we send 10 and then 2 bytes, then the other end receives 10 and then 2 bytes, never 12 at once. MMORPGs are insanely difficult to make and we created Telepathy so that we would never have to worry about low level Networking again. What about... Async Sockets: didn't perform better in our benchmarks. ConcurrentQueue: .NET 3.5 compatibility is important for Unity. Wasn't faster than our SafeQueue anyway. UDP vs. TCP: Minecraft and World of Warcraft are two of the biggest multiplayer games of all time and they both use TCP networking. There is a reason for that."
  },
  "Components/Authenticators/index.html": {
    "href": "Components/Authenticators/index.html",
    "title": "Authentication",
    "keywords": "Authentication When you have a multiplayer game, often you need to store information about your player for later games, keep game stats or communicate with your friends. For all these use cases, you often need a way to uniquely identify a user. Being able to tell users apart is called authentication. There are several methods available, some examples include: Ask the user for username and password Use a third party oath or OpenID identity provider, such as Facebook, Twitter, Google Use a third party service such as PlayFab, GameLift or Steam Use the device id, very popular method in mobile Use Google Play in Android Use Game Center in IOS Use a web service in your website In addition to the Authenticators listed below, you can make your own! Check out this Guide for details. Authenticators Basic Authenticator Mirror includes a Basic Authenticator in the Mirror / Authenticators folder which just uses a simple username and password."
  },
  "Components/Authenticators/Basic.html": {
    "href": "Components/Authenticators/Basic.html",
    "title": "Basic Authenticator",
    "keywords": "Basic Authenticator Mirror includes a Basic Authenticator in the Mirror / Authenticators folder which just uses a simple username and password. Drag the Basic Authenticator script to the inspector of the object in your scene that has Network Manager The Basic Authenticator component will automatically be assigned to the Authenticator field in Network Manager When you're done, it should look like this: Note: You don't need to assign anything to the event lists unless you want to subscribe to the events in your own code for your own purposes. Mirror has internal listeners for both events."
  },
  "Components/index.html": {
    "href": "Components/index.html",
    "title": "Components Overview",
    "keywords": "Components Overview These core components are included in Mirror: Network Animator The Network Animator component allows you to synchronize animation states for networked objects. It synchronizes state and parameters from an Animator Controller. Network Identity The Network Identity component is at the heart of the Mirror networking high-level API. It controls a game object’s unique identity on the network, and it uses that identity to make the networking system aware of the game object. It offers two different options for configuration and they are mutually exclusive, which means either one of the options or none can be checked. Network Manager The Network Manager is a component for managing the networking aspects of a multiplayer game. Network Manager HUD The Network Manager HUD is a quick-start tool to help you start building your multiplayer game straight away, without first having to build a user interface for game creation/connection/joining. It allows you to jump straight into your gameplay programming, and means you can build your own version of these controls later in your development schedule. Network Discovery Network Discovery uses a UDP broadcast on the LAN enabling clients to find the running server and connect to it. Network Proximity Checker The Network Proximity Checker component controls the visibility of game objects for network clients, based on proximity to players. Network Scene Checker The Network Scene Checker component controls visibility of networked objects between scenes. Network Match Checker The Network Match Checker component controls visibility of networked objects based on match id. Network Room Manager The Network Room Manager is an extension component of Network Manager that provides a basic functional room. Network Room Player The Network Room Player is a component that's required on Player prefabs used in the Room Scene with the Network Room Manager above. Network Start Position Network Start Position is used by the Network Manager when creating player objects. The position and rotation of the Network Start Position are used to place the newly created player object. Network Transform The Network Transform component synchronizes the movement and rotation of game objects across the network. Note that the network Transform component only synchronizes spawned networked game objects. Network Transform Child The Network Transform Child component synchronizes the position and rotation of the child game object of a game object with a Network Transform component. Authenticators Authenticators are also available and more will be added soon: Basic Authenticator Mirror includes a Basic Authenticator in the Mirror / Authenticators folder which just uses a simple username and password."
  },
  "Components/NetworkProximityChecker.html": {
    "href": "Components/NetworkProximityChecker.html",
    "title": "Network Proximity Checker",
    "keywords": "Network Proximity Checker The Network Proximity Checker component controls the visibility of game objects for network clients, based on proximity to players. Vis Range Define the range that the game object should be visible to observers. Vis Update Interval Define how often (in seconds) the game object should check for observers entering its visible range. Check Method Define which type of physics (2D or 3D) to use for proximity checking. Force Hidden Tick this checkbox to hide this object from all players. With the Network Proximity Checker, a game running on a client doesn’t have information about game objects that are not visible. This has two main benefits: it reduces the amount of data sent across the network, and it makes your game more secure against hacking. This component relies on physics to calculate visibility, so observer game objects must also have a collider component on it. A game object with a Network Proximity Checker component must also have a Network Identity component. When you create a Network Proximity Checker component on a game object, Mirror also creates a Network Identity component on that game object if it does not already have one. Scene objects with a Network Proximity Checker component are disabled when they're out of range, and spawned objects are destroyed when they're out of range."
  },
  "Components/NetworkAnimator.html": {
    "href": "Components/NetworkAnimator.html",
    "title": "Network Animator",
    "keywords": "Network Animator The Network Animator component allows you to synchronize animation states for networked objects. It synchronizes state and parameters from an Animator Controller. Note that if you create a Network Animator component on an empty game object, Mirror also creates a Network Identity component and an Animator component on that game object. Client Authority Enable this to have changes to animation parameters sent from client to server. Animator Use this field to define the Animator component you want the Network Animator to synchronize with. Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds). Details The Network Animator ensures the synchronization of game object animation across the network, meaning that all players see the animation happen at the same. There are two kinds of authority for networked animation (see documentation on network authority ): NOTE: Animator Triggers are not synced directly. Call NetworkAnimator.SetTrigger instead. A game object with authority can use the SetTrigger function to fire an animation trigger on other clients. If the game object has authority on the client, you should animate it locally on the client that owns the game object. That client sends the animation state information to the server, which broadcasts it to all the other clients. For example, this may be suitable for player characters with client authority. If the game object has authority on the server, then you should animate it on the server. The server then sends state information to all clients. This is common for animated game objects that are not related to a specific client, such as scene objects and non-player characters, or server-authoritative clients."
  },
  "Guides/Communications/RemoteActions.html": {
    "href": "Guides/Communications/RemoteActions.html",
    "title": "Remote Actions",
    "keywords": "Remote Actions The network system has ways to perform actions across the network. These type of actions are sometimes called Remote Procedure Calls. There are two types of RPCs in the network system, Commands - which are called from the client and run on the server; and ClientRpc calls - which are called on the server and run on clients. The diagram below shows the directions that remote actions take: Commands Commands are sent from player objects on the client to player objects on the server. For security, Commands can only be sent from YOUR player object, so you cannot control the objects of other players. To make a function into a command, add the [Command] custom attribute to it, and add the “Cmd” prefix. This function will now be run on the server when it is called on the client. Any arguments will automatically be passed to the server with the command. Commands functions must have the prefix “Cmd” and cannot be static. This is a hint when reading code that calls the command - this function is special and is not invoked locally like a normal function. public class Player : NetworkBehaviour { void Update() { if (!isLocalPlayer) return; if (Input.GetKey(KeyCode.X)) CmdDropCube(); } // assigned in inspector public GameObject cubePrefab; [Command] void CmdDropCube() { if (cubePrefab != null) { Vector3 spawnPos = transform.position + transform.forward * 2; Quaternion spawnRot = transform.rotation; GameObject cube = Instantiate(cubePrefab, spawnPos, spawnRot); NetworkServer.Spawn(cube); } } } Be careful of sending commands from the client every frame! This can cause a lot of network traffic. It is possible to send commands from non-player objects that have client authority. These objects must have been spawned with client authority or have authority set with NetworkIdentity.AssignClientAuthority . Commands sent from these object are run on the server instance of the object, not on the associated player object for the client. ClientRpc Calls ClientRpc calls are sent from objects on the server to objects on clients. They can be sent from any server object with a NetworkIdentity that has been spawned. Since the server has authority, then there no security issues with server objects being able to send these calls. To make a function into a ClientRpc call, add the [ClientRpc] custom attribute to it, and add the “Rpc” prefix. This function will now be run on clients when it is called on the server. Any arguments will automatically be passed to the clients with the ClientRpc call.. ClientRpc functions must have the prefix “Rpc” and cannot be static. This is a hint when reading code that calls the method - this function is special and is not invoked locally like a normal function. public class Player : NetworkBehaviour { int health; public void TakeDamage(int amount) { if (!isServer) return; health -= amount; RpcDamage(amount); } [ClientRpc] void RpcDamage(int amount) { Debug.Log(\"Took damage:\" + amount); } } When running a game as a host with a local client, ClientRpc calls will be invoked on the local client even though it is in the same process as the server. So the behaviours of local and remote clients are the same for ClientRpc calls. TargetRpc Calls TargetRpc functions are called by user code on the server, and then invoked on the corresponding client object on the client of the specified NetworkConnection. The arguments to the RPC call are serialized across the network, so that the client function is invoked with the same values as the function on the server. These functions must begin with the prefix \"Target\" and cannot be static. Context Matters: If the first parameter of your TargetRpc method is a NetworkConnection then that's the connection that will receive the message regardless of context. If the first parameter is any other type, then the owner client of the object with the script containing your TargetRpc will receive the message. This example shows how a client can use a Command to make a request from the server ( CmdMagic ) by including its own connectionToClient as one of the parameters of the TargetRpc invoked directly from that Command: public class Player : NetworkBehaviour { int health; [Command] void CmdMagic(GameObject target, int damage) { target.GetComponent<Player>().health -= damage; NetworkIdentity opponentIdentity = target.GetComponent<NetworkIdentity>(); TargetDoMagic(opponentIdentity .connectionToClient, damage); } [TargetRpc] public void TargetDoMagic(NetworkConnection target, int damage) { // This will appear on the opponent's client, not the attacking player's Debug.Log($\"Magic Damage = {damage}\"); } [Command] void CmdHealMe() { health += 10; } [TargetRpc] public void TargetHealed(int amount) { // No NetworkConnection parameter, so it goes to owner Debug.Log($\"Health increased by {amount}\"); } } Arguments to Remote Actions The arguments passed to commands and ClientRpc calls are serialized and sent over the network. You can use any supported mirror type . Arguments to remote actions cannot be sub-components of game objects, such as script instances or Transforms."
  },
  "Guides/Communications/NetworkBehavior.html": {
    "href": "Guides/Communications/NetworkBehavior.html",
    "title": "NetworkBehaviour Callbacks",
    "keywords": "NetworkBehaviour Callbacks See also NetworkBehaviour in the API Reference. Like the Network Manager callbacks, there are a number of events relating to network behaviours that can occur over the course of a normal multiplayer game. These include events such as the host starting up, a player joining, or a player leaving. Each of these possible events has an associated callback that you can implement in your own code to take action when the event occurs. When you create a script which inherits from NetworkBehaviour , you can write your own implementation of what should happen when these events occur. To do this, you override the virtual methods on the NetworkBehaviour class with your own implementation of what should happen when the given event occurs. This page lists all the virtual methods (callbacks) that you can implement on NetworkBehaviour , and when they occur. Server mode When a client connects: OnStartServer OnRebuildObservers Start() function is called Client mode When a client connects: OnStartClient OnStartLocalPlayer OnStartAuthority Start() function is called Host mode These are only called on the Player Game Objects when a client connects: OnStartServer OnStartClient OnRebuildObservers OnStartAuthority OnStartLocalPlayer Start() function is called OnSetLocalVisibility"
  },
  "Guides/Communications/NetworkManager.html": {
    "href": "Guides/Communications/NetworkManager.html",
    "title": "Network Manager Callbacks",
    "keywords": "Network Manager Callbacks See also NetworkManager in the API Reference. There are a number of events that can occur over the course of the normal operation of a multiplayer game, such as the host starting up, a player joining, or a player leaving. Each of these possible events has an associated callback that you can implement in your own code to take action when the event occurs. To do this for the NetworkManager , you need to create your own script which inherits from NetworkManager . You can then override the virtual methods on NetworkManager with your own implementation of what should happen when the given event occurs. This page lists all the virtual methods (the callbacks) that you can implement on the NetworkManager , and when they occur. The callbacks that occur, and the order they occur, vary slightly depending on which mode your game is running in, so each mode’s callbacks are listed separately below. A game can be running in one of three modes, host, client, or server-only. The callbacks for each mode are listed below: Host Mode: When the host is started: Start() function is called OnStartHost OnStartServer OnServerConnect OnStartClient OnClientConnect OnServerSceneChanged OnServerReady OnServerAddPlayer OnClientChangeScene OnClientSceneChanged When a client connects: OnServerConnect OnServerReady OnServerAddPlayer When a client disconnects: OnServerDisconnect When the host is stopped: OnStopHost OnStopServer OnStopClient Client Mode When the client starts: Start() function is called OnStartClient OnClientConnect OnClientChangeScene OnClientSceneChanged When the client stops: OnStopClient OnClientDisconnect Server Mode When the server starts: Start() function is called OnStartServer OnServerSceneChanged When a client connects: OnServerConnect OnServerReady OnServerAddPlayer When a client disconnects: OnServerDisconnect When the server stops: OnStopServer"
  },
  "Guides/DevServer/AWS/index.html": {
    "href": "Guides/DevServer/AWS/index.html",
    "title": "Amazon Web Services (AWS)",
    "keywords": "Amazon Web Services (AWS) During this section we will focus on using a Windows instance and connecting from a Windows computer. NOTE : AWS requires a payment method/credit card added before being able to use a Windows server. Don't forget to read up on the free tier limitations . During this example we will be using the free tier of the EC2 option, which gives us the possibility to use a Windows instance (if you have already added a payment method). For more information about which services offer a Free Tier, see AWS Free Tier . These are the steps we will go through from start to finish: Account creation Setting up an instance with the EC2 Management Console Configuring the server via RDP (Remote Desktop) Setting up the firewall to allow connections through Testing the connection 1. Account Creation Go to the Account creation page and sign up with your details and payment method (e.g. credit card). Adding the payment method is necessary to run a windows instance on AWS. 2. Setting up an instance with the EC2 Management Console After setting up your account you should be logged in. Always make sure you're in your correct region so it's a good habit to check in the top right corner. Change it to the closest location to you now. After this click on Services in the top left corner and click on EC2. This will bring you to the EC2 instance dashboard and ready to Launch your instance! Click on \"Launch Instance\" . There are 7 steps to creating your AWS Instance: Choose an Amazon Machine Image (AMI) Choose Instance Type Configure Instance Add Storage Add Tags Configure Security Group Review Step 1: Choose an Amazon Machine Image Scroll down until you see the Microsoft Windows Server 2019 Base (take the newest one if this is outdated). Make sure that the option you select has the \"Free Tier Eligible\" under the icon and click on \"Select\". Step 2: Choose Instance Type Make sure you choose the instance type with the \"free tier eligible\", at the time of writing this is the t2.micro instance. Click on \"Next: Configure Instance Details\" . Do not click on Review and Launch. Step 3: Configure Instance Nothing has to be changed at this step. Keep it default. Click on \"Next: Add Storage\" . Step 4: Add Storage Nothing has to be changed. Keep it default. The 30GB is more than you need but there will be an error if you choose a lower amount. Keep in mind that you can always click \"Previous\" if you need to return, you do not need to repeat the entire process if you make a mistake (unless you click Launch at the end). Click on \"Next: Add Tags\" to continue. Step 5: Add Tags Nothing has to be changed. Keep it default. Click on \"Next: Configure Security Groups\" Step 6: Configure Security Groups IMPORTANT STEP This makes it possible to connect to your instance from outside for: RDP (needed for this example) For clients connecting through port 7777 for your Mirror Project. SSH (if needed) Create a new security group and you can give it your own name and description. Add the following rules: RDP with source \"Anywhere\", Description can be whatever but put it as Remote Desktop Program. Custom TCP Rule with port 7777 and source \"Anywhere\", Description can be whatever but put it as Mirror. SSH with source \"Anywhere\", Description can be whatever but put it as SSH. SSH is not strictly necessary but can be used to remote connect to it through other means than the RDP. You can ignore the warning about the source as this is just a testing environment. In the future you might wish to restrict this but you will almost never know the clients' connection IP's beforehand. Click on \"Next: Review and Launch\" Step 7: Review Almost there! Make sure everything is correct and you are using the free tier, then click on \"Launch\" . One more thing: A window will pop up asking for your key pair. Just create a new one by selecting the dropdown: \"Create a new key pair\" and give it a name, click on \"Download Key Pair\" . Keep the key file (.PEM File) somewhere secure (To be 100% certain, back it up somewhere). YOU CANNOT ACCESS THE CREATED INSTANCE WITHOUT THIS KEY Now you can (finally) click on \"Launch Instances\" ! Go back to your EC2 dashboard by clicking on \"Services\" at the top left and clicking on EC2. Now you see you have \"Running Instances: 1\". Click on \"Running Instances\" to continue . A new instance might take around 5-10 minutes to set up. Refresh the page after 10 minutes if nothing changes. Now you did all this but you want to get ON the dedicated server right? Perfect! The next step will get you up and running! 3. Configuring the server via RDP (Remote Desktop) Time to get the RDP file so you can start connecting. There are a few things we'll need: RDP file with the key pair added to it Configure RDP file once downloaded to allow getting files from our C: drive or other drives (so you can easily get your zip project) Enter the windows Admin password once you start the RDP file Once you've done this, you should be able to continue using the same RDP file. RDP file with the key pair added to it Get the password before clicking Download Copy the Password for later Now click on \"Download Remote Desktop File\" . The RDP file will be downloaded. Configure RDP file for easy file access Go to your freshly downloaded RDP file and rightclick it and then click \"Edit\". Go to the third tab \"Local sources\", at the bottom click \"more\" under local devices and sources. On the new window select your C: drive or any other drive. This is your own computer your connecting from. For easy file exchange. Perfect! Now you can run the RDP file! The RDP file will ask a password. If you forgot your password you can get it back by rightclicking the instance and clicking on \"Get Windows Password\". You will be asked to re-enter your key pair (.PEM) file and decrypt the message. Once done you will be able to copy the password. There you have it! Now you have your password and Remote Desktop should show you logging into your dedicated server! Setting up the firewall to allow connections through Go to the windows firewall settings, go to the advanced firewall settings and go to inbound rules. Add a new rule and choose the port type. Select TCP and enter the 7777 port (or any other if you use another port in Mirror). Continue clicking next and keep things default. Close all the windows when done. AWESOME! You now have everything set up to accept incoming requests on port 7777 . 4. Testing the connection Before you can (finally) test out your server build of your project you need to get it on the dedicated server! Place your (zipped) server build at the root of your added drive (C: or another) to make it easier to find it fast. Go to \"My Computer\" and because of our previous changes to the RDP we should now see your local drive under \"Devices and Drives\". Double click it and because you placed your zipped server build on that drive, you should see it immediatly when it's done loading. Now unzip the project in a new folder on the dedicated server's desktop and run it. Want to test if it sees the 7777 port is open after you started your Mirror server? Get your IPv4 public IP from the EC2 Management Console from your instance and use it on your client to connect to that IP. Go to PortChecker and enter the Dedicated Server IP address and enter port 7777. NOTE: If you are not running your game / project then the port will be closed. It's only open when the server is running."
  },
  "Guides/Visibility.html": {
    "href": "Guides/Visibility.html",
    "title": "Network Visibility",
    "keywords": "Network Visibility Multiplayer games use the concept of network visibility to determine which players can see which game objects at any given time during game play. In a game that has a moving viewpoint and moving game objects, it’s common that players cannot see everything that is happening in the game at once. If a particular player, at a certain point in time during game play, cannot see most of the other players, non-player characters, or other moving or interactive things in your game, there is usually no need for the server to send information about those things to the player’s client. This can benefit your game in two ways: It reduces the amount of data sent across the network between players. This can help improve the responsiveness of your game, and reduce bandwidth use. The bigger and more complex your multiplayer game, the more important this issue is. It also helps prevent some cheating. Since a player client does not have information about things that can’t be seen, a hack on that player’s computer cannot reveal the information. The idea of “visibility” in the context of networking doesn’t necessarily relate to whether game objects are directly visible on-screen. Instead, it relates to whether data should or shouldn’t be sent about the game object in question to a particular client. Put simply, if a client can’t ‘see’ an game object, it does not need to be sent information about that game object across the network. Ideally you want to limit the amount of data you are sending across the network to only what is necessary, because sending large amounts of unnecessary data across the network can cause network performance problems. However, it can be also be resource intensive or complex to determine accurately whether a game object truly visible to a given player, so it’s often a good idea to use a more simple calculation for the purposes of determining whether a player should be sent networked data about it - i.e. whether it is ‘Network Visible’. The balance you want to achieve when considering this is between the cost of the complexity of the calculation for determining the visibility, and the cost of sending more information than necessary over the network. A very simple way to calculate this is a distance (proximity) check, and Mirror provides a built-in component for this purpose. Network Proximity Checker Component Mirror’s Network Proximity Checker component is simplest way to implement network visibility for players. It works in conjunction with the physics system to determine whether game objects are close enough (that is, “visible” for the purposes of sending network messages in your multiplayer game). Network Scene Checker Component Mirror's Network Scene Checker component can be used to isolate players and networked objects on the server in additive scene instances. Network Visibility on Remote Clients When a player on a remote client joins a networked game, only game objects that are network-visible to the player will be spawned on that remote client. This means that even if the player enters a large world with many networked game objects, the game can start quickly because it does not need to spawn every game object that exists in the world. Note that this applies to networked game objects in your Scene, but does not affect the loading of Assets. Unity still takes time to load the Assets for registered Prefabs and Scene game objects. When a player moves within the world, the set of network-visible game objects changes. The player’s client is told about these changes as they happen. The ObjectHide message is sent to clients when a game object becomes no longer network-visible. By default, Mirror destroys the game object when it receives this message. When a game object becomes visible, the client receives an ObjectSpawn message, as if Mirror has spawned the game object for the first time. By default, the game object is instantiated like any other spawned game object. Network Visibility on the Host The host shares the same Scene as the server, because it acts as both the server and the client to the player hosting the game. For this reason, it cannot destroy game objects that are not visible to the local player. Instead, there is the virtual method OnSetLocalVisibility in the NetworkVisibility class that is invoked. This method is invoked on all scripts that inherit from NetworkVisibility on game objects that change visibility state on the host. The default implementation of OnSetLocalVisibility disables or enables all renderer components on the game object. If you want to customize this implementation, you can override the method in your script, and provide a new behavior for how the host (and therefore the local client) should respond when a game object becomes network-visible or invisible (such as disabling HUD elements or renderers). Customizing Network Visibility Sometimes you might want to use other kinds of visibility check, such as grid-based rules, line-of-sight tests, navigation path tests, or any other type of test that suits your game. To do this, you can create your own custom Network Observer from a script template via the Assets menu by clicking Create -> Mirror -> Network Observer. It may be helpful to understand how the Network Proximity Checker works. The Network Proximity Checker is implemented using the public visibility interface of Mirror’s HLAPI. Using this same interface, you can implement any kind of visibility rules you desire. Each NetworkIdentity keeps track of the set of players that it is visible to. The players that a NetworkIdentity game object is visible to are called the “observers” of the NetworkIdentity. The Network Proximity Checker calls the RebuildObservers method on the Network Identity component at a fixed interval (set using the “Vis Update Interval” value in the inspector), so that the set of network-visible game objects for each player is updated as they move around. In the NetworkVisibility class (which your custom observer scripts inherit from), there are some virtual functions for determining visibility. These are: OnCheckObserver This method is called on the server, on each networked game object when a new player enters the game. If it returns true, that player is added to the object’s observers. The Network Proximity Checker does a simple distance check in its implementation of this function, and uses Physics.OverlapSphereNonAlloc to find the players that are within the visibility distance for this object. OnRebuildObservers This method is called on the server when RebuildObservers is invoked. This method expects the set of observers to be populated with the players that can see the object. The NetworkServer then handles sending ObjectHide and ObjectSpawn messages based on the differences between the old and new visibility sets. OnSetHostVisibility This method is called on the server by the visibility system for objects on a host. Objects on a host (with a local client) cannot be disabled or destroyed when they are not visibile to the local client. So this function is called to allow custom code to hide these objects. A typical implementation will disable renderer components on the object. This is only called on local clients on a host. You can check whether any given networked game object is a player by checking if its NetworkIdentity has a valid connectionToClient. For example: int hitCount = Physics.OverlapSphereNonAlloc(transform.position, visRange, hitsBuffer3D, castLayers); for (int i = 0; i < hitCount; i++) { Collider hit = hitsBuffer3D[i]; NetworkIdentity identity = hit.GetComponent<NetworkIdentity>(); if (identity != null && identity.connectionToClient != null) observers.Add(identity.connectionToClient); }"
  },
  "Guides/NetworkDiscovery.html": {
    "href": "Guides/NetworkDiscovery.html",
    "title": "Network Discovery",
    "keywords": "Network Discovery Suppose your are next to a friend. He starts a game in host mode and you want to join him. How will your phone locate his? Finding out his IP address is not exactly intuitive or something kids can do. To solve this problem you can use Network Discovery. When your game starts, it sends a message in your current network asking \"Is there any server available?\". Any server within the same network will reply and provide information about how to connect to it. Mirror comes with a simple implementation of Network Discovery you can simply use in your game. It also provides a way for you to extend it so that you can pass additional data during the discovery phase. Quick Start To use Network Discovery follow these steps: Create a gameobject with a NetworkManager if you have not done so already Do not add a NetworkManagerHUD. Discovery has a different UI component. Add a NetworkDiscoveryHUD component to the NetworkManager gameobject. A NetworkDiscovery component will be automatically added and wired up to your HUD. Add a player to the NetworkManager if you have not done so. Build and run a standalone version Click on Start Host Start play mode in the editor and click on Find Servers The editor should find the standalone version and display a button Click on the button to connect to it. The NetworkDiscoveryHUD is provided as a simple and quick way to get started, but you will probably want to replace it with your own user interface. Custom Network Discovery You can completely replace the user interface by adding your own interface (typically Unity UI based) instead of the default NetworkDiscoveryHUD. You do still need the NetworkDiscovery component to do the heavy lifting. Sometimes you want to provide more information in the discovery messages. Some use cases could include: The client can show if the server is in PvP or PvE mode The client can show how full the servers are. The client can show the ping to each server so the player can chose the fastest server The client can show the language The client can show if the server is password protected To do this, we've provided a Template , so from the Assets menu, click Create > Mirror > Network Discovery. This will create a script in your project with 2 empty message classes and a custom NetworkDiscovery class that inherits from NetworkDiscoveryBase and has all the override methods included and documented for you. The message classes define what is sent between the client and server. As long as you keep your messages simple using the data types that Mirror can serialize, you won't need to write custom serializers for them. public class DiscoveryRequest : MessageBase { public string language=\"en\"; // Add properties for whatever information you want sent by clients // in their broadcast messages that servers will consume. } public class DiscoveryResponse : MessageBase { enum GameMode {PvP, PvE}; // you probably want uri so clients know how to connect to the server public Uri uri; public GameMode GameMode; public int TotalPlayers; public int HostPlayerName; // Add properties for whatever information you want the server to return to // clients for them to display or consume for establishing a connection. } The custom NetworkDiscovery class contains the overrides for handling the messages above. You may want to refer to the NetworkDiscovery.cs script in the Components/Discovery folder to see how these should be implemented. public class NewNetworkDiscovery: NetworkDiscoveryBase<DiscoveryRequest, DiscoveryResponse> { #region Server protected override void ProcessClientRequest(DiscoveryRequest request, IPEndPoint endpoint) { base.ProcessClientRequest(request, endpoint); } protected override DiscoveryResponse ProcessRequest(DiscoveryRequest request, IPEndPoint endpoint) { // TODO: Create your response and return it return new DiscoveryResponse(); } #endregion #region Client protected override DiscoveryRequest GetRequest() { return new DiscoveryRequest(); } protected override void ProcessResponse(DiscoveryResponse response, IPEndPoint endpoint) { // TODO: a server replied, do something with the response such as invoking a unityevent } #endregion }"
  },
  "Guides/Profiler.html": {
    "href": "Guides/Profiler.html",
    "title": "Mirror Network Profiler",
    "keywords": "Mirror Network Profiler The mirror profiler is part of the Mirror Pro suit. As of this writing it is accessible to our Github Supporters. Installation Make sure you have the latest version of Mirror Become a Github Supporter if you haven't. Download the profiler Install the unity package in your project Usage In Unity menu, click on Open Window -> Analysis -> Mirror Network Profiler. The profiler view will appear You may dock the profiler anywhere you want Start your game in the editor Press \"Record\" in the profiler Begin your game as host, client or server At the top a chart will show messages coming in and out Click the chart to select a frame The profiler will display information about all the messages sent and received in that frame Currently the messages display the following fields: In/Out: Whether the message was received (in) or sent (out) Name: Short name of the message, if the message was a [Command] , [ClientRpc] , [TargetRpc] or [TargetEvent] , this will display the name of the method, otherwise it will display the name of the message class. Bytes: The size of the message in bytes Count: In the case of out messages, this will contain how many clients the message was sent to. Total Bytes: the size of the message multiplied by the amount of clients the message was sent to (Bytes * Count) Channel: The channel used to send the message. As of this writing, we cannot determine the channel for inbound messages, so it displays -1. This will be improved in future versions. Transports can use channels for many purposes such as reliable, unreliable, encrypted, compressed, etc. Optimizing bandwidth On most transports, the total bandwidth is dominated by the Count column. This is because each message is packaged in a TCP or UDP frame, which have large headers. If you are sending multiple [Command] in the same frame, consider consolidating them into a single [Command] call if it makes sense If you see a large Count number on a specific message, consider adding a NetworkProximityChecker to your object, so that it is only visible to nearby players instead of the entire world. This can dramatically reduce the Count (and total bytes) depending on your game. If you are sending a message every single frame, consider changing your logic so that you only send messages when things change, or use a timer. Consider using SyncToOwner feature so that only the owner gets a message when private information such as inventory changes. This can dramatically reduce the Count depending on your game. If you have a lot of [ClientRpc] calls that synchronize data, consider using [SyncVar] and synclists instead. They can reduce the amount of messages because they only send deltas when they change, plus they get batched together, so hundreds of variables can be synchronized with a single message."
  },
  "Guides/ClockSync.html": {
    "href": "Guides/ClockSync.html",
    "title": "Clock Synchronization",
    "keywords": "Clock Synchronization For many algorithms you need the clock to be synchronized between the client and the server. Mirror does that automatically for you. To get the current time use this code: double now = NetworkTime.time; It will return the same value in the client and the servers. It starts at 0 when the server starts. Note the time is a double and should never be casted to a float. Casting this down to a float means the clock will lose precision after some time: after 1 day, accuracy goes down to 8 ms after 10 days, accuracy is 62 ms after 30 days , accuracy is 250 ms after 60 days, accuracy is 500 ms Mirror will also calculate the RTT time as seen by the application: double rtt = NetworkTime.rtt; You can measure accuracy. double time_standard_deviation = NetworkTime.timeSd; for example, if this returns 0.2, it means the time measurements swing up and down roughly 0.2 s Network hiccups are compensated against by smoothing out the values using EMA. You can configure how often you want the the ping to be sent: NetworkTime.PingFrequency = 2.0f; You can also configure how many ping results are used in the calculation: NetworkTime.PingWindowSize = 10;"
  },
  "Guides/IDs.html": {
    "href": "Guides/IDs.html",
    "title": "Got ID?",
    "keywords": "Got ID? Asset Id Mirror uses GUID for Asset Ids. Every prefab with a NetworkIdentity component has an Asset Id, which is simply Unity's AssetDatabase.AssetPathToGUID converted to 16 bytes. Mirror needs that to know which prefabs to spawn. Scene Id Mirror uses uint for Scene Ids. Every game object with a NetworkIdentity in the scene (hierarchy) is assigned a scene id in OnPostProcessScene. Mirror needs that to distinguish scene objects from each other, because Unity has no unique id for different game objects in the scene. Network Instance Id (a.k.a. NetId) Mirror uses uint for NetId. Every NetworkIdentity is assigned a NetId in NetworkIdentity.OnStartServer, or after spawning it. Mirror uses the id when passing messages between client and server to tell which object is the recipient of the message. Connection Id Every network connection has a connection id, which is assigned by the low level Transport layer. Connection id 0 is reserved for the local connection when the server is also a client (host)"
  },
  "General/Integrations/index.html": {
    "href": "General/Integrations/index.html",
    "title": "Integrations",
    "keywords": "Integrations Here we will maintain a list of assets known to be compatible with Mirror. If you know of others, please have the publisher contact us directly in our Discord . SmoothSync Weather Maker Noble Connect Free Dissonance Voice Chat RTS Engine Rucksack Steamworks Networking Master Audio Multiplayer"
  },
  "General/index.html": {
    "href": "General/index.html",
    "title": "General Overview",
    "keywords": "General Overview Mirror’s multiplayer High Level API (HLAPI) is a system for building multiplayer capabilities for Unity games. It is built on top of the lower level transport real-time communication layer, and handles many of the common tasks that are required for multiplayer games. While the transport layer supports any kind of network topology, the HLAPI is a server authoritative system; although it allows one of the participants to be a client and the server at the same time, so no dedicated server process is required. Working in conjunction with the internet services, this allows multiplayer games to be played over the internet with little work from developers. The HLAPI is focused on ease of use and iterative development and provides useful functionality for multiplayer games, such as: Message handlers General purpose high performance serialization Distributed object management State synchronization Network classes: Server, Client, Connection, etc The HLAPI is built from a series of layers that add functionality: Server and Host In Mirror’s High Level API (HLAPI) system, multiplayer games include: Server A server is an instance of the game which all other players connect to when they want to play together. A server often manages various aspects of the game, such as keeping score, and transmit that data back to the client. Clients Clients are instances of the game that usually connect from different computers to the server. Clients can connect over a local network, or online. A client is an instance of the game that connects to the server, so that the person playing it can play the game with other people, who connect on their own clients. The server might be either a “dedicated server”, or a “host server”. Dedicated server This is an instance of the game that only runs to act as a server. Host server When there is no dedicated server, one of the clients also plays the role of the server. This client is the “host server”. The host server creates a single instance of the game (called the host), which acts as both server and client. The diagram below represents three players in a multiplayer game. In this game, one client is also acting as host, which means the client itself is the “local client”. The local client connects to the host server, and both run on the same computer. The other two players are remote clients - that is, they are on different computers, connected to the host server. The host is a single instance of your game, acting as both server and client at the same time. The host uses a special kind of internal client for local client communication, while other clients are remote clients. The local client communicates with the server through direct function calls and message queues, because it is in the same process. It actually shares the Scene with the server. Remote clients communicate with the server over a regular network connection. When you use Mirror’s HLAPI, this is all handled automatically for you. One of the aims of the multiplayer system is for the code for local clients and remote clients to be the same, so that you only have to think about one type of client most of the time when developing your game. In most cases, Mirror handles this difference automatically, so you should rarely need to think about the difference between your code running on a local client or a remote client. Instantiate and Spawn When you make a single player game In Unity, you usually use the GameObject.Instantiate method to create new game objects at runtime. However, with a multiplayer system, the server itself must “spawn” game objects in order for them to be active within the networked game. When the server spawns game objects, it triggers the creation of game objects on connected clients. The spawning system manages the lifecycle of the game object, and synchronizes the state of the game object based on how you set the game object up. For more details about networked instantiating and spawning, see documentation on Spawning game objects . Players and Local Players Mirror’s multiplayer HLAPI system handles player game objects differently to non-player game objects. When a new player joins the game (when a new client connects to the server), that player’s game object becomes a “local player” game object on the client of that player, and Mirror associates the player’s connection with the player’s game object. Mirror associates one player game object for each person playing the game, and routes networking commands to that individual game object. A player cannot invoke a command on another player’s game object, only their own. For more details, see documentation on Player game objects . Authority Servers and clients can both manage a game object’s behavior. The concept of “authority” refers to how and where a game object is managed. Mirror’s HLAPI is based around “server authority” as the default state, where the Server has authority over all game objects. Player game objects are a special case and treated as having “local authority”. You may want to build your game using a different system of authority - for more details, see Network Authority ."
  },
  "General/ScriptTemplates.html": {
    "href": "General/ScriptTemplates.html",
    "title": "Script Templates",
    "keywords": "Script Templates We've added Script Templates to make it easier to create derived class scripts that inherit from our base classes. All possible overrides are already made for you and organized They're all fully commented as to what they all do Base method calls are all in place where needed so you can see what they already do. Each has links at the top to their doc page(s) After importing Mirror and restarting Unity, the Mirror section will appear under the Assets > Create menu, as well as the context menu that comes up when you right-click on any folder in your project. You'll be prompted for the file name like any other asset creation. Hopefully these templates will be helpful to new users of Mirror to learn what methods are available in various classes, as well as just being more convenient for everyone."
  },
  "Examples/AdditiveScenes/index.html": {
    "href": "Examples/AdditiveScenes/index.html",
    "title": "Additive Scenes",
    "keywords": "Additive Scenes General description of Additive Scenes example."
  },
  "Examples/Room/index.html": {
    "href": "Examples/Room/index.html",
    "title": "Room",
    "keywords": "Room General description of Room example."
  },
  "Transports/Discord.html": {
    "href": "Transports/Discord.html",
    "title": "Discord Transport",
    "keywords": "Discord Transport Discord Transport is a networking transport that enables sending networking packets via Discord's Game SDK . Latest Release Getting Started Features Discord's Relay - No need to port forward or worry about NAT issues! No IPs - No IPs mean no IP leaks or hassle Encryption - Discord automatically encrypts all your data Credits Derek - Made Discord-Mirror"
  },
  "Transports/index.html": {
    "href": "Transports/index.html",
    "title": "Transports Overview",
    "keywords": "Transports Overview Mirror is a high level Networking Library that can use several different low level transports. To use a transport, simply add it as component to the NetworkManager and drag it into the NetworkManager's Transport field. TCP - Telepathy Simple, message based, MMO Scale TCP networking in C#. And no magic. TCP - Apathy Apathy is a fast, lightweight, allocation-free low level TCP library for Unity developed by vis2k. Apathy was developed in native C for maximum MMO Scale networking performance. TCP - Booster The Mirror Booster uncorks your multiplayer game by moving the Networking load out of Unity! WebGL - WebSockets WebSockets transport layer for Mirror that target WebGL clients, without relying on Unity's stodgy old LLAPI. Multiplexer Multiplexer is a bridging transport to allow a server to handle clients on different transports concurrently, for example desktop clients using Telepathy together with WebGL clients using Websockets. Fallback Fallback is a compatibility transport for transports that don't run on all platforms and need fallback options to cover all other platforms. Discord Discord Transport is a networking transport that enables sending networking packets via Discord's Game SDK . UDP - Ignorance Ignorance implements a reliable and unreliable sequenced UDP transport based on ENet. UDP - LiteNetLib4Mirror LiteNetLib4Mirror implements a UDP transport based on LiteNetLib with Network Discovery and uPnP included. Steam - Fizzy A complete rebuild utilising Async (Previously SteamNetNetworkTransport) of a Steam P2P network transport layer."
  },
  "Transports/Multiplexer.html": {
    "href": "Transports/Multiplexer.html",
    "title": "Multiplex Transport",
    "keywords": "Multiplex Transport The MultiplexTransport is not a transport itself, but it allows you to combine other transports so that your clients can connect to your servers via either one of them. A common use case for the MultiplexTransport is a server listening to both websockets and TCP. Your webgl clients can connect to the server using websockets and your mobile or desktop clients can connect to the same server via TCP. In HLAPI, you had to chose between websockets and UDP, but you cannot use both at the same time. You can configure any number of transports in the MultiplexTransport. To use the MultiplexTransport follow these steps: Add a gameobject with a NetworkManager to your scene if you have not done so By default, Unity will add TelepathyTransport to your NetworkManager game object Add a MultiplexTransport component to the gameobject Assign the MultiplexTransport component in your NetworkManager's transport Add a WebsocketTransport component to the gameobject Add the TelepathyTransport component to the MultiplexTransport as the first transport Add the WebsocketTransport component to the MultiplexTransport as the second transport Please note that Telepathy and WebsocketTransport cannot listen to the same port. By default Telepathy listens to 7777 and the websocket transport listens to 7778. If you build your game as a webgl game, the TelepathyTransport will be skipped and your client will use the websocket transport. If you build your game as a mobile or desktop app, it will choose TelepathyTransport. The server will happily accept connections from both. Here is what the configuration should look like:"
  },
  "Transports/Fallback.html": {
    "href": "Transports/Fallback.html",
    "title": "Fallback Transport",
    "keywords": "Fallback Transport The FallbackTransport can be used to work around transport platform limits. For example, our Apathy transport is currently only available on Windows, Mac and Linux where as Telepathy is available on all Platforms. Apathy has significant performance improvements, and ideally we would want Mirror to use Apathy if on Windows/Mac/Linux and fall back to Telepathy otherwise. This is what the FallbackTransport allows us to do. Usage: Add a gameobject with a NetworkManager to your scene if you have not done so By default, Unity will add TelepathyTransport to your NetworkManager game object Add a FallbackTransport component to the gameobject Assign the FallbackTransport component in your NetworkManager's transport Add a ApathyTransport component to the gameobject Add both ApathyTransport and TelepathyTransport to the FallbackTransport's transport property. Important: all fallback transport need to be binary compatible with each other. For example, it might happen that the server runs Apathy and a client connects to it with Telepathy."
  },
  "Transports/WebSockets.html": {
    "href": "Transports/WebSockets.html",
    "title": "WebSockets Transport",
    "keywords": "WebSockets Transport General description of WebSockets"
  },
  "Components/NetworkIdentity.html": {
    "href": "Components/NetworkIdentity.html",
    "title": "Network Identity",
    "keywords": "Network Identity See also NetworkIdentity in the API Reference. The Network Identity component is at the heart of the Unity networking high-level API. It controls a game object’s unique identity on the network, and it uses that identity to make the networking system aware of the game object. It offers two different options for configuration and they are mutually exclusive, which means either one of the options or none can be checked. Server Only Tick this checkbox to ensure that Unity only spawns the game object on the server, and not on clients. Instantiated Network Game Objects With the Mirror’s server-authoritative networking system, the server must spawn networked game objects with network identities, using NetworkServer.Spawn . This automatically creates them on clients that are connected to the server, and assigns them a netId . You must put a Network Identity component on any Prefabs that spawn at runtime for the network system to use them. See Object Spawning for more information. Scene-based Network Game Objects You can also network game objects that are saved as part of your Scene (for example, environmental props). Networking game objects makes them behave slightly differently, because you need to have them spawn across the network. When building your game, Unity disables all Scene-based game objects with Network Identity components. When a client connects to the server, the server sends spawn messages to tell the client which Scene game objects to enable and what their most up-to-date state information is. This ensures the client’s game does not contain game objects at incorrect locations when they start playing, or that Unity does not spawn and immediately destroy game objects on connection (for example, if an event removed the game object before that client connected). See Networked Scene Game Objects for more information. Preview Pane Information This component contains network tracking information, and displays that information in the preview pane. For example, the scene ID, network ID and asset ID the object has been assigned. This allows you to inspect the information which can be useful for investigation and debugging. At runtime there is more information to display here (a disabled NetworkBehaviour is displayed non-bold):"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "Guides/GameObjects/SpawnPlayerCustom.html": {
    "href": "Guides/GameObjects/SpawnPlayerCustom.html",
    "title": "Custom Character Spawning",
    "keywords": "Custom Character Spawning Many games need character customization. You may want to pick the color of the hair, eyes, skin, height, race, etc. By default Mirror will instantiate the player for you. While that is convenient, it might prevent you from customizing it. Mirror provides the option of overriding player creation and customize it. Create a class that extends NetworkManager if you have not done so. For example: public class MMONetworkManager : NetworkManager { ... } and use it as your Network manager. Open your Network Manager in the inspector and disable the \"Auto Create Player\" Boolean. Create a message that describes your player. For example: public class CreateMMOCharacterMessage : MessageBase { public Race race; public string name; public Color hairColor; public Color eyeColor; } public enum Race { None, Elvish, Dwarvish, Human } Create your player prefabs (as many as you need) and add them to the \"Register Spawnable Prefabs\" in your Network Manager, or add a single prefab to the player prefab field in the inspector. Send your message and register a player: public class MMONetworkManager : NetworkManager { public override void OnStartServer() { base.OnStartServer(); NetworkServer.RegisterHandler<CreateMMOCharacterMessage>(OnCreateCharacter); } public override void OnClientConnect(NetworkConnection conn) { base.OnClientConnect(conn); // you can send the message here, or wherever else you want CreateMMOCharacterMessage characterMessage = new CreateMMOCharacterMessage { race = Race.Elvish, name = \"Joe Gaba Gaba\", hairColor = Color.red, eyeColor = Color.green }; conn.Send(characterMessage); } void OnCreateCharacter(NetworkConnection conn, CreateMMOCharacterMessage message) { // playerPrefab is the one assigned in the inspector in Network // Manager but you can use different prefabs per race for example GameObject gameobject = Instantiate(playerPrefab); // Apply data from the message however appropriate for your game // Typically Player would be a component you write with syncvars or properties Player player = gameobject.GetComponent<Player>(); player.hairColor = message.hairColor; player.eyeColor = message.eyeColor; player.name = message.name; player.race = message.race; // call this to use this gameobject as the primary controller NetworkServer.AddPlayerForConnection(conn, gameobject); } } Ready State In addition to players, client connections also have a “ready” state. The host sends clients that are ready information about spawned game objects and state synchronization updates; clients which are not ready are not sent these updates. When a client initially connects to a server, it is not ready. While in this non-ready state, the client can do things that don’t require real-time interactions with the game state on the server, such as loading Scenes, allowing the player to choose an avatar, or fill in log-in boxes. Once a client has completed all its pre-game work, and all its Assets are loaded, it can call ClientScene.Ready to enter the “ready” state. The simple example above demonstrates implementation of ready states; because adding a player with NetworkServer.AddPlayerForConnection also puts the client into the ready state if it is not already in that state. Clients can send and receive network messages without being ready, which also means they can do so without having an active player game object. So a client at a menu or selection screen can connect to the game and interact with it, even though they have no player game object. See documentation on Network Messages for more details about sending messages without using commands and RPC calls. Switching Players To replace the player game object for a connection, use NetworkServer.ReplacePlayerForConnection . This is useful for restricting the commands that players can issue at certain times, such as in a pregame room screen. This function takes the same arguments as AddPlayerForConnection , but allows there to already be a player for that connection. The old player game object does not have to be destroyed. The NetworkRoomManager uses this technique to switch from the NetworkRoomPlayer game object to a game play player game object when all the players in the room are ready. You can also use ReplacePlayerForConnection to respawn a player or change the object that represents the player. In some cases it is better to just disable a game object and reset its game attributes on respawn. The following code sample demonstrates how to actually replace the player game object with a new game object: public class MyNetworkManager : NetworkManager { public void ReplacePlayer(GameObject newPrefab) { NetworkConnection conn = NetworkClient.connection; // Cache a reference to the current player object GameObject oldPlayer = conn.identity.gameObject; // Instantiate the new player object and broadcast to clients NetworkServer.ReplacePlayerForConnection(conn, Instantiate(newPrefab)); // Remove the previous player object that's now been replaced NetworkServer.Destroy(oldPlayer); } } If the player game object for a connection is destroyed, then that client cannot execute Commands. They can, however, still send network messages. To use ReplacePlayerForConnection you must have the NetworkConnection game object for the player’s client to establish the relationship between the game object and the client. This is usually the property connectionToClient on the NetworkBehaviour class, but if the old player has already been destroyed, then that might not be readily available. To find the connection, there are some lists available. If using the NetworkRoomManager , then the room players are available in roomSlots . The NetworkServer also has lists of connections ."
  },
  "Guides/GameObjects/SpawnPlayer.html": {
    "href": "Guides/GameObjects/SpawnPlayer.html",
    "title": "Player Game Objects",
    "keywords": "Player Game Objects Mirror’s multiplayer HLAPI system handles player game objects differently to non-player game objects. When a new player joins the game (when a new client connects to the server), that player’s game object becomes a “local player” game object on the client of that player, and Unity associates the player’s connection with the player’s game object. Unity associates one player game object for each person playing the game, and routes networking commands to that individual game object. A player cannot invoke a command on another player’s game object, only their own. The NetworkBehaviour class (which you derive from to create your network scripts) has a property called isLocalPlayer. On each client’s player game object, Mirror sets that property to true on the NetworkBehaviour script, and invokes the OnStartLocalPlayer() callback. This means each client has a different game object set up like this, because on each client a different game object is the one that represents the local player. The diagram below shows two clients and their local players. Only the player game object that is “yours” (from your point of view as the player) has the isLocalPlayer flag set. Usually you should set this flag in script to determine whether to process input, whether to make the camera track the game object, or do any other client-side things that should only occur for the player belonging to that client. Player game objects represent the player (that is, the person playing the game) on the server, and have the ability to run commands from the player’s client. These commands are secure client-to-server remote procedure calls. In this server-authoritative system, other non-player server-side game objects cannot receive commands directly from client-side game objects. This is both for security, and to reduce the complexity of building your game. By routing all incoming commands from users through the player game object, you can ensure that these messages come from the right place, the right client, and can be handled in a central location. The Network Manager adds a player every time a client connects to the server. In some situations though, you might want it not to add players until an input event happens - such as a user pressing a “start” button on the controller. To disable automatic player creation, navigate to the Network Manager component’s Inspector and untick the Auto Create Player checkbox."
  },
  "Guides/GameObjects/SpawnObjectCustom.html": {
    "href": "Guides/GameObjects/SpawnObjectCustom.html",
    "title": "Custom Spawn Functions",
    "keywords": "Custom Spawn Functions You can use spawn handler functions to customize the default behavior when creating spawned game objects on the client. Spawn handler functions ensure you have full control of how you spawn the game object, as well as how you destroy it. Use ClientScene.RegisterSpawnHandler to register functions to spawn and destroy client game objects. The server creates game objects directly, and then spawns them on the clients through this functionality. This function takes the asset ID of the game object and two function delegates: one to handle creating game objects on the client, and one to handle destroying game objects on the client. The asset ID can be a dynamic one, or just the asset ID found on the prefab game object you want to spawn (if you have one). The spawn / unspawn delegates need to have this game object signature. This is defined in the high level API. // Handles requests to spawn game objects on the client public delegate GameObject SpawnDelegate(Vector3 position, System.Guid assetId); // Handles requests to unspawn game objects on the client public delegate void UnSpawnDelegate(GameObject spawned); The asset ID passed to the spawn function can be found on NetworkIdentity.assetId for prefabs, where it is populated automatically. The registration for a dynamic asset ID is handled like this: // generate a new unique assetId System.Guid creatureAssetId = System.Guid.NewGuid(); // register handlers for the new assetId ClientScene.RegisterSpawnHandler(creatureAssetId, SpawnCreature, UnSpawnCreature); // get assetId on an existing prefab System.Guid coinAssetId = coinPrefab.GetComponent<NetworkIdentity>().assetId; // register handlers for an existing prefab you'd like to custom spawn ClientScene.RegisterSpawnHandler(coinAssetId, SpawnCoin, UnSpawnCoin); // spawn a coin - SpawnCoin is called on client NetworkServer.Spawn(gameObject, coinAssetId); The spawn functions themselves are implemented with the delegate signature. Here is the coin spawner. The SpawnCreature would look the same, but have different spawn logic: public GameObject SpawnCoin(Vector3 position, System.Guid assetId) { return Instantiate(m_CoinPrefab, position, Quaternion.identity); } public void UnSpawnCoin(GameObject spawned) { Destroy(spawned); } When using custom spawn functions, it is sometimes useful to be able to unspawn game objects without destroying them. This can be done by calling NetworkServer.UnSpawn . This causes a message to be sent to clients to un-spawn the game object, so that the custom unspawn function will be called on the clients. The game object is not destroyed when this function is called. Note that on the host, game objects are not spawned for the local client, because they already exist on the server. This also means that no spawn handler functions are called. Setting Up a Game Object Pool with Custom Spawn Handlers Here is an example of how you might set up a very simple game object pooling system with custom spawn handlers. Spawning and unspawning then puts game objects in or out of the pool. using UnityEngine; using Mirror; using System.Collections; public class SpawnManager : MonoBehaviour { public int m_ObjectPoolSize = 5; public GameObject m_Prefab; public GameObject[] m_Pool; public System.Guid assetId { get; set; } public delegate GameObject SpawnDelegate(Vector3 position, System.Guid assetId); public delegate void UnSpawnDelegate(GameObject spawned); void Start() { assetId = m_Prefab.GetComponent<NetworkIdentity> ().assetId; m_Pool = new GameObject[m_ObjectPoolSize]; for (int i = 0; i < m_ObjectPoolSize; ++i) { m_Pool[i] = Instantiate(m_Prefab, Vector3.zero, Quaternion.identity); m_Pool[i].name = \"PoolObject\" + i; m_Pool[i].SetActive(false); } ClientScene.RegisterSpawnHandler(assetId, SpawnObject, UnSpawnObject); } public GameObject GetFromPool(Vector3 position) { foreach (var obj in m_Pool) { if (!obj.activeInHierarchy) { Debug.Log(\"Activating GameObject \" + obj.name + \" at \" + position); obj.transform.position = position; obj.SetActive (true); return obj; } } Debug.LogError (\"Could not grab game object from pool, nothing available\"); return null; } public GameObject SpawnObject(Vector3 position, System.Guid assetId) { return GetFromPool(position); } public void UnSpawnObject(GameObject spawned) { Debug.Log (\"Re-pooling game object \" + spawned.name); spawned.SetActive (false); } } To use this manager, create a new empty game object and name it “SpawnManager”. Create a new script called SpawnManager, copy in the code sample above, and attach it to the new SpawnManager game object. Next, drag a prefab you want to spawn multiple times to the Prefab field, and set the Object Pool Size (default is 5). Finally, set up a reference to the SpawnManager in the script you are using for player movement: SpawnManager spawnManager; void Start() { spawnManager = GameObject.Find(\"SpawnManager\").GetComponent<SpawnManager> (); } Your player logic might contain something like this, which moves and fires coins: void Update() { if (!isLocalPlayer) return; var x = Input.GetAxis(\"Horizontal\")*0.1f; var z = Input.GetAxis(\"Vertical\")*0.1f; transform.Translate(x, 0, z); if (Input.GetKeyDown(KeyCode.Space)) { // Command function is called on the client, but invoked on the server CmdFire(); } } In the fire logic on the player, make it use the game object pool: [Command] void CmdFire() { // Set up coin on server var coin = spawnManager.GetFromPool(transform.position + transform.forward); coin.GetComponent<Rigidbody>().velocity = transform.forward*4; // spawn coin on client, custom spawn handler is called NetworkServer.Spawn(coin, spawnManager.assetId); // when the coin is destroyed on the server, it is automatically destroyed on clients StartCoroutine (Destroy (coin, 2.0f)); } public IEnumerator Destroy(GameObject go, float timer) { yield return new WaitForSeconds (timer); spawnManager.UnSpawnObject(go); NetworkServer.UnSpawn(go); } The automatic destruction shows how the game objects are returned to the pool and re-used when you fire again."
  },
  "General/Migration.html": {
    "href": "General/Migration.html",
    "title": "Migration Guide",
    "keywords": "Migration Guide Migrating a project from UNet (HLAPI) This guide gives you a step by step instruction for migrating your project from HLAP to Mirror. Mirror is a fork of UNet. As such the migration is straight forward for most projects. You should review the information on the Deprecations page to see if your project will be impacted. There's also a Migration Tool you can try: https://github.com/Lymdun/MirrorConverter/ 1. BACKUP You have been warned. 2. Install Mirror and Restart Unity Get Mirror from the asset store and import it in your project. Alternatively you can grab the latest release from GitHub if you're feeling adventurous, but be aware that bleeding edge dev releases are not necessarily stable. NOTE: You must restart Unity after adding Mirror to the project for the components menu to update correctly. 3. Replace namespace Replace UnityEngine.Networking for Mirror everywhere in your project. For example, if you have this: using UnityEngine.Networking; public class Player : NetworkBehaviour { ... } replace it with: using Mirror; public class Player : NetworkBehaviour { ... } At this point, you might get some compilation errors. Don't panic, these are easy to fix. Keep going... 4. Replace playerController with identity Replace references to NetworkConnection.playerController with NetworkConnection.identity . Click here for guidance. 5. Remove NetworkSettings NetworkSettings in UNet have channels, but this is flat out broken. Rather than ignoring your settings we removed channels from NetworkSettings completely. sendInterval is now set in code and / or the inspector too. For example, if you have this code: [NetworkSettings(channel=1,sendInterval=0.05f)] public class NetStreamer : NetworkBehaviour { ... } replace it with: public class NetStreamer : NetworkBehaviour { void Start() { syncInterval = 0.05f; } } Please note that the default transport Telpathy , completely ignores channels, all messages are reliable, sequenced and fragmented. They just work with no fuss. If you want to take advantage of unreliable channels use LLAPITransport instead. 6. Change SyncListStruct to SyncList There is a bug in the original UNet Weaver that makes it mess with our Mirror.SyncListStruct without checking the namespace. In Mirror, we fixed SyncLists so that they work with structs by default. For example, if you have definitions like: public class SyncListQuest : SyncListStruct<Quest> { } replace them with: public class SyncListQuest : SyncList<Quest> { } 7. Replace NetworkHash128 and NetworkInstanceId These have been changed to System.Guid and uint, respectively. For example, if you have something like this: public sealed class SpawnItemMessage : MessageBase { public NetworkHash128 assetID; public NetworkInstanceId networkInstanceID; public Vector3 position; public Quaternion rotation; } replace with: public sealed class SpawnItemMessage : MessageBase { public System.Guid assetID; public uint networkInstanceID; public Vector3 position; public Quaternion rotation; } 8. Update your synclist callbacks In UNet, SyncLists have a callback delegate that gets called in the client whenever the list is updated. We have changed the callback to be a C# event instead and we also pass the item that was updated/removed. For example, if you have this code: using UnityEngine; using UnityEngine.Networking; public class MyBehaviour : NetworkBehaviour { public SyncListInt m_ints = new SyncListInt(); private void OnIntChanged(SyncListInt.Operation op, int index) { Debug.Log(\"list changed \" + op); } public override void OnStartClient() { m_ints.Callback = OnIntChanged; } } replace it with: using UnityEngine; using Mirror; public class MyBehaviour : NetworkBehaviour { public SyncListInt m_ints = new SyncListInt(); private void OnIntChanged(SyncListInt.Operation op, int index, int item) { Debug.Log(\"list changed \" + op + \" item \" + item); } public override void OnStartClient() { m_ints.Callback += OnIntChanged; } } Notice the callback will also work in the server in Mirror. 9. Replace Components Every networked prefab and scene object needs to be adjusted. They will be using NetworkIdentity from Unet, and you need to replace that component with NetworkIdentity from Mirror. You may be using other network components, such as NetworkAnimator or NetworkTransform . All components from Unet should be replaced with their corresponding component from Mirror. Note that if you remove and add a NetworkIdentity, you will need to reassign it in any component that was referencing it. 10. Update Extended Components Some commonly extended components, such as NetworkManager, have changed method parameters in Mirror. A commonly used override is OnServerAddPlayer. Using the original HLAPI, your override may have looked like this: public override void OnServerAddPlayer(NetworkConnection conn, short playerControllerId, NetworkReader extraMessageReader) { base.OnServerAddPlayer(conn, playerControllerId, extraMessageReader); // your code } In your newly Mirror-capable NetworkManager, if you are using the OnServerAddPlayer override, remove the \"playerControllerId\" and \"extraMessageReader\" parameters from your override and the base call: public override void OnServerAddPlayer(NetworkConnection conn) { base.OnServerAddPlayer(conn); // your code } See Custom Player Spawn Guide for details on how to submit custom characters now. 11. Pick your transport You can choose one of several transports in Mirror. Open your NetworkManager gameobject, in the inspector you will see a TelepathyTransport component by default. Drag in one of the available transports and remove TelepathyTransport if you wish to use a UDP based transport instead. 12. Configure address and port In HLAPI, you configure the port and local address in the NetworkManager. One of our goals is to make Mirror transport independent. Not all transports need address and port. Some transports might even use more than one port at the same time, so these settings were inadequate. We removed the port and address and all other Network Info properties from NetworkManager, and we moved them to the transport components instead. 13. Update your firewall and router LLAPI uses UDP. Mirror uses TCP by default. This means you may need to change your router port forwarding and firewall rules in your machine to expose the TCP port instead of UDP. This highly depends on your router and operating system. Video version See for yourself how uMMORPG was migrated to Mirror Possible Error Messages TypeLoadException: A type load exception has occurred. - happens if you still have SyncListStruct instead of SyncListSTRUCT in your project. NullPointerException: The most likely cause is that you replaced NetworkIdentities or other components but you had them assigned somewhere. Reassign those references. error CS0246: The type or namespace name 'UnityWebRequest' could not be found. Are you missing 'UnityEngine.Networking' using directive? Add this to the top of your script: using UnityWebRequest = UnityEngine.Networking.UnityWebRequest; UnityWebRequest is not part of UNet or Mirror, but it is in the same namespace as UNet. Changing the namespace to Mirror caused your script not to find UnityWebRequest. The same applies for WWW and all UnityWebRequest related classes."
  },
  "General/Start.html": {
    "href": "General/Start.html",
    "title": "Getting Started",
    "keywords": "Getting Started This document describes steps to creating a multiplayer game with Mirror. The process described here is a simplified, higher level version of the actual process for a real game; it doesn’t always work exactly like this, but it provides a basic recipe for the process. Video tutorials Check out these awesome videos showing you how to get started with mirror. Courtesy of First Gear Games also known as Punfish in discord. Script Templates Create new Network Behaviours and other common scripts faster See Script Templates . NetworkManager set-up Add a new game object to the Scene and rename it “NetworkManager”. Add the NetworkManager component to the “NetworkManager” game object. Add the NetworkManagerHUD component to the game object. This provides the default UI for managing the network game state. See Using the NetworkManager . Player Prefab Find the Prefab for the player game object in the game, or create a Prefab from the player game object Add the NetworkIdentity component to the player Prefab Set the playerPrefab in the NetworkManager’s Spawn Info section to the player Prefab Remove the player game object instance from the Scene if it exists in the Scene See Player Objects for more information. Player movement Add a NetworkTransform component to the player Prefab Check the Client Authority checkbox on the component. Update input and control scripts to respect isLocalPlayer Override OnStartLocalPlayer to take control of the Main Camera in the scene for the player. For example, this script only processes input for the local player: using UnityEngine; using Mirror; public class Controls : NetworkBehaviour { void Update() { if (!isLocalPlayer) { // exit from update if this is not the local player return; } // handle player input for movement } } Basic player game state Make scripts that contain important data into NetworkBehaviours instead of MonoBehaviours Make important member variables into SyncVars See State Synchronization . Networked actions Make scripts that perform important actions into NetworkBehaviours instead of MonoBehaviours Update functions that perform important player actions to be commands See Networked Actions . Non-player game objects Fix non-player prefabs such as enemies: Add the NetworkIdentify component Add the NetworkTransform component Register spawnable Prefabs with the NetworkManager Update scripts with game state and actions Spawners Potentially change spawner scripts to be NetworkBehaviours Modify spawners to only run on the server (use isServer property or the OnStartServer() function) Call NetworkServer.Spawn() for created game objects Spawn positions for players Add a new game object and place it at player’s start location Add the NetworkStartPosition component to the new game object"
  },
  "General/Support.html": {
    "href": "General/Support.html",
    "title": "Support",
    "keywords": "Support Discord You can find us on Discord . GitHub You can create an issue in GitHub You can also contribute with Pull Requests...see Contributing"
  },
  "General/ChangeLog.html": {
    "href": "General/ChangeLog.html",
    "title": "Change Log",
    "keywords": "Change Log Mirror is published to the Asset Store at the start of every month, unless some critical issue causes a delay. Mirror uses semantic versioning, and the versions shown here are those that were published to the Asset Store, and occasionally major version bumps happen mid-month between store submissions and are therefore not individually shown here. Version 12.x.x -- In Progress Added: NetworkMatchChecker component. Use this component to create many concurrent isolated matches within a single game server. Added: SyncLists now have Find and FindAll functions. Added: NetworkBehaviour now has OnStopServer and OnStopClient virtual methods Added: Weaver now supports custom Reader & Writer for types in other assemblies Added: Network Manager now has an optional setting to check for and disconnect remote connections that have gone silent for a specified interval. Fixed: NetworkAnimator no longer double-fires SetTrigger / ResetTrigger on the host client Fixed: Destroy is no longer invoked twice on the server for the player object. Changed: NetworkBehaviour: OnNetworkDestroy was renamed to OnStopClient . Changed: Breaking NetworkBehaviour: OnRebuildObservers , OnCheckObserver , and OnSetHostVisibility were moved to a separate class called NetworkVisibility Version 11.4.2 - 2020-Apr-03 Added: SyncVar hooks can be virtual now, and overriden in a derived class. Added: Virtual OnRoomStopServer to NetworkRoomManager and Script Template Added: 10K Networked Objects Benchmark Example Fixed: Setting breakpoints in an IDE for Command's and Rpc's work correctly now. Fixed: NetworkServer's calls to SendToObservers now reports correct channel to Mirror Profiler. Fixed: NetworkRoomManager's roomPlayerPrefab is now protected so it can be accessed in derived classes. Fixed: NetworkRoomPlayer inspector and documentation updated to be less confusing. Fixed: NetworkIdentity no longer double calls NetworkServer.Destroy. Fixed: NetworkAnimator now correctly excludes parameters controlled by curves. Fixed: NetworkBehaviour now uses a property drawer for the SyncVar label so it displays better. Fixed: NetworkServer.SendToReady overloads are no longer ambiguous. Fixed: NetworkRoomManager no longer incorrectly destroys the game player object. It's left in the game scene to be cleaned up by Unity when the scene changes. Fixed: StopHost correctly raises OnServerDisconnect in Network Manager, and correctly unwinds before shutting down the server. Fixed: isServer is no longer incorrectly false on server in Network Identity's OnDestroy Changed: Network Manager offlineScene and onlineScene store full paths now, so use SceneManager.GetActiveScene().path instead. Changed: Network Manager HUD now calls StopHost / StopServer / StopClient more appropriately. Changed: Network Manager HUD labels no longer say LAN. Associated docs also cleaned up to eliminate the misconception of Mirror being LAN only solution. Changed: NetworkTransform compression removed and message handling is much simpler now. Changed: NetworkSceneChecker initializes in Awake again because OnEnable proved to be unreliable in some cases. Changed: Network Manager will no longer lose references to scenes if they aren't in the Build Settings scene list, however moving or renaming scenes may cause references to be lost. Changed: Breaking Many obsolete methods and properties removed. Use version 10 first if upgrading from UNet or older Mirror. See Deprecations for complete list. Version 10.4.7 - 2020-Mar-03 Added: Weaver will now block play mode and builds if there are weaver errors and show them in the console again. Added: PooledNetworkReader and PooledNetworkWriter, both Disposable. Added: NetworkReader.ReadMessage . Added: NetworkDiscovery now handles headless server mode. Added: SyncVar, Cmd's and Rpc's now support Scriptable Objects via CreateInstance on the receiving side. Added: Discord Transport Fixed: isClient now returns true on clients in OnDestroy for networked objects. Fixed: Host Player race condition for Ready message. Fixed: NetworkAnimator and NetworkTransform now correctly check for client authority in their respective Command methods. Fixed: Network Room Manager Script Template had a virtual method instead of an override. Fixed: NetworkServer's calls to NetworkConnectionToClient.Send now includes the channelId parameter that was missing. Fixed: NetworkServer's calls to SendToAll, SendToReady, and SendToObservers send to the exact connection if it is detected as local connection, instead of falling back to the .localConnection. Fixed: NetworkServer.SpawnObjects returns false if server isn't running. Fixed: NetworkTransform rotation detection improved. Fixed: Weaver generated code now builds properly for IL2CPP (again). Changed: StartHost in Network Manager is no longer a virtual method (and shoudn't have been). Override OnStartHost instead. Changed: NetworkRoomManager's OnRoomServerSceneLoadedForPlayer now includes NetworkConnection parameter. Changed: NetworkSceneChecker now works from OnEnable instead of Awake, and uses Scene instead of scene name. Changed: Renamed NeworkWriter.Write to WriteMessage for consistency. Version 9.0.2 - 2020-Feb-04 Added: NetworkAnimator now has a ResetTrigger function and server / client authority warnings. Added: NetworkTransform now has 3 new floats for Sensitivity to quiet down message traffic from micro changes. Added: Network Observer added to Script Templates -- See the new Mirror section in the Assets > Create menu. Added: Network Discovery has been reimplemented including an example and script template -- thanks to all those who contributed! Added: Network Discovery Guide added to documentation. Added: Network Scene Checker Component . Added: Mirror Icon for all components. Added: Inspector Headers to NetworkBehaviour, NetworkTransform, and NetworkAnimator. Added: URI added to supported data types. Added: NetworkReaderPool has been implemented in place of new NetworkReader everywhere, significantly reducing garbage allocation. Fixed: NetworkTransform and NetworkAnimator now uses NetworkWriterPool. Fixed: NetworkTransform and NetworkAnimator now respect hasAuthority for client owned objects. Fixed: NetworkTransform will now correctly teleport if time / distance are too large. Fixed: NetworkAnimator now correctly syncs when clientAuthority is false. Fixed: Client owned objects are now destroyed when client disconnects (regression). Fixed: Client authority is now preserved for networked objects carried through scene change in DontDestroyOnLoad (DDOL). Fixed: Starting server immediately after cancelling client connection attempt no longer throws a NRE. Fixed: IL2CPP builds no longer trigger an assert when stopping server. Fixed: SyncVars are now set for Host player before hook is invoked. Fixed: SyncDictionary now correctly updates the value before invoking callbacks. Fixed: StopHost no longer tries to change to the Offline scene twice. Fixed: NetworkRoomManager roomSlots are now correctly managed on both server and clients. Fixed: NetworkRoomManager now correctly supports multiple GamePlay scenes and adds a virtual OnRoomServerAddPlayer . Fixed: Additive scene operations no longer incorrectly lead to extraneous AddPlayer messages from clients. Fixed: NetworkWriterPool is now used everywhere instead of new NetworkWriter (we missed a couple when the pool was implemented). Fixed: Patch for Unity 2019.3.x RequestScriptReload was moved to EditorUtility from UnityEditorInternal.InternalEditorUtility. Fixed: Arrays of custom types are now correctly supported. Changed: Shutdown logic has been streamlined. Changed: NetworkIdentity GetSceneIdenity method renamed to GetSceneIdentity (name typo). Changed: OnApplicationQuit virtual method added to Transport class and Transport.activeTransport.Shutdown() is no longer called from Network Manager. Changed: Breaking SyncVar Hooks now require two parameters, one each for the old and new value, and the property value is now set before the hook is called. Version 6.7.7 - 2020-Jan-01 Added: Script Templates -- See the new Mirror section in the Assets > Create menu. Added: Full Text Search added to docs. Added: Basic Chat example. Added: Some youtube videos have been created and linked from various doc pages where appropriate. Added: Transports can now support using a URI for connection including port. Added: version.txt file is now included with the release version in it. Added: Structs that inherit from IMessageBase now generate serializers. Fixed: Components now appear in docs under API Reference. Fixed: Delayed disconnect in Basic Authenticator. Fixed: Multiplexer now handles OnClientConnect and GetMaxMessageSize correctly. Fixed: NetworkRoomManager OnRoomServerCreateGamePlayer now includes the Room Player Object as parameter. Changed: Room example now has NetworkRoomManager in the Offline scene and correctly switches to the Room scene when server / client is started. Changed: NetworkManager startPositionIndex and loadingSceneAsync are now public. Changed: SceneMessage now has an optional customHandling flag so devs can handle their own custom scene loading, e.g. using Addressables. Changed: Breaking NetworkTransform now defaults to server authority and has a Client Authority checkbox. Version 6.3.0 - 2019-Dec-09 Added: SyncMode selector now works for components on any scene objects owned by a client in addition to the player object, e.g. pets. Added: MessageBase now fully supports inheritance. Added: Room example now has UI button for host to return all clients to the Room scene and other improvements. Fixed: ReplacePlayerForConnection now works for existing scene objects as long as another player doesn't own the targetted object. Fixed: isClient and isServer are now true for networked objects in Start and OnStartClient / OnStartServer, respectively. Fixed: hasAuthority is now set before OnStartClient and OnStartLocalPlayer are invoked. Changed: connectionToClient is now used to assign client authority. Changed: In many respects, the Host player acts a lot more like a client and will reveal bugs better. Changed: ReplacePlayerForConnection now has an optional bool to retain authority of the previous object (default = false). Removed: NetworkServer.SpawnWithClientAuthority is deprecated in favor of overloads of NetworkServer.Spawn. Version 5.0.2 - 2019-Nov-03 Added: SyncList and SyncSet custom Equality Comparer support. Added: Custom serializers may be implemented for any type in Cmd's and Rpc's. Added: Fallback Transport . Fixed: SyncVar hooks are no longer called in Host if no change. Fixed: NetworkIdentity no longer throws a null reference exception in RemoveClientAuthority. Fixed: Server transport now suspended during scene change to prevent erroneous messages. Fixed: SyncList, SyncDictionary and SyncSet now use a custom IEnumerator to avoid memory allocation. Fixed: sceneID is no longer reset in certain cases when editing a prefab. Changed: PreprocessorDefine code moved to CompilerSymbols folder to avoid paradox of missing symbols preventing the symbols being added to the project. Changed: Host player no longer gets authority assigned to all objects by default. Changed: Commands no longer bypass serialization for Host player, making debugging easier. Changed: Local connections now maintain their own message queue. Changed: Transport.Available is now abstract. Removed: Network Identity: Local Player Authority has been removed as no longer necessary. Version 4.0.7 - 2019-Oct-03 Added: Authentication support to authenticate clients in the Connect phase. Added: Profiler events. These events can be subscribed to by the Network Profiler to provide visual information. Added: Transports now include channel in profiler events. Added: Transport abstract class now supports sending a message to a list of connection id's. Fixed: SceneMessage now has sceneOperation enum so clients can properly handle additive scenes. Fixed: NetworkClient handlers are now cleared in Shutdown. Fixed: Offline scene is no longer reloaded when client fails to connect or is rejected. Fixed: Start Position Index is now reset to zero when server is stopped. Fixed: Network Room Players are now all in DontDestroyOnLoad so they don't respawn in the game scene. Fixed: Network Room example player controller restores main camera on disable. Fixed: Components with different sync intervals were not sending updates to clients. Fixed: In certain cases, weaver wouldn't weave some external assemblies. Fixed: NetworkAnimator now does a full sync for new clients. Fixed: NetworkBehaviour inspector now shows SyncMode for private SyncVars. Fixed: Calling Commands and Rpcs of parent classes from inherited classes works as it should. Fixed: Telepathy no longer hangs when attempting to connect to a nonexistent host. Fixed: Websockets Transport now properly returns the client endpoint information via ServerGetClientAddress . Fixed: WebGL build now works with ArraySegment. Changed: Mirror is now free of garbage memory allocation on the sending side. Some transports may still have a little garbage allocation yet. Changed: Deprecated the AddPlayerMessage extraMessage byte[] in favor of an easier approach to Custom Players . This is a breaking change: The virtual method OnServerAddPlayer loses the AddPlayerMessage parameter. Changed: NetworkIdentity.RemoveAuthorityForConnection is now easier to use: no need to supply the current \"owner\" anymore. Changed: Renamed NetworkConnection.playerController to identity ... see Deprecations for details. Changed: Lobby system renamed to Room to better align the name for what it is and make way for a future Lobby framework. Version 3.17.4 - 2019-Sep-04 Added: Custom Network Readers & Writers via extension methods. Added: Network Sync Mode selector on components to sync to observers (default) or just the owner. Added: SyncVars now support structs and enums in other assemblies. Added: Support for reading and writing array segments. Added: NetworkAnimator now has layers support. Added: New virtual method OnServerChangeScene to NetworkManager. Added: XML summary comments for intellisense and future generated class docs. Updated Examples and Documentation. Fixed: SceneID was not set to 0 for prefab variants. Fixed: Observers were not properly rebuilt on scene changes. Fixed: SyncVar hooks were not able to change other SyncVars in Host mode. Fixed: Telepathy not setting socket options on accepted clients. Fixed: Catch IL2CPP bug. Fixed: Telepathy and Websockets now start connections ID's at 1 instead of 2 Fixed: Websockets support for SSL restored. Fixed: NetworkManager no longer complains about missing player prefab if auto-create is disabled. Fixed: Removed a garbage allocation in Network Transform. Fixed: NetworkClient.Ready was being called unncessarily in certain cases, e.g. SceneMessages. Changed: Documentation moved to website and API generated docs implemented. Changed: AddPlayerForConnection handler is now internal to keep safety checks intact. Changed: A bunch of messages converted to value types for performance. Version 3.11.6 - 2019-Jul-10 Fixed: Telepathy IPv4, IPv6, and FQDN should all work now. Fixed: TelepathyTransport error in UWP builds. Fixed: OnApplicationQuit is handled better now. Fixed: Performance and memory allocation improvements. Changed: Telepathy Source is now included instead of a DLL. Version 3.10.10 - 2019-Jun-19 Added: Scene Message now supports params for SceneMode (Normal / Additive) and PhysicsMode (2D / 3D). Added: ClientScene.Send now has an optional ChannelId parameter. Added: ASMDEF to Examples folder. Added: Support for sending and receiving ArraySegment<byte> Added: IReadOnlyList<T> in SyncLists. Fixed: NetworkManager not switching to correct scene in some cases. Fixed: ListServer Ping not found in WebGL. Fixed: TelepathyTransport.GetMaxPacketSize uses the new configurable max size. Fixed: Significant reduction in memory allocation and garbage collection. Changed: Use transform.localPosition and transform.localRotation for better VR support. Removed: Websockets send queues (they never worked) and SSL (temporarily because it didn't work). Version 3.6.7 -- 2019-Apr-28 Changed: NetworkReader now uses ArraySegment<byte> to minimize allocations. Version 3.6.6 -- 2019-Apr-24 Fixed: Reverted two internal refactor commits that had unintended consequences. Version 3.6.5 -- 2019-Apr-23 Fixed: Unity 2019.1 compatibility. Fixed: Erroneous error indicating prefabs were missing Scene ID's. Fixed: OnDeserializeSafely now works without allocations. Fixed: Weaver not writing symbol files, preventing breakpoints from working in Visual Studio. Fixed: NetworkIdentity SceneID generation now uses RNG Crypto Service Provider. Fixed: Scene lighting in Additive example. Fixed: Player Prefab transform details now respected when instantiated in the absence of NetworkStartPosition. Removed: Tests folder from Unity package generation (no end-user value). Version 3.5.9 -- 2019-Apr-12 Fixed: NetworkManager round-robin mode using NetworkStartPosition objects now uses hierarchy sibling order. Fixed: IsLocalPlayer is now reliably accurate in Start() by combining OwnerMessage and SpawnPrefabMessage. Fixed: Stack overflow issues with Weaver and Cecil. Fixed: Corrected assembly paths passed to weaver. Fixed: Enum bandwdith reduced in SyncVars, Commands, and Rpcs. Fixed: Placeholder files added for removed code files so updating works better. Changed: NetworkManager isHeadless is a static property now, changed from IsHeadless() . Version 3.5.3 -- 2019-Apr-10 Fixed: Exceptions in overrides of Network Manager and other components incorrectly silenced. Fixed: Lobby system sometimes would not spawn and swap game player prefabs into the game scene. Fixed: Application.targetFrameRate no longer set in host mode. Changed: Telepathy: Split MaxMessageSize to allow setting a different value for client and server. Version 3.4.9 -- 2019-Apr-6 Added: Semantic Versioning (which is why we jumped from 1.6 to 3.4.9). Added: SyncDictionary . Added: SyncHashSet . Added: SyncSortedSet . Added: SyncList and SyncDictionary support all IList and IDictionary derived types, respectively. Added: Documentation for SyncVars . Added: Documentation for SyncEvents . Added: NoRotation to NetworkTransform. Added: Scale is now included in spawn payload along with position and rotation. Added: Generic IMessageBase to allow struct message types. Added: Weaver now supports Vector2Int and Vector3Int. Added: List Server example. Added: Additive Scenes example. Fixed: SyncLists now work correctly for primitives and structs. Fixed: SyncVar Hooks now will update the local property value after the hook is called. You no longer need to have a line of code in your hook method to manualy update the local property. Fixed: Host should not call Disconnect on transports. Fixed: NetworkAnimimator now supports up to 64 animator parameters. Fixed: NetworkManager StartServer no longer assumes scene zero is the default scene...uses GetActiveScene now. Fixed: NetworkServer Shutdown now resets netId to zero. Fixed: Observers are now properly rebuilt when client joins and OnRebuildObservers / OnCheckObserver is overridden. Fixed: NetworkProximityChecker: On rare occasion, player could be excluded from observers rebuild. Fixed: NetworkLobbyPlayer OnClientReady works now. Fixed: NetworkLobbyPlayer Remove button not showing for P1 when Server Only. Fixed: NetworkLobbyManager pendingPlayers and lobbySlots lists are now public for inheritors. Fixed: Offline scene switching now works via StopClient() . Fixed: Pong example updated. Fixed: Source Weaver was deleting PDB files, preventing breakpoints and debugging from working. Changed: TargetRpc NetworkConnection paramater is now optional...the calling client's NetworkConnection is default. Changed: Movement example replaced with Tank example. Changed: NetworkClient functions are all static now, so the singleton is gone. Use NetworkClient directly. Changed: SyncList now supports structs directly, making SyncListSTRUCT obsolete. Removed: SyncListSTRUCT - Use SyncList instead. Removed: NetworkClient.ShutdownAll is obsolete -- Use NetworkClient.Shutdown instead. Version 1.6 -- 2019-Mar-14 Fixed: Websockets transport moved to Mirror.Websocket namespace. Fixed: NetworkAnimator bandwidth abuse. Fixed: NetworkAnimator float sync bug. Fixed: Persistent SceneID's for Networked objects. Changed: Documentation for Transports . Changed: Weaver is now full source...FINALLY! Changed: ClientScene.AddPlayer 2nd parameter is now byte[] extraData instead of MessageBase extraMessage . Please refer to the code sample here to see how to update your code. Changed: NetworkManager -- Headless Auto-Start moved to Start() from Awake() . Changed: Removed Message ID's for all messages - See Network Messages for details. Message IDs are now generated automatically based on the message name. Previously you would call Send(MyMessage.MsgId, message), now you call Send(message). Removed: Documentation for Groove Transport - use Websockets Transport instead. Version 1.5 -- 2019-Mar-01 Added: Migration Tool to (mostly) automate conversion from UNet. Added: Full support for WebSockets and WebSocketsSecure to replace UNet LLAPI. Added: Transport Multiplexer - allows the use of multiple concurrent transports. Added: NetworkLobbyManager and NetworkLobbyPlayer with example game. Added: Configurable Server Tickrate in NetworkManager. Added: New virtual OnClientChangeScene fires right before SceneManager.LoadSceneAsync is executed. Added: Unit tests for Weaver. Fixed: Garbage allocations removed from a lot of things (more work to do, we know). Fixed: NetworkProximityChecker now uses OverlapSphereNonAlloc and OverlapCircleNonAlloc. Fixed: SyncVar hook not firing when clients joined. Fixed: NetworkManager no longer assumes it's on Scene(0) in Build Settings. Fixed: NetworkAnimator no longer lmited to 6 variables. Fixed: TelepathyTransport delivering messages when disabled. Changed: Minimum Unity version: 2018.3.6 Removed: SceneAttribute.cs (merged to CustomAttributes.cs). Removed: NetworkClient.allClients (Use NetworkClient.singleton instead). Removed: NetworkServer.hostId and NetworkConnection.hostId (holdovers from LLAPI). Removed: NetworkConnection.isConnected (NetworkConnection is always connected). Removed: Transport.GetConnectionInfo (Use ServerGetClientAddress instead). Version 1.4 -- 2019-Feb-01 Added: HelpURL attirbutes to components. Added: Automatic targetFramerate for headless builds. Added: ByteMessage to Messages class. Fixed: Connectiing state can be cancelled properly. Fixed: NetworkTransformBase interpolation applied to client's own object. Fixed: Objects are spawned with correct rotation. Fixed: SceneId assignment. Fixed: Changed syncInterval wasn't saved...it is now. Fixed: Additive Scene loading. Changed: Mirror is now full source -- no more DLL's. Changed: Transports are now components -- TCP, UDP, WebGL, Steam. Changed: Transport class now dispatches Unity Events. Changed: NetworkServer.SendToClientOfPlayer uses NetworkIdentity now. Changed: NetworkServer.SendToObservers uses NetworkIdentity parameter now. Changed: NetworkServer.SendToReady uses NetworkIdentity now. Changed: NetworkServer.DestroyPlayerForConnection uses NetworkIdentity.spawned now. Changed: NetworkConnection.Dispose uses NetworkIdentity.spawned now. Changed: NetworkReader.ReadTransform uses NetworkIdentity.spawned now. Changed: NetworkTransform reimplemented -- physics removed, code simplified. Removed: NetworkClient.hostPort (port is handled at Transport level). Removed: NetworkServer.FindLocalObject (Use NetworkIdentity.spawned[netId] instead). Removed: ClientScene.FindLocalObject (Use NetworkIdentity.spawned[netId] instead)."
  },
  "General/WhyTCP.html": {
    "href": "General/WhyTCP.html",
    "title": "Why TCP by default and not UDP?",
    "keywords": "Why TCP by default and not UDP? It's the year 2019 and every game developer swears by UDP. Yet we chose TCP as default for Mirror. Why is that? First of all, a quick word about the major differences between UDP and TCP. UDP has lower latency, unreliable and hard to use correctly TCP has higher latency, reliable and easy to use TCP (Transmision Control Protocol) Tcp is a protocol built on top of IP. It is by far the most popular protocol on the internet. Everything you are seeing in this page was sent to your browser via TCP. It is designed to be simple to use and scalable. Servers open a TCP port and wait for connections. Clients send an initial message (handshake) to establish the connection then send data. Data flows one byte after another, always in the right order, without missing anything. Some of the key features include: Reliable: if a packet gets lost, TCP will resend it. All data is either transmitted successfully or you get an error and the connection is closed. Applications don't have to worry about missing packets. Fragmented: network cards cannot just send 1 MB of data. They can only send small packets of 1.5Kb or less. If a lot of data is sent by the application, TCP will split it into small packets and reassemble the data on the receiving end. Sequenced: If you send data \"a\" and \"b\" you will not receive \"b\" and \"a\". TCP guarantees that every byte will arrive in the same order it was sent. Connection oriented: TCP has the concept of a connection. A client sends an initial handshake message. A connection is considered established until either the client and server decides to disconnect. Both the client and server get notified when the connection ends and can react accordingly, for example saving and destroying player object. Congestion control: If a server is being overwhelmed, TCP will throttle the data to avoid congestion collapse. These are great features that make it very easy for programmers to work with TCP, but they come at a cost: Latency. Suppose an object is moving from point a to b to c. The server sends 3 messages: move to a, b, c. Suppose b gets lost (wifi drops a lot of packets for example) and c arrives fine. We could skip b and move towards c instead, but we can't because the operating system won't give us c until b is retransmitted. For this reason, AAA studios consistently prefer UDP for fast paced action games. UDP (User Datagram Protocol) UDP is also a protocol based on IP. It is used for real time applications such as fast paced action games or voice over ip, where low latency is more important than reliability. A server opens a port and waits for messages. Clients send messages to the port, and the server may send messages back. Data flows in both ways as individual messages. There is no concept of connection, so there is no built in way to determine if a client disconnects. Messages are delivered as soon as possible, there is no guarantee that the order will be preserved or that they will be delivered at all. Messages must be small, typically 1.5Kb or less. Mirror does need reliability, fragmentation, sequenced, connections for many things, so we would not use raw UDP. We would use a library that implements those features on top of UDP such as ENet , LiteNetLib or LLAPI, typically referred to as RUDP (Reliable UDP) The obvious question is: do RUDP libraries just reinventing TCP? yes, to some degree they do. But the point is that those features are optional and we can send messages without the extra features for low latency data such as movement or voice. Dark ages Back in 2015 when we started uMMORPG and Cubica, we originally used Unity's built in Networking system aka UNET. UNET used LLAPI, an RUDP library that avoided garbage collection at all costs. What sounds good in theory, was terrible in practice. We spent about half our work hours from 2015 to 2018 dealing with UNET bugs. There was packet loss, highly complex code due to GC avoidance, synchronization issues, memory leaks and random errors. Most importantly, no decent way to debug any of it. If a monster didn't spawn on a client, we wouldn't know what caused it. Was the packet dropped by UDP? Was it a bug in the highly complex UNET source code? Was the reliable layer on top of UDP not working as intended? Was the reliable layer actually fully reliable? Did we use the right networking config for the host that we tested it on? Or was it a bug in our own project? After 3 years in UDP/LLAPI hell, we realized if we ever wanted to finish our games, we would need a networking layer that just works. We could have tried other RUDP transports, but we would end up debugging them instead. That's why we made Telepathy and Mirror. Life is short. We just need the damn thing to work. The choice is yours We acknowledge not everyone will agree with our reasoning. Rather than push our views on users, we made Mirror transport independent. A few months later, Unity did the same thing. You can easily swap out the transport for one of the several RUDP implementations simply by dragging it into your NetworkManager gameobject. Pick whatever works best for you. We recommend you profile your game and collect real world numbers before you make a final decision. After we made Mirror transport independent, the community stepped up integrated several RUDP transports with Mirror. While the default is Telepathy (simple \"just works\" TCP transport) you can choose among several transports or even write your own."
  },
  "Components/NetworkMatchChecker.html": {
    "href": "Components/NetworkMatchChecker.html",
    "title": "Network Scene Checker",
    "keywords": "Network Scene Checker The Network Match Checker component controls visibility of networked objects based on match id. Any object with this component on it will only be visible to other objects in the same match. This would be used to isolate players to their respective matches within a single game server instance. When you create a match, generate and store, in a List for example, a new match id with System.Guid.NewGuid(); and assign the same match id to the Network Scene Checker via GetComponent<NetworkMatchChecker>().matchId . Mirror's built-in Observers system will isolate SyncVar's and ClientRpc's on networked objects to only send updates to clients with the same match id."
  },
  "Components/NetworkTransformChild.html": {
    "href": "Components/NetworkTransformChild.html",
    "title": "Network Transform Child",
    "keywords": "Network Transform Child The Network Transform Child component synchronizes the position and rotation of the child game object of a game object with a Network Transform component. You should use this component in situations where you need to synchronize an independently-moving child object of a Networked game object. To use the Network Transform Child component, attach it to the same parent game object as the Network Transform, and use the Target field to define which child game object to apply the component settings to. You can have multiple Network Transform Child components on one parent game object . You can modify Compress Rotation to save some bandwidth when synchronizing the rotation. You can use the Network Sync Interval to specify how often it syncs (in seconds). This component takes authority into account, so local player game objects (which have local authority) synchronize their position from the client to server, then out to other clients. Other game objects (with server authority) synchronize their position from the server to clients."
  },
  "Components/NetworkManager.html": {
    "href": "Components/NetworkManager.html",
    "title": "Network Manager",
    "keywords": "Network Manager The Network Manager is a component for managing the networking aspects of a multiplayer game. The Network Manager features include: Game state management Spawn management Scene management Debugging information Customization Getting Started with the Network Manager The Network Manager is the core controlling component of a multiplayer game. To get started, create an empty game object in your starting Scene, and add the Network Manager component. The newly added Network Manager component looks like this: The Inspector for the Network Manager in the Editor allows you to configure and control many things related to networking. Note : You can only ever have one active Network Manager in each scene because it's a singleton. Do not place the Network Manager component on a networked game object (one which has a Network Identity component), because Mirror disables these when the Scene loads. If you are already familiar with multiplayer game development, you might find it useful to know that the Network Manager component is implemented entirely using the API, so everything it does is also available to you through scripting. For advanced users, if you find that you need to expand on the Network Manager component’s features, you can use scripting to derive your own class from Network Manager and customize its behavior by overriding any of the virtual function hooks that it provides. However, the Network Manager component wraps up a lot of useful functionality into a single place, and makes creating, running and debugging multiplayer games as simple as possible. Transports Mirror's uses a separate component (derived from the Transport class) to connect across the network. By default, it is Telepathy Transport. This design choice of separating the transport into its own component allows game developers to choose the transport that best fits their game needs. Changing transports is as simple as swapping out the component on the Network Manager object and assigning it to the Transport field. Transports are available for TCP, UDP, WebGL, and Steam. Additionally, there's a Multiplex transport that allows for using two transports together on the server, e.g. Telepathy and WebSockets, so that desktop and browser players can play together on the same server seamlessly. See Transports for more information. Game State Management A Networking multiplayer game can run in three modes - as a client, as a dedicated server, or as a host which is both a client and a server at the same time. If you’re using the Network Manager HUD, it automatically tells the Network Manager which mode to start in, based on which button the player clicks. If you’re writing your own UI that allows the player to start the game, you’ll need to call these from your own code. These methods are: NetworkManager.StartClient NetworkManager.StartServer NetworkManager.StartHost Whichever mode the game starts in (client, server, or host), the Network Address and Transport Port properties are used. In client mode, the game attempts to connect to the address and port specified. A fully-qualified domain name (FQDN) can also be used for the Network Address, e.g. \"game.example.com\". In server or host mode, the game listens for incoming connections on the port specified, but does not bind to any specific IP address (it listens on all available). Spawn Management Use the Network Manager to manage the spawning (networked instantiation) of networked game objects from Prefabs. Most games have a Prefab which represents the player, so the Network Manager has a Player Prefab slot. You should assign this slot with your player Prefab. When you have a player Prefab set, a player game object is automatically spawned from that Prefab for each user in the game. This applies to the local player on a hosted server, and remote players on remote clients. You must attach a Network Identity component to the Player Prefab before assigning it to this field. Once you have assigned a Player Prefab, you can start the game as a host and see the player game object spawn. Stopping the game destroys the player game object . If you build and run another copy of the game and connect it as a client to localhost , the Network Manager makes another player game object appear. When you stop that client, it destroys that player’s game object . In addition to the Player Prefab, you must also register other prefabs that you want to dynamically spawn during game play with the Network Manager. You can add prefabs to the list shown in the inspector labelled Registered Spawnable Prefabs. You can also register prefabs via code, with the ClientScene.RegisterPrefab method. If you have one Network Manager that is persisted through scenes via Don't Destroy On Load (DDOL), you need to register all prefabs to it which might be spawned in any scene. If you have a separate Network Manager in each scene, you only need to register the prefabs relevant for that scene. Start Positions The Network Manager will spawn Player Prefab at their defined transform position and rotation by default, however the Player Spawn Method property allows you to control how start positions are chosen in conjunction with Network Start Position components. Choose Random to spawn players at randomly chosen startPosition options. Choose Round Robin to cycle through startPosition options in a set list. If the Random or Round Robin modes don’t suit your game, you can customize how the start positions are selected by using code. You can access the available Network Start Position components by the list NetworkManager.startPositions , and you can use the helper method GetStartPosition on the Network Manager that can be used in an implementation of OnServerAddPlayer to find a start position. Scene Management Most games have more than one scene. At the very least, there is usually a title screen or starting menu scene in addition to the scene where the game is actually played. The Network Manager is designed to automatically manage scene state and scene transitions in a way that works for a multiplayer game. There are two slots on the Network Manager inspector for scenes: the Offline Scene and the Online Scene. Dragging scene assets into these slots activates networked Scene Management. When a server or host is started, the Online Scene is loaded. This then becomes the current network scene. Any clients that connect to that server are instructed to also load that scene. The name of this scene is stored in the networkSceneName property. When the network is stopped, by stopping the server or host or by a client disconnecting, the offline Scene is loaded. This allows the game to automatically return to a menu scene when disconnected from a multiplayer game. You can also change scenes while the game is active by calling ServerChangeScene . This makes all the currently connected clients change Scene too, and updates networkSceneName so that new clients also load the new Scene. While networked Scene management is active, any calls to game state management functions such as StartHost or StopClient can cause scene changes. This applies to the runtime control UI. By setting up scenes and calling these methods, you can control the flow of your multiplayer game. Note that scene change causes all the game objects in the previous scene to be destroyed. You should normally make sure the Network Manager persists between Scenes, otherwise the network connection is broken upon a scene change. To do this, ensure the Don’t Destroy On Load checkbox is ticked in the inspector. However it is also possible to have a separate Network Manager in each scene with different settings, which may be helpful if you wish to control incremental prefab loading, or different scene transitions. Customization There are virtual functions on the NetworkManager class that you can customize by creating your own derived class that inherits from NetworkManager . When implementing these functions, be sure to take care of the functionality that the default implementations provide. For example, in OnServerAddPlayer , the function NetworkServer.AddPlayer must be called to activate the player game object for the connection. Properties dontDestroyOnLoad Use this property to control whether or not Mirror should destroy the game object with the Network Manager when the Scene changes. Tick this checkbox to ensure Mirror does not destroy your Network Manager game object when the Scene changes in your game. Untick the checkbox if you want Mirror to destroy the game object when the Scene it exists in is no longer the active Scene. This is useful if you want to manage multiple, separate Network Manager game objects in each of your Scenes. This checkbox is ticked by default. runInBackground Use this property to control whether the networked game runs when the window it is running in is not focused. Tick the checkbox if you want it to run; untick it if you want the game to stop running when the window is not focused. This checkbox is ticked by default. You need to enable this property if you want to run multiple instances of a program on the same machine, such as when testing using localhost. You should disable it when deploying to mobile platforms. When enabled, it sets Application.runInBackground to true when the Network Manager starts up. You can also set this property from the Unity menu: Edit > Project Settings, then select the Player category, and navigate to the Resolution and Presentation panel. startOnHeadless If this box is checked (property is true) and computer that runs the program has no graphic device, program will start in server mode. serverTickRate Sets the target frame rate for the server. Default is 30. showDebugMessages Use this property to control the amount of information Mirror outputs to the console window. offlineScene If you assign a Scene to this field, the Network Manager automatically switches to the specified Scene when a network session stops - for example, when the client disconnects, or when the server shuts down. onlineScene If you assign a Scene to this field, the Network Manager automatically switches to the specified Scene when a network session starts - for example, when the client connects to a server, or when the server starts listening for connections. Network Info transport A link to a Component derived from Transport class. TelepathyTransport is created and linked there by default. networkAddress The network address currently in use. For clients, this is the address of the server that is connected to. For servers, this is the local address. This is set to ‘localhost’ by default. A Fully Qualified Domain Name (FQDN) can be used by clients in this field. maxConnections Maximum number of clients connected to a server. Note that host is a server and one client. Transports may also have their own setting for this, otherwise they either copy this value or leave it to Mirror to manage the limit. SpawnInfo You can expand this section of the inspector to access spawn-related settings, listed below playerPrefab Define the default prefab Mirror should use to create player game objects on the server. Mirror creates Player game objects in the default handler for AddPlayer on the server. Implement OnServerAddPlayer to override this behavior. autoCreatePlayer Tick this checkbox if you want Mirror to automatically create player game objects on connect, and when the Scene changes. This checkbox is ticked by default. playerSpawnMethod Define how Mirror should decide where to spawn new player game objects. This is set to Random by default. random Choose Random to spawn players at randomly chosen startPositions . roundRobin Choose Round Robin to cycle through startPositions in a set list. spawnPrefabs List of prefabs registered in the Network Manager startPositions List of Transforms built from all game objects in the scene with a Network Start Position component. clientLoadedScene Bool that indicates that the client has loaded the current scene numPlayers Returns the number of active connections from NetworkServer . Only valid on the server. networkSceneName Name of currently loaded and active scene. isNetworkActive Bool indicating that the server is online or the client is connected. client Returns the NetworkClient.singleton . isHeadless Bool that indicates of the application was started in headless mode. Methods Unity Virtual Callbacks public virtual void Awake() {} public virtual void Start() {} Server Methods public bool StartServer() {} public void StartClient() {} public void StopHost() {} public void StopServer() {} public void StopClient() {} public Transform GetStartPosition() {} Server Static Methods public static void RegisterStartPosition(Transform start) {} public static void UnRegisterStartPosition(Transform start) {} public static void Shutdown() {} Server Virtual Methods public virtual void ConfigureServerFrameRate() {} public virtual void StartHost() {} public virtual void ServerChangeScene(string newSceneName, LoadSceneMode sceneMode, LocalPhysicsMode physicsMode) {} public virtual void OnServerConnect(NetworkConnection conn) {} public virtual void OnServerDisconnect(NetworkConnection conn) {} public virtual void OnServerReady(NetworkConnection conn) {} public virtual void OnServerAddPlayer(NetworkConnection conn, AddPlayerMessage extraMessage) {} public virtual void OnServerRemovePlayer(NetworkConnection conn, NetworkIdentity player) {} public virtual void OnServerError(NetworkConnection conn, int errorCode) {} public virtual void OnServerSceneChanged(string sceneName) {} public virtual void OnStartHost() {} public virtual void OnStartServer() {} public virtual void OnStopServer() {} public virtual void OnStopHost() {} public virtual void OnDestroy() {} Client Virtual Methods public virtual void OnStartClient() {} public virtual void OnStopClient() {} public virtual void OnClientConnect(NetworkConnection conn) {} public virtual void OnClientDisconnect(NetworkConnection conn) {} public virtual void OnClientError(NetworkConnection conn, int errorCode) {} public virtual void OnClientNotReady(NetworkConnection conn) {} public virtual void OnClientChangeScene(string newSceneName, LoadSceneMode sceneMode) {} public virtual void OnClientSceneChanged(NetworkConnection conn) {}"
  },
  "Components/NetworkRoomPlayer.html": {
    "href": "Components/NetworkRoomPlayer.html",
    "title": "Network Room Player",
    "keywords": "Network Room Player The Network Room Player stores per-player state for the Network Room Manager while in the room. When using this component, you need to write a script which allows players to indicate they are ready to begin playing, which sets the ReadyToBegin property. A game object with a Network Room Player component must also have a Network Identity component. When you create a Network Room Player component on a game object, Unity also creates a Network Identity component on that game object if it does not already have one. Show Room GUI Enable this to show the developer GUI for players in the room. This UI is only intended to be used for ease of development. This is enabled by default. Ready To Begin Diagnostic indicator that a player is Ready. Index Diagnostic index of the player, e.g. Player 1, Player 2, etc. Network Sync Interval The rate at which information is sent from the Network Room Player to the server. Methods Client Virtual Methods public virtual void OnClientEnterRoom() {} public virtual void OnClientExitRoom() {} public virtual void OnClientReady(bool readyState) {}"
  },
  "index.html": {
    "href": "index.html",
    "title": "Mirror Networking for Unity",
    "keywords": "Mirror Networking for Unity Mirror is the most compatible direct replacement for the deprecated Unity Networking API. Mirror has nearly all of the components and features from UNet, making networking easy, concise and maintainable, whether you're starting from scratch or converting an existing project. We even have a Migration Tool to do most of the work for you! Built to support games of any scale, from LAN party games to dedicated high-volume authoritative servers running hundreds of players, Mirror is the core networking solution for uMMORPG , uSurvival , Cubica , and more ! uMMORPG was possible with <6000 lines of code. We needed a networking library that allows us to launch our games, period! Full Source included for debugging convenience Several working examples included Active Discord for prompt support Requires Unity 2018.3.6+ and Runtime .Net 4.x (default in Unity 2019) and .Net 2.0 Compatibility is recommended Alpha / Beta Unity versions cannot be supported Multiple Transports Available: TCP ( Telepathy ) UDP ( ENet and LiteNetLib ) WebGL ( Secure Web Sockets ) Steam ( Steamworks.Net ) Discord ( Discord DSK ) List Server We've developed a List Server where game servers can register and clients can connect to find those servers to play on them. Key Features & Components: Transports are interchangeable components Additive Scene Loading Single and separated Unity projects supported Network Authenticators to protect your game Network Discovery to easily connect LAN players to a LAN Server or Host Network Manager and HUD Network Room Manager and Room Player Network Identity Network Transform to sync position, rotation, and scale with interpolation Network Animator with 64 parameters Network Proximity Checker to help with Area of Interest Network Scene Checker to islolate players and networked objects to Additive scene instances SyncVar , SyncList , SyncEvent , SyncDictionary , and SyncHashSet Integrations Dissonance Voice Chat Network Sync Transform Noble Connect Free Rucksack RTS Engine Smooth Sync Weather Maker Steamworks Networking Master Audio Multiplayer"
  },
  "Guides/Sync/index.html": {
    "href": "Guides/Sync/index.html",
    "title": "State Synchronization",
    "keywords": "State Synchronization State synchronization refers to the synchronization of values such as integers, floating point numbers, strings and boolean values belonging to scripts. State synchronization is done from the Server to remote clients. The local client does not have data serialized to it. It does not need it, because it shares the Scene with the server. However, SyncVar hooks are called on local clients. Data is not synchronized in the opposite direction - from remote clients to the server. To do this, you need to use Commands. SyncVars SyncVars are variables of scripts that inherit from NetworkBehaviour, which are synchronized from the server to clients. SyncEvents SyncEvents are networked events like ClientRpc’s, but instead of calling a function on the game object, they trigger Events instead. SyncLists SyncLists contain lists of values and synchronize data from servers to clients. SyncDictionary A SyncDictionary is an associative array containing an unordered list of key, value pairs. SyncHashSet An unordered set of values that do not repeat. SyncSortedSet A sorted set of values that do not repeat. Sync To Owner It is often the case when you don't want some player data visible to other players. In the inspector change the \"Network Sync Mode\" from \"Observers\" (default) to \"Owner\" to let Mirror know to synchronize the data only with the owning client. For example, suppose you are making an inventory system. Suppose player A,B and C are in the same area. There will be a total of 12 objects in the entire network: Client A has Player A (himself), Player B and Player C Client B has Player A , Player B (himself) and Player C Client C has Player A , Player B and Player C (himself) Server has Player A, Player B, Player C each one of them would have an Inventory component Suppose Player A picks up some loot. The server adds the loot to Player's A inventory, which would have a SyncLists of Items. By default, Mirror now has to synchronize player A's inventory everywhere, that means sending an update message to client A, client B and client C, because they all have a copy of Player A. This is wasteful, Client B and Client C do not need to know about Player's A inventory, they never see it on screen. It is also a security problem, someone could hack the client and display other people's inventory and use it to their advantage. If you set the \"Network Sync Mode\" in the Inventory component to \"Owner\", then Player A's inventory will only be synchronized with Client A. Now, suppose instead of 3 people you have 50 people in an area and one of them picks up loot. It means that instead of sending 50 messages to 50 different clients, you would only send 1. This can have a big impact in bandwith in your game. Other typical use cases include quests, player's hand in a card game, skills, experience, or any other data you don't need to share with other players. Advanced State Synchronization In most cases, the use of SyncVars is enough for your game scripts to serialize their state to clients. However in some cases you might require more complex serialization code. This page is only relevant for advanced developers who need customized synchronization solutions that go beyond Mirror’s normal SyncVar feature. Custom Serialization Functions To perform your own custom serialization, you can implement virtual functions on NetworkBehaviour to be used for SyncVar serialization. These functions are: public virtual bool OnSerialize(NetworkWriter writer, bool initialState); public virtual void OnDeserialize(NetworkReader reader, bool initialState); Use the initialState flag to differentiate between the first time a game object is serialized and when incremental updates can be sent. The first time a game object is sent to a client, it must include a full state snapshot, but subsequent updates can save on bandwidth by including only incremental changes. Note that SyncVar hook functions are not called when initialState is true; they are only called for incremental updates. If a class has SyncVars, then implementations of these functions are added automatically to the class, meaning that a class that has SyncVars cannot also have custom serialization functions. The OnSerialize function should return true to indicate that an update should be sent. If it returns true, the dirty bits for that script are set to zero. If it returns false, the dirty bits are not changed. This allows multiple changes to a script to be accumulated over time and sent when the system is ready, instead of every frame. Although this works, it is usually better to let Mirror generate these methods and provide custom serializers for your specific field. Serialization Flow Game objects with the Network Identity component attached can have multiple scripts derived from NetworkBehaviour . The flow for serializing these game objects is: On the server: Each NetworkBehaviour has a dirty mask. This mask is available inside OnSerialize as syncVarDirtyBits Each SyncVar in a NetworkBehaviour script is assigned a bit in the dirty mask. Changing the value of SyncVars causes the bit for that SyncVar to be set in the dirty mask Alternatively, calling SetDirtyBit writes directly to the dirty mask NetworkIdentity game objects are checked on the server as part of it’s update loop If any NetworkBehaviours on a NetworkIdentity are dirty, then an UpdateVars packet is created for that game object The UpdateVars packet is populated by calling OnSerialize on each NetworkBehaviour on the game object NetworkBehaviours that are not dirty write a zero to the packet for their dirty bits NetworkBehaviours that are dirty write their dirty mask, then the values for the SyncVars that have changed If OnSerialize returns true for a NetworkBehaviour , the dirty mask is reset for that NetworkBehaviour so it does not send again until its value changes. The UpdateVars packet is sent to ready clients that are observing the game object On the client: an UpdateVars packet is received for a game object The OnDeserialize function is called for each NetworkBehaviour script on the game object Each NetworkBehaviour script on the game object reads a dirty mask. If the dirty mask for a NetworkBehaviour is zero, the OnDeserialize function returns without reading any more If the dirty mask is non-zero value, then the OnDeserialize function reads the values for the SyncVars that correspond to the dirty bits that are set If there are SyncVar hook functions, those are invoked with the value read from the stream. So for this script: public class data : NetworkBehaviour { [SyncVar] public int int1 = 66; [SyncVar] public int int2 = 23487; [SyncVar] public string MyString = \"Example string\"; } The following code sample demonstrates the generated OnSerialize function: public override bool OnSerialize(NetworkWriter writer, bool forceAll) { if (forceAll) { // The first time a game object is sent to a client, send all the data (and no dirty bits) writer.WritePackedUInt32((uint)this.int1); writer.WritePackedUInt32((uint)this.int2); writer.Write(this.MyString); return true; } bool wroteSyncVar = false; if ((base.get_syncVarDirtyBits() & 1u) != 0u) { if (!wroteSyncVar) { // Write dirty bits if this is the first SyncVar written writer.WritePackedUInt32(base.get_syncVarDirtyBits()); wroteSyncVar = true; } writer.WritePackedUInt32((uint)this.int1); } if ((base.get_syncVarDirtyBits() & 2u) != 0u) { if (!wroteSyncVar) { // Write dirty bits if this is the first SyncVar written writer.WritePackedUInt32(base.get_syncVarDirtyBits()); wroteSyncVar = true; } writer.WritePackedUInt32((uint)this.int2); } if ((base.get_syncVarDirtyBits() & 4u) != 0u) { if (!wroteSyncVar) { // Write dirty bits if this is the first SyncVar written writer.WritePackedUInt32(base.get_syncVarDirtyBits()); wroteSyncVar = true; } writer.Write(this.MyString); } if (!wroteSyncVar) { // Write zero dirty bits if no SyncVars were written writer.WritePackedUInt32(0); } return wroteSyncVar; } The following code sample demonstrates the OnDeserialize function: public override void OnDeserialize(NetworkReader reader, bool initialState) { if (initialState) { this.int1 = (int)reader.ReadPackedUInt32(); this.int2 = (int)reader.ReadPackedUInt32(); this.MyString = reader.ReadString(); return; } int num = (int)reader.ReadPackedUInt32(); if ((num & 1) != 0) { this.int1 = (int)reader.ReadPackedUInt32(); } if ((num & 2) != 0) { this.int2 = (int)reader.ReadPackedUInt32(); } if ((num & 4) != 0) { this.MyString = reader.ReadString(); } } If a NetworkBehaviour has a base class that also has serialization functions, the base class functions should also be called. Note that the UpdateVar packets created for game object state updates may be aggregated in buffers before being sent to the client, so a single transport layer packet may contain updates for multiple game objects."
  },
  "Guides/Communications/index.html": {
    "href": "Guides/Communications/index.html",
    "title": "Actions and Communication",
    "keywords": "Actions and Communication When you are making a multiplayer game, In addition to synchronizing the properties of networked game objects, you are likely to need to send, receive, and react to other pieces of information - such as when the match starts, when a player joins or leaves the match, or other information specific to your type of game, for example a notification to all players that a flag has been captured in a “capture-the-flag” style game. Within the Mirror networking High-Level API there are three main ways to communicate this type of information. Remote Actions Remote actions allow you to call a method in your script across the network. You can make the server call methods on all clients or individual clients specifically. You can also make clients call methods on the server. Using remote actions, you can pass data as parameters to your methods in a very similar way to how you call methods in local (non-multiplayer) projects. Networking Callbacks Networking callbacks allow you to hook into built-in Mirror events which occur during the course of the game, such as when players join or leave, when game objects are created or destroyed, or when a new Scene is loaded. There are two types of networking callbacks that you can implement: Network manager callbacks, for callbacks relating to the network manager itself (such as when clients connect or disconnect) Network behaviour callbacks, for callbacks relating to individual networked game objects (such as when its Start function is called, or what this particular game object should do if a new player joins the game) Network Messages Network messages are a “lower level” approach to sending messages (although they are still classed as part of the networking “High level API”). They allow you to send data directly between clients and the server using scripting. You can send basic types of data (int, string, etc) as well as most common Unity types (such as Vector3). Since you implement this yourself, these messages are not associated directly with any particular game objects or Unity events - it is up to you do decide their purpose and implement them!"
  },
  "Guides/Communications/NetworkMessages.html": {
    "href": "Guides/Communications/NetworkMessages.html",
    "title": "Network Messages",
    "keywords": "Network Messages For the most part we recommend the high level Commands and RPC calls and SyncVar , but you can also send low level network messages. This can be useful if you want clients to send messages that are not tied to game objects, such as logging, analytics or profiling information. There is a class called MessageBase that you can extend to make serializable network message classes. This class has Serialize and Deserialize functions that take writer and reader objects. You can implement these functions yourself, but we recommend you let Mirror generate them for you. The base class looks like this: public abstract class MessageBase { // Deserialize the contents of the reader into this message public virtual void Deserialize(NetworkReader reader) {} // Serialize the contents of this message into the writer public virtual void Serialize(NetworkWriter writer) {} } The auto generated Serialize/Deserialize can efficiently deal any supported mirror type . Make your members public. If you need class members or complex containers such as List and Dictionary, you must implement the Serialize and Deserialize methods yourself. To send a message, use the Send() method on the NetworkClient, NetworkServer, and NetworkConnection classes which work the same way. It takes a message object that is derived from MessageBase. The code below demonstrates how to send and handle a message: To declare a custom network message class and use it: using UnityEngine; using Mirror; public class Scores : MonoBehaviour { public class ScoreMessage : MessageBase { public int score; public Vector3 scorePos; public int lives; } public void SendScore(int score, Vector3 scorePos, int lives) { ScoreMessage msg = new ScoreMessage() { score = score, scorePos = scorePos, lives = lives }; NetworkServer.SendToAll(msg); } public void SetupClient() { NetworkClient.RegisterHandler<ScoreMessage>(OnScore); NetworkClient.Connect(\"localhost\"); } public void OnScore(NetworkConnection conn, ScoreMessage msg) { Debug.Log(\"OnScoreMessage \" + msg.score); } } Note that there is no serialization code for the ScoreMessage class in this source code example. The body of the serialization functions is automatically generated for this class by Mirror."
  },
  "Guides/DevServer/index.html": {
    "href": "Guides/DevServer/index.html",
    "title": "Development Servers",
    "keywords": "Development Servers During this guide we will set up a dedicated server and place the server build of our project on the dedicated server. IMPORTANT: Before we begin, there are some potential problems you may face, as no server is truly 'free': Service providers are NOT free. Most of the time you can start with free trials for a limited time, after x amount of time or x amount of used resources the trial will end and you might incur payment. Always read the providers free trial limitations. Some providers require a payment method for using a Windows instance, however as long as you do not go over the limitations the provider should not bill you. NOTE : Mirror is not affiliated and can not be held responsible for any charges or fees associated with service providers like AWS , Microsoft Azure , Google Compute Engine and others... Introduction During your development with Mirror you will need to test your project as a client and as a server. There are a few possible ways to test your project: Default build: Host/client as one and connecting with another build/editor to the host locally on 1 computer. Server build: Server is a separate executable. You can place it on your computer run it and connect to it as a client. Dedicated Server: Same as the server build but placed on an external machine, you connect to it with the server's external ip. This guide will focus on the \"Dedicated Server\" option. There are multiple providers and even self hosted dedicated machines. All possibilities still go through the same process to ensure connectivity to clients. A few requirements for a dedicated server: Port forwarding (Not strictly necessary but makes everything a lot easier without needing NAT punchthrough) Firewall exceptions Computer/machine that stays online and accessible whenever you need it. In the upcoming sections we will go through setting up a provider with the free tier. Always double check that you do not select a paid feature as this is purely meant as a short term period to test out basic functionality during development of your project. Microsoft Azure Microsoft Azure (as of time of writing) allows setting up a windows instance during the free trial without an active payment method. To be added Google Compute Engine Google Compute Engine (as of time of writing) does not allow setting up a windows instance during the free trial without an active payment method. To be added Self Hosted Dedicated Server A self hosted dedicated server is the same as the other providers but you provide the hardware, internet connection and costs for running the computer. Most of the time this is the cheapest option during development if you already have an extra machine. Preferably you would put the machine on a different network (to simulate the conditions as the other providers). This would mean you could connect to the machine and put your server build on whenever you need and have access to the router and security settings of the machine for port forwarding and firewall exceptions. In essence, this is the simplest set up but does require extra hardware."
  },
  "Guides/GameObjects/SpawnObject.html": {
    "href": "Guides/GameObjects/SpawnObject.html",
    "title": "Spawning Game Objects",
    "keywords": "Spawning Game Objects In Unity, you usually “spawn” (that is, create) new game objects with Instantiate . However, in Mirror, the word “spawn” means something more specific. In the server-authoritative model of the Mirror, to “spawn” a game object on the server means that the game object is created on clients connected to the server, and is managed by the spawning system. Once the game object is spawned using this system, state updates are sent to clients whenever the game object changes on the server. When Mirror destroys the game object on the server, it also destroys it on the clients. The server manages spawned game objects alongside all other networked game objects, so that if another client joins the game later, the server can spawn the game objects on that client. These spawned game objects have a unique network instance ID called “netId” that is the same on the server and clients for each game object. The unique network instance ID is used to route messages set across the network to game objects, and to identify game objects. When the server spawns a game object with a Network Identity component, the game object spawned on the client has the same “state”. This means it is identical to the game object on the server; it has the same Transform, movement state, and (if Network Transform and SyncVars are used) synchronized variables. Therefore, client game objects are always up-to-date when Mirror creates them. This avoids issues such as game objects spawning at the wrong initial location, then reappearing at their correct position when a state update arrives. The Network Manager before trying to register it with the Network Manager. To register a Prefab with the Network Manager in the Editor, select the Network Manager game object, and in the Inspector, navigate to the Network Manager component. Click the triangle next to Spawn Info to open the settings, then under Registered Spawnable Prefabs, click the plus (+) button. Drag and drop Prefabs into the empty field to assign them to the list. Spawning Without Network Manager For more advanced users, you may find that you want to register Prefabs and spawn game objects without using the Network Manager component. To spawn game objects without using the Network Manager, you can handle the Prefab registration yourself via script. Use the ClientScene.RegisterPrefab method to register Prefabs to the Network Manager. using UnityEngine; using Mirror; public class MyNetworkManager : MonoBehaviour { public GameObject treePrefab; // Register prefab and connect to the server public void ClientConnect() { ClientScene.RegisterPrefab(treePrefab); NetworkClient.RegisterHandler<ConnectMessage>(OnClientConnect); NetworkClient.Connect(\"localhost\"); } void OnClientConnect(NetworkConnection conn, ConnectMessage msg) { Debug.Log(\"Connected to server: \" + conn); } } In this example, you create an empty game object to act as the Network Manager, then create and attach the MyNetworkManager script (above) to that game object. Create a prefab that has a Network Identity component attached to it, and drag that onto the treePrefab slot on the MyNetworkManager component in the Inspector. This ensures that when the server spawns the tree game object, it also creates the same kind of game object on the clients. Registering prefabs ensures that there is no stalling or loading time for creating the Asset. For the script to work, you also need to add code for the server. Add this to the MyNetworkManager script: public void ServerListen() { NetworkServer.RegisterHandler<ConnectMessage>(OnServerConnect); NetworkServer.RegisterHandler<ReadyMessage>(OnClientReady); if (NetworkServer.Listen(7777)) Debug.Log(\"Server started listening on port 7777\"); } // When client is ready spawn a few trees void OnClientReady(NetworkConnection conn, ReadyMessage msg) { Debug.Log(\"Client is ready to start: \" + conn); NetworkServer.SetClientReady(conn); SpawnTrees(); } void SpawnTrees() { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); NetworkServer.Spawn(treeGo); } } void OnServerConnect(NetworkConnection conn, ConnectMessage msg) { Debug.Log(\"New client connected: \" + conn); } The server does not need to register anything, as it knows what game object is being spawned (and the asset ID is sent in the spawn message). The client needs to be able to look up the game object, so it must be registered on the client. When writing your own network manager, it’s important to make the client ready to receive state updates before calling the spawn command on the server, otherwise they won’t be sent. If you’re using Mirror’s built-in Network Manager component, this happens automatically. For more advanced uses, such as object pools or dynamically created Assets, you can use the ClientScene.RegisterSpawnHandler method, which allows callback functions to be registered for client-side spawning. See documentation on Custom Spawn Functions for an example of this. If the game object has a network state like synchronized variables, then that state is synchronized with the spawn message. In the following example, this script is attached to the tree Prefab: using UnityEngine; using Mirror; class Tree : NetworkBehaviour { [SyncVar] public int numLeaves; public override void OnStartClient() { Debug.Log(\"Tree spawned with leaf count \" + numLeaves); } } With this script attached, you can change the numLeaves variable and modify the SpawnTrees function to see it accurately reflected on the client: void SpawnTrees() { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); Tree tree = treeGo.GetComponent<Tree>(); tree.numLeaves = Random.Range(10,200); Debug.Log(\"Spawning leaf with leaf count \" + tree.numLeaves); NetworkServer.Spawn(treeGo); } } Attach the Tree script to the treePrefab script created earlier to see this in action. Constraints A NetworkIdentity must be on the root game object of a spawnable Prefab. Without this, the Network Manager can’t register the Prefab. NetworkBehaviour scripts must be on the same game object as the NetworkIdentity, not on child game objects Game Object Creation Flow The actual flow of internal operations that takes place for spawning game objects is: Prefab with Network Identity component is registered as spawnable. game object is instantiated from the Prefab on the server. Game code sets initial values on the instance (note that 3D physics forces applied here do not take effect immediately). NetworkServer.Spawn is called with the instance. The state of the SyncVars on the instance on the server are collected by calling OnSerialize on [Network Behaviour] components. A network message of type ObjectSpawn is sent to connected clients that includes the SyncVar data. OnStartServer is called on the instance on the server, and isServer is set to true Clients receive the ObjectSpawn message and create a new instance from the registered Prefab. The SyncVar data is applied to the new instance on the client by calling OnDeserialize on Network Behaviour components. OnStartClient is called on the instance on each client, and isClient is set to true As game play progresses, changes to SyncVar values are automatically synchronized to clients. This continues until game ends. NetworkServer.Destroy is called on the instance on the server. A network message of type ObjectDestroy is sent to clients. OnNetworkDestroy is called on the instance on clients, then the instance is destroyed. Player Game Objects Player game objects in the HLAPI work slightly differently to non-player game objects. The flow for spawning player game objects with the Network Manager is: Prefab with NetworkIdentity is registered as the PlayerPrefab Client connects to the server Client calls AddPlayer , network message of type MsgType.AddPlayer is sent to the server Server receives message and calls NetworkManager.OnServerAddPlayer game object is instantiated from the Player Prefab on the server NetworkManager.AddPlayerForConnection is called with the new player instance on the server The player instance is spawned - you do not have to call NetworkServer.Spawn for the player instance. The spawn message is sent to all clients like on a normal spawn. A network message of type Owner is sent to the client that added the player (only that client!) The original client receives the network message OnStartLocalPlayer is called on the player instance on the original client, and isLocalPlayer is set to true Note that OnStartLocalPlayer is called after OnStartClient , because it only happens when the ownership message arrives from the server after the player game object is spawned, so isLocalPlayer is not set in OnStartClient . Because OnStartLocalPlayer is only called for the client’s local player game object, it is a good place to perform initialization that should only be done for the local player. This could include enabling input processing, and enabling camera tracking for the player game object. Spawning Game Objects with Client Authority To spawn game objects and assign authority of those game objects to a particular client, use NetworkServer.Spawn , which takes as an argument the NetworkConnection of the client that is to be made the authority. For these game objects, the property hasAuthority is true on the client with authority, and OnStartAuthority is called on the client with authority. That client can issue commands for that game object. On other clients (and on the host), hasAuthority is false. Objects spawned with client authority must have LocalPlayerAuthority set in their NetworkIdentity . For example, the tree spawn example above can be modified to allow the tree to have client authority like this (note that we now need to pass in a NetworkConnection game object for the owning client’s connection): void SpawnTrees(NetworkConnection conn) { int x = 0; for (int i = 0; i < 5; ++i) { GameObject treeGo = Instantiate(treePrefab, new Vector3(x++, 0, 0), Quaternion.identity); Tree tree = treeGo.GetComponent<Tree>(); tree.numLeaves = Random.Range(10,200); Debug.Log(\"Spawning leaf with leaf count \" + tree.numLeaves); NetworkServer.Spawn(treeGo, conn); } } The Tree script can now be modified to send a command to the server: public override void OnStartAuthority() { CmdMessageFromTree(\"Tree with \" + numLeaves + \" reporting in\"); } [Command] void CmdMessageFromTree(string msg) { Debug.Log(\"Client sent a tree message: \" + msg); } Note that you can’t just add the CmdMessageFromTree call into OnStartClient , because at that point the authority has not been set yet, so the call would fail."
  },
  "Guides/index.html": {
    "href": "Guides/index.html",
    "title": "Networking Concepts Overview",
    "keywords": "Networking Concepts Overview High level scripting API Mirror’s networking has a “high-level” scripting API (which we’ll refer to as the HLAPI). Using this means you get access to commands which cover most of the common requirements for multiuser games without needing to worry about the “lower level” implementation details. The HLAPI allows you to: Control the networked state of the game using a “Network Manager”. Operate “client hosted” games, where the host is also a player client. Serialize data using a general-purpose serializer. Send and receive network messages. Send networked commands from clients to servers. Make remote procedure calls (RPCs) from servers to clients. Send networked events from servers to clients. Engine and Editor integration Mirror’s networking is integrated into the engine and the editor, allowing you to work with components and visual aids to build your multiplayer game. It provides: A NetworkIdentity component for networked objects. A NetworkBehaviour for networked scripts. Configurable automatic synchronization of object transforms. Automatic synchronization of script variables. Support for placing networked objects in Unity scenes. Network components"
  },
  "Guides/DataTypes.html": {
    "href": "Guides/DataTypes.html",
    "title": "Data types",
    "keywords": "Data types The client and server can pass data to each other via Remote methods , State Synchronization or via Network Messages Mirror supports a number of data types you can use with these, including: Basic c# types (byte, int, char, uint, UInt64, float, string, etc) Built-in Unity math type (Vector3, Quaternion, Rect, Plane, Vector3Int, etc) URI NetworkIdentity Game object with a NetworkIdentity component attached. Structures with any of the above (it's recommended to implement IEquatable<T> to avoid boxing and to have the struct readonly, cause modifying one of fields doesn't cause a resync) Classes as long as each field has a supported data type. ScriptableObject as long as each field has a supported data type Arrays of any of the above (not supported with syncvars or synclists) ArraySegments of any of the above (not supported with syncvars or synclists) Custom Data Types Sometimes you don't want mirror to generate serialization for your own types. For example, instead of serializing quest data, you may want to serialize just the quest id, and the receiver can look up the quest by id in a predefined list. Sometimes you may want to serialize data which uses a different type not supported by Mirror, such as DateTime or System.Uri You can add support for any type by adding extension methods to NetworkWriter and NetworkReader . For example, to add support for DateTime , add this somewhere in your project: public static class DateTimeReaderWriter { public static void WriteDateTime(this NetworkWriter writer, DateTime dateTime) { writer.WriteInt64(dateTime.Ticks); } public static DateTime ReadDateTime(this NetworkReader reader) { return new DateTime(reader.ReadInt64()); } } ...then you can use DateTime in your [Command] or SyncList Inheritance and Polymorphism Sometimes you might want to send a polymorphic data type to your commands. Mirror does not serialize the type name to keep messages small and for security reasons, therefore Mirror cannot figure out the type of object it received by looking at the message. This code does not work out of the box. class Item { public string name; } class Weapon : Item { public int hitPoints; } class Armor : Item { public int hitPoints; public int level; } class Player : NetworkBehaviour { [Command] void CmdEquip(Item item) { // IMPORTANT: this does not work. Mirror will pass you an object of type item // even if you pass a weapon or an armor. if (item is Weapon weapon) { // The item is a weapon, // maybe you need to equip it in the hand } else if (item is Armor armor) { // you might want to equip armor in the body } } [Command] void CmdEquipArmor(Armor armor) { // IMPORTANT: this does not work either, you will receive an armor, but // the armor will not have a valid Item.name, even if you passed an armor with name } } CmdEquip will work if you provide a custom serializer for the Item type. For example: public static class ItemSerializer { const byte WEAPON = 1; const byte ARMOR = 2; public static void WriteItem(this NetworkWriter writer, Item item) { if (item is Weapon weapon) { writer.WriteByte(WEAPON); writer.WriteString(weapon.name); writer.WritePackedInt32(weapon.hitPoints); } else if (item is Armor armor) { writer.WriteByte(ARMOR); writer.WriteString(armor.name); writer.WritePackedInt32(armor.hitPoints); writer.WritePackedInt32(armor.level); } } public static Item ReadItem(this NetworkReader reader) { byte type = reader.ReadByte(); switch(type) { case WEAPON: return new Weapon { name = reader.ReadString(), hitPoints = reader.ReadPackedInt32() }; case ARMOR: return new Armor { name = reader.ReadString(), hitPoints = reader.ReadPackedInt32(), level = reader.ReadPackedInt32() }; default: throw new Exception($\"Invalid weapon type {type}\"); } } } Scriptable Objects People often want to send scriptable objects from the client or server. For example, you may have a bunch of swords created as scriptable objects and you want put the equipped sword in a syncvar. This will work fine, Mirror will generate a reader and writer for scriptable objects by calling ScriptableObject.CreateInstance and copy all the data. However the generated reader and writer are not suitable for every occasion. Scriptable objects often reference other assets such as textures, prefabs, or other types that can't be serialized. Scriptable objects are often saved in the in the Resources folder. Scriptable objects sometimes have a large amount of data in them. The generated reader and writers may not work or may be inneficient for these situations. Instead of passing the scriptable object data, you can pass the name and the other side can lookup the same object by name. This way you can have any kind of data in your scriptable object. You can do that by providing a custom reader and writer. Here is an example: [CreateAssetMenu(fileName = \"New Armor\", menuName = \"Armor Data\")] class Armor : ScriptableObject { public int Hitpoints; public int Weight; public string Description; public Texture2D Icon; // ... } public static class ArmorSerializer { public static void WriteArmor(this NetworkWriter writer, Armor armor) { // no need to serialize the data, just the name of the armor writer.WriteString(armor.name); } public static Armor ReadArmor(this NetworkReader reader) { // load the same armor by name. The data will come from the asset in Resources folder return Resources.Load<Armor>(reader.ReadString()); } }"
  },
  "Guides/Authority.html": {
    "href": "Guides/Authority.html",
    "title": "Network Authority",
    "keywords": "Network Authority Servers and clients can both manage a game object’s behavior. The concept of “authority” refers to how and where a game object is managed. Server Authority The default state of authority in networked games using Mirror is that the Server has authority over all game objects which do not represent players. This means, for example, the server would manage control of all collectible items, moving platforms, NPCs, and any other parts of your game that players can interact with, and player game objects have authority on their owner’s client (meaning the client manages their behavior). Client Authority Client authority means the local client can control a networked game object. By default only the server has control over a networked object. In practical terms, having client authority means that the client can call Command methods, and if the client disconnects, the object is automatically destroyed. Use the NetworkIdentity.hasAuthority property in the client to find out whether a game object has local authority (also accessible on NetworkBehaviour for convenience). Assigning authority to a client causes Mirror to call OnStartAuthority() on each NetworkBehaviour on the game object on the authority client, and sets the hasAuthority property to true. On other clients, the hasAuthority property remains false. Player objects always have client authority. This is required for controlling movement and other player actions. Client Authority is not to be confused with client authoritative architecture Any action must still go to the server via a Command . The client cannot modify SyncVars or affect other clients directly Non-Player Game Objects It is possible to have client authority over non-player game objects. There are two ways to do this. One is to spawn the game object using NetworkServer.Spawn and pass the network connection of the client to take ownership. The other is to use NetworkIdentity.AssignClientAuthority with the network connection of the client to take ownership. The example below spawns a game object and assigns authority to the client of the player that spawned it. [Command] void CmdSpawn() { GameObject go = Instantiate(otherPrefab, transform.position + new Vector3(0,1,0), Quaternion.identity); NetworkServer.Spawn(go, connectionToClient); } Network Context Properties The NetworkBehaviour class contains properties that allow scripts to know what the context of a networked game object is at any time. isServer : true if the game object is on a server and has been spawned. isClient : true if the game object is on a client, and was created by the server. isLocalPlayer : true if the game object is a player game object for this client. hasAuthority : true if the game object is owned by this client. On the server, the NetworkIdentity holds the owning client in connectionToClient . To see these properties, select the game object you want to inspect, and in the Inspector window, view the preview window for the NetworkBehaviour scripting components. You can use the value of these properties to execute code based on the context in which the script is running."
  },
  "Guides/Attributes.html": {
    "href": "Guides/Attributes.html",
    "title": "Attributes Overview",
    "keywords": "Attributes Overview Networking attributes are added to member functions of NetworkBehaviour scripts, to make them run on either the client or server. These attributes can be used for Unity game loop methods like Start or Update, as well as other implemented methods. NetworkSettings This attribute has been deprecated because channels were moved to transports (where applicable) and interval was moved to an inspector property Server means don't allow a client to call that method (throws a warning or an error when called on a client). ServerCallback A Custom Attribute that can be added to member functions of NetworkBehaviour scripts, to make them only run on servers. Client means don't allow a server to call that method (throws a warning or an error when called on the server). ClientCallback A Custom Attribute that can be added to member functions of NetworkBehaviour scripts, to make them only run on clients, but not generate warnings. ClientRpc The server uses a Remote Procedure Call (RPC) to run that function on clients. See also: Remote Actions TargetRpc This is an attribute that can be put on methods of NetworkBehaviour classes to allow them to be invoked on clients from a server. Unlike the ClientRpc attribute, these functions are invoked on one individual target client, not all of the ready clients. See also: Remote Actions Command Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. Use this as a wrapper around another function, if you want to call it from the server too. See also Remote Actions​ The allowed argument types are: Basic type (byte, int, float, string, UInt64, etc) Built-in Unity math type (Vector3, Quaternion, etc), Arrays of basic types Structs containing allowable types NetworkIdentity Game object with a NetworkIdentity component attached. SyncVar SyncVars are used to synchronize a variable from the server to all clients automatically. Don't assign them from a client, it's pointless. Don't let them be null, you will get errors. You can use int, long, float, string, Vector3 etc. (all simple types) and NetworkIdentity and game object if the game object has a NetworkIdentity attached to it. You can use hooks . SyncEvent SyncEvent are networked events like ClientRpc's, but instead of calling a function on the game object, they trigger Events instead."
  },
  "Guides/NetworkBehaviour.html": {
    "href": "Guides/NetworkBehaviour.html",
    "title": "NetworkBehaviour",
    "keywords": "NetworkBehaviour See also NetworkBehaviour in the API Reference. Network Behaviour scripts work with game objects that have a NetworkIdentity component. These scripts can perform high-level API functions such as Commands, ClientRpc's, SyncEvents and SyncVars. With the server-authoritative system of Mirror, the server must use the NetworkServer.Spawn function to spawn game objects with Network Identity components. Spawning them this way assigns them a netId and creates them on clients connected to the server. Note: This is not a component that you can add to a game object directly. Instead, you must create a script which inherits from NetworkBehaviour (instead of the default MonoBehaviour ), then you can add your script as a component to a game object. Properties isServer Returns true if this game object is running on the server, and has been spawned. isClient Returns true if this game object is on the client and has been spawned by the server. isLocalPlayer Returns true if this game object represents the player created for this client. hasAuthority Returns true on the client if this client has authority over this game object. It is meaningless in server context. netId The unique network ID of this game object. The server assigns this at run time. It is unique for all game objects in that network session. netIdentity Returns the NetworkIdentity of this object connectionToServer The NetworkConnection associated with the Network Identity component attached to this game object. This is only valid for player objects on the client. connectionToClient The NetworkConnection associated with the Network Identity component attached to this game object. This is only valid for player game objects on the server. NetworkBehaviour scripts have the following features: Synchronized variables Network callbacks Server and client functions Sending commands Client RPC calls Networked events Network Callbacks There are built-in callback functions which are invoked on NetworkBehaviour scripts for various network events. These are virtual functions on the base class, so you can override them in your own code like this: public class SpaceShip : NetworkBehaviour { public override void OnStartServer() { // disable client stuff } public override void OnStartClient() { // register client events, enable effects } } The built-in callbacks are: OnStartServer called on server when a game object spawns on the server, or when the server is started for game objects in the Scene OnStopServer called on server when a game object spawns on the server, or when the server is started for game objects in the Scene OnStartClient called on clients when the game object spawns on the client, or when the client connects to a server for game objects in the Scene OnStopClient called on clients when the server destroys the game object OnStartLocalPlayer called on clients for player game objects on the local client (only) OnStartAuthority called on clients for behaviours that have authority, based on context and hasAuthority. OnStopAuthority called on clients for behaviours when authority is removed. Note that in a peer-hosted setup, when one of the clients is acting as both host and client, both OnStartServer and OnStartClient are called on the same game object. Both these functions are useful for actions that are specific to either the client or server, such as suppressing effects on a server, or setting up client-side events. Server and Client functions You can tag member functions in NetworkBehaviour scripts with custom attributes to designate them as server-only or client-only functions. Server and ServerCallback return immediately if the client is not active. Likewise, Client and ClientCallback return immediately if the server is not active. The Server and Client attributes are for your own custom callback functions. They do not generate compile time errors, but they do emit a warning log message if called in the wrong scope. The ServerCallback and ClientCallback attributes are for built-in callback functions that are called automatically by Mirror. These attributes do not cause a warning to be generated. For more information, see Attributes . Commands To execute code on the server, you must use commands. The high-level API is a server-authoritative system, so commands are the only way for a client to trigger some code on the server. Only player game objects can send commands. When a client player game object sends a command, that command runs on the corresponding player game object on the server. This routing happens automatically, so it is impossible for a client to send a command for a different player. To define a command in your code, you must write a function which has: A name that begins with Cmd The Command attribute Commands are called just by invoking the function normally on the client. Instead of the command function running on the client, it is automatically invoked on the corresponding player game object on the server. Commands are type-safe, have built-in security and routing to the player, and use an efficient serialization mechanism for the arguments to make calling them fast. See Communications and related sections for more information. Client RPC Calls Client RPC calls are a way for server game objects to make things happen on client game objects. Client RPC calls are not restricted to player game objects, and may be called on any game object with a Network Identity component. To define a Client RPC call in your code, you must write a function which: Has a name that begins with Rpc Has the ClientRpc attribute See Communications and related sections for more information. Networked Events Networked events are like Client RPC calls, but instead of calling a function on the game object, they trigger Events instead. This allows you to write scripts which can register for a callback when an event is triggered. To define a Networked event in your code, you must write a function which both: Has a name that begins with Event Has the SyncEvent attribute You can use events to build powerful networked game systems that can be extended by other scripts. This example shows how an effect script on the client can respond to events generated by a combat script on the server. SyncEvent is the base class that Commands and ClientRpc calls are derived from. You can use the SyncEvent attribute on your own functions to make your own event-driven networked game play code. Using SyncEvent, you can extend Mirror’s Multiplayer features to better fit your own programming patterns. See SyncEvents for more details."
  },
  "Guides/Authentication.html": {
    "href": "Guides/Authentication.html",
    "title": "Authentication",
    "keywords": "Authentication When you have a multiplayer game, often you need to store information about your player for later games, keep game stats or communicate with your friends. For all these use cases, you often need a way to uniquely identify a user. Being able to tell users apart is called authentication. There are several methods available, some examples include: Ask the user for username and password Use a third party oath or OpenID identity provider, such as Facebook, Twitter, Google Use a third party service such as PlayFab, GameLift or Steam Use the device id, very popular method in mobile Use Google Play in Android Use Game Center in IOS Use a web service in your website Encryption Warning By default Mirror uses Telepathy, which is not encrypted, so if you want to do authentication through Mirror, we highly recommend you use a transport that supports encryption. Message Registration By default all messages registered to NetworkServer and NetworkClient require authentication unless explicitly indicated otherwise. To register messages to bypass authentication, you need to specify false for a new bool parameter to the RegisterMessage method: NetworkServer.RegisterHandler<ConnectMessage>(OnServerConnectInternal, false); Certain internal messages already have been set to bypass authentication: Server ConnectMessage DisconnectMessage ErrorMessage NetworkPingMessage Client ConnectMessage DisconnectMessage ErrorMessage SceneMessage NetworkPongMessage Basic Authenticator Mirror includes a Basic Authenticator in the Mirror / Authenticators folder which just uses a simple username and password. Custom Authenticators Authenticators are derived from an Authenticator abstract class that allows you to implement any authentication scheme you need. From the Assets menu, click Create > Mirror > Network Authenticator to make your own custom Authenticator from our Script Templates , and just fill in the messages and validation code to suit your needs. When a client is successfully authenticated, call base.OnServerAuthenticated.Invoke(conn) on the server and base.OnClientAuthenticated.Invoke(conn) on the client. Mirror is listening for these events to proceed with the connection sequence. Subscribe to OnServerAuthenticated and OnClientAuthenticated events if you wish to perform additional steps after authentication. Tips Register handlers for messages in OnStartServer and OnStartClient . They're called from StartServer/StartHost, and StartClient, respectively. Send a message to the client if authentication fails, especially if there's some issue they can resolve. Call the Disconnect() method of the NetworkConnection on the server and client when authentication fails. If you want to give the user a few tries to get their credentials right, you certainly can, but Mirror will not do the disconnect for you. Remember to put a small delay on the Disconnect call on the server if you send a failure message so that it has a chance to be delivered before the connection is dropped. NetworkConnection has an authenticationData object where you can drop any data you need to persist on the server related to the authentication, such as account id's, tokens, character selection, etc. Now that you have the foundation of a custom Authenticator component, the rest is up to you. You can exchange any number of custom messages between the server and client as necessary to complete your authentication process before approving the client. If you write a good authenticator, consider sharing it with other users or donating it to the mirror project."
  },
  "Examples/Basic/index.html": {
    "href": "Examples/Basic/index.html",
    "title": "Basic",
    "keywords": "Basic General description of Basic example."
  },
  "Examples/Tanks/index.html": {
    "href": "Examples/Tanks/index.html",
    "title": "Tanks",
    "keywords": "Tanks General description of Tanks example."
  },
  "Examples/Pong/index.html": {
    "href": "Examples/Pong/index.html",
    "title": "Pong",
    "keywords": "Pong A simple example for \"How to built a multiplayer game with Mirror\" is Pong, which is included in the AssetStore package of Mirror. It illustrates the usage of NetworkManager, NetworkManagerHUD, NetworkBehaviour, NetworkIdentity, NetworkTransform, NetworkStartPosition and NetworkingAttributes. Setting the number of players First of all, let's have a look at the NetworkManager object in the main scene. When adding the NetworkManager component to a gameobject, a few default settings are already set ( Don't destroy on Load , Run in Background , ...) For playing Pong the maximum number of players is 2, so the setting Network Info/Max connections will also be 2. As there are no other scenes (room, online or offline scene) in this sample the properties for Offline Scene and Online Scene will stay empty. Creating the player Furthermore every player needs a racket to play with. Each player who joins the game will have his own controllable object, which represents him within the game. This gameobject is called PlayerObject . For spawning the PlayerObject a prefab has to be created, containing at least a NetworkIdentity component with Local Player Authority checked. The Local Player Authority allows the player to control and modify the gameobjects properties (e.g. for movement). The NetworkManager needs a reference to this prefab, which is located in Spawn Info/Player Prefab . To have the player movement synchronized over the network, the player prefab also contains a NetworkTransform. Player start position The main scene contains 2 gameobjects with only a NetworkStartPosition component (gameobjects RacketSpawnLeft, RacketSpawnRight in the scene). These transforms will be automatically registered by the NetworkManager as spawning positions. Setting up the network A very convenient component for establish/testing connections is the NetworkManagerHUD. It provides basic functionality for start a game as Client, Server, or Host (Client and Server at the same time). It requires the NetworkManager component. The ball of Pong The ball is the main focus of Pong, as this is the object needed to score points. Its NetworkIdentity component has neither Server Only nor Local Player Authority checked, as it's moved by the server physics engine and can be influenced by the players. As with the PlayerObject the position is synchronized via NetworkTransform. When having multiple scenes, the ball can be spawned by the NetworkManager, but to keep this sample simple, it's placed directly within the main scene."
  },
  "Examples/index.html": {
    "href": "Examples/index.html",
    "title": "Samples Overview",
    "keywords": "Samples Overview Mirror includes several small examples to help you learn how to use various features and how to set things up so they work together. Basic Basic is what it sounds like...the most rudimentary baseline of a networked game. Features SyncVars updating random UI data for each player. Tanks This is a simple scene with animated tanks, networked rigidbody projectiles, and NavMesh movement Pong A simple example for \"How to build a multiplayer game with Mirror\" is Pong. It illustrates the usage of NetworkManager , NetworkManagerHUD , NetworkBehaviour, NetworkIdentity, NetworkTransform , NetworkStartPosition and various Attributes. Additive Scenes The Additive Scenes example demonstrates a server additively loading a sub-scene into a main scene at startup, and having a server-only trigger that generates a message to any client whose player enters the trigger zone to also load the sub-scene, and subsequently unload it when they leave the trigger zone. Only players inside the trigger zone can see the objects in the sub-scene. Network Proximity Checker components are key to making this scenario work. Room System The Room System example demonstrates how to set up a \"staging\" scene where players assemble before starting a match. When all players are ready, the server sends them all a message to change scenes (along with the server itself) to the actual game play scene so they all come in at once. Includes fully playable game with a character controller where players collect server-spawned prizes for score."
  },
  "Transports/Ignorance.html": {
    "href": "Transports/Ignorance.html",
    "title": "Ignorance",
    "keywords": "Ignorance What is Ignorance? Ignorance is a reliable UDP transport layer that utilizes the native ENET C Networking library via a custom fork of ENet-CSharp providing an reliable and unreliable sequenced UDP transport for both 64Bit desktop operating systems (Windows, Mac OS and Linux) and Mobile OSes (Apple iOS and Android). It also supports up to 255 channels and 4096 clients connected at one time. ENET is a solid reliable UDP C++ network library that is mature and stable. Unity's LLAPI needs a replacement. Ignorance was designed with that goal in mind - fill the gap and provide a solid, performant RUDP transport for Mirror. Why Ignorance over the Unity LLAPI? Unity's old LLAPI was horridly inefficient, and lots of testing has shown that you will get reduced performance using Unity LLAPI in your project. This is due to the design of the old networking code - Unity Tech made \"by design\" decisions and poor bug fixes that were seen to other developers as band-aids over a gaping wound. They did not care about performance or bug fixes. Unity LLAPI was also closed source, meaning the Mirror developers could not take a knife to it and make it better. This is where the concept of Ignorance took shape. Who develops Ignorance? Coburn is the lead developer of the transport. Oiran Studio actively uses this transport for networked game projects. It is currently also being utilized by some game projects, where you can find on the Mirror Discord server. Why would I want to use reliable UDP over TCP? if you have realtime communications that you need speed over reliability (VoIP...) if you need channels if you need custom channel send types if you need a data hose for your game (a first person shooter, racing game, etc) Why wouldn't I want to use reliable UDP over TCP? if you have mission critical things (as in, data NEEDS to go from A and B, no exceptions) if you need fully reliable network protocol if you're paranoid if you're making a Minecraft-like game and need to keep everyone in sync I want to know more about reliable UDP... A little explanation is required. UDP is best described as a \"shattershot\" data transmission protocol, which means you just spray and pray that packets at a destination and hope for the best. The remote destination may or may not receive those packets, nor are they going to be in order. For example, if you have a packet stream that is: 1 2 3 4 5 6 7 ...then it may end up like any of the following on the other end due to packets arriving out of order. A dot in the following example means that packet went missing. 7 6 1 3 2 4 5 7 6 . . 4 . 1 . . . . 1 2 3 1 2 3 5 4 6 7 For example, say you lost a packet and that contained a player's health update. Everyone else might know they took 69 damage, but that client will still have the old value of say, 72 health. Without reliable UDP, you can become out of sync very quickly. When you're out of sync, the game is over - everything will start operating very strangely. Sequencing and Reliable Delivery Sequencing Sequencing basically tags packets so they know what number they are when being dispatched. So if you send packets 100, 101, 102 to the remote destination, the other end will reconstruct the packet in that order rather than in a different order (like 101, 100, 102 ). If a packet is missing, it'll be skipped but the network library will take note that it's missing and compensate. Reliable mode just tells ENET to send this while waiting for the remote to acknowledge packet reception, before claiming it was 'lost'. ENET will still classify said packets as lost if it doesn't hear back from the remote, but it will retransmit them to compensate for lossy connections or high latency situations. Reliable mode tries to emulate some of TCP's resending if not acknowledged in time, but as UDP does not have all the overhead TCP protocol has, it adds some packet overhead. Ignorance comes with two channels in both Reliable and Unreliable mode by default. There are other channel modes that developers can test as different ones might suit different loads, but the average person does not need to worry about this. Ignorance comes with sane defaults out of the box. Does Ignorance support Websockets? No, it does not. Mirror comes with built-in websockets support. Where can I get Ignorance? Grab the latest build from the releases page on the Ignorance repository . Simply import the Unity Package from the release you downloaded. Where can I get support? You can get support by opening a issue ticket on the Ignorance repository issue tracker or the #ignorance channel in the Mirror Discord server. I still don't understand what this transport is, my head is spinning, help! Come by the Discord and we'll do our best to explain it in plain English."
  },
  "Transports/Fizzy.html": {
    "href": "Transports/Fizzy.html",
    "title": "FizzySteam Transport",
    "keywords": "FizzySteam Transport Fizzy Steam is a Steam P2P transport for Mirror, it utilizes Steam's P2P service to directly connect or relay your connection to another player. Fizzy Steam is based of Steamworks.Net wrapper. You can get the release Here with the latest version of Steamworks.Net included or you can clone the repo Here . Features Multiple Customizable Channels : You can customize the channels in the transport, whether you want just 1 or 5 channels that are unreliable or reliable (best to leave channel 0 as reliable). Steam Nat Punching & Relay : The transport will use Steam to do Nat Punching to your destination, and if that doesn't work, steam's relay Server will be used to ensure you can always connect (latency may vary). No Code Changes Needed : If you Already use Mirror, you just need to slap this transport in (maybe add your steam App ID in your build), and everything should work the same like any other Mirror Transport. \"It Just Works\" -Todd Howard Credits Fizz Cube : Original author for this Transport. Chykary : The current maintainer for this Transport. rlabrecque : Creator of Steamworks.Net. vis2k : Creator of Mirror. Valve : Steam"
  },
  "Transports/LiteNetLib4Mirror.html": {
    "href": "Transports/LiteNetLib4Mirror.html",
    "title": "LiteNetLib4Mirror Transport",
    "keywords": "LiteNetLib4Mirror Transport General description of LiteNetLib4Mirror"
  },
  "Components/NetworkStartPosition.html": {
    "href": "Components/NetworkStartPosition.html",
    "title": "Network Start Position",
    "keywords": "Network Start Position To control where players are spawned, you can use the Network Start Position component. To use these, attach a Network Start Position component to a game object in the scene, and position the game object where you would like one of the players to start. You can add as many start positions to your Scene as you like. The Network Manager detects all start positions in your Scene, and when it spawns each player instance, it uses the position and orientation of one of them. The Network Manager will spawn players at (0, 0, 0) by default. Adding this component to a game object will automatically register/unregister its game object's transform to the Network Manager as an available spawning position. Depending on the Network Manager Player Spawn Method setting the spawning is either Random (possible that the same spawn position will be used by two or more players) or Round Robin (use every available position, until there are more clients than spawn points)."
  },
  "Components/NetworkDiscovery.html": {
    "href": "Components/NetworkDiscovery.html",
    "title": "Network Discovery",
    "keywords": "Network Discovery Network Discovery uses a UDP broadcast on the LAN enabling clients to find the running server and connect to it. See also our extended guide document . NetworkDiscovery and NetworkDiscoveryHUD components are included, or you can make your own from a ScriptTemplate . When a server is started, it listens on the UDP Broadcast Listen Port for requests from clients and returns a connection URI that clients apply to their transport. You can adjust how often the clients send their requests out to find a server in seconds with the Active Discovery Interval. The Server Found event must be assigned to a handler method, e.g. the OnDiscoveredServer method of NetworkDiscoveryHUD. In the NetworkDiscoveryHUD, the NetworkDiscovery component should be assigned automatically."
  },
  "Components/NetworkRoomManager.html": {
    "href": "Components/NetworkRoomManager.html",
    "title": "Network Room Manager",
    "keywords": "Network Room Manager **Please see the Room example in the Examples folder in your Mirror folder The Network Room Manager is a specialized type of Network Manager that provides a multiplayer room before entering the main play scene of the game. It allows you to set up a network with: A maximum player limit Automatic start when all players are ready Option to prevent players from joining a game in progress Customizable ways for players to choose options while in room There are two types of player objects with the Network Room Manager: Room Player Prefab One for each player Created when client connects, or player is added Persists until client disconnects Holds ready flag and configuration data Handles commands in the room Must use the Network Room Player component Player Prefab One for each player Created when game scene is started Destroyed when leaving game scene Handles commands in the game Properties Show Room GUI Show the default OnGUI controls for the room. Min Players Minimum number of players needed to start a game. Room Player Prefab The prefab to create for players when they enter the room (requires Network Room Player component). Room Scene The scene to use for the room. Gameplay Scene The scene to use for main game play. pendingPlayers List<PendingPlayer> that holds players that are ready to start playing. roomSlots List<NetworkRoomPlayer> that manages the slots for connected clients in the room. allPlayersReady Bool indicating if all players are ready to start playing. This value changes as players invoke CmdChangeReadyState indicating true or false, and will be set false when a new client connects. Methods Server Virtual Methods public virtual void OnRoomStartHost() {} public virtual void OnRoomStopHost() {} public virtual void OnRoomStartServer() {} public virtual void OnRoomServerConnect(NetworkConnection conn) {} public virtual void OnRoomServerDisconnect(NetworkConnection conn) {} public virtual void OnRoomServerSceneChanged(string sceneName) {} public virtual GameObject OnRoomServerCreateRoomPlayer(NetworkConnection conn) { return null; } public virtual GameObject OnRoomServerCreateGamePlayer(NetworkConnection conn) { return null; } public virtual bool OnRoomServerSceneLoadedForPlayer(GameObject roomPlayer, GameObject gamePlayer) { return true; } public virtual void OnRoomServerPlayersReady() { ServerChangeScene(GameplayScene); } Client Virtual Methods public virtual void OnRoomClientEnter() {} public virtual void OnRoomClientExit() {} public virtual void OnRoomClientConnect(NetworkConnection conn) {} public virtual void OnRoomClientDisconnect(NetworkConnection conn) {} public virtual void OnRoomStartClient() {} public virtual void OnRoomStopClient() {} public virtual void OnRoomClientSceneChanged(NetworkConnection conn) {} public virtual void OnRoomClientAddPlayerFailed() {}"
  },
  "Components/NetworkSceneChecker.html": {
    "href": "Components/NetworkSceneChecker.html",
    "title": "Network Scene Checker",
    "keywords": "Network Scene Checker The Network Scene Checker component controls the visibility of game objects for network clients, based on which scene they're in. Force Hidden Tick this checkbox to hide this object from all players. With the Network Scene Checker, a game running on a client doesn’t have information about game objects that are not visible. This has two main benefits: it reduces the amount of data sent across the network, and it makes your game more secure against hacking. This component would typically be used when the server has several subscenes loaded and needs to isolate networked objects to the subscene they're in. A game object with a Network Scene Checker component must also have a Network Identity component. When you create a Network Scene Checker component on a game object, Mirror also creates a Network Identity component on that game object if it does not already have one. Scene objects with a Network Scene Checker component are disabled when they're not in the same scene, and spawned objects are destroyed when they're not in the same scene. Use with Additive Scenes In Mirror, the Server and connected Clients are always on the same main scene, however the server and clients can have various combinations of smaller subscenes loaded additively. The server may load all subscenes at start, or it may dynamically load and unload subscenes where players or other activity is going on as needed. All player objects are always first spawned in the main scene, which may or may not have visual content, networked objects, etc. With this component attached to all networked objects, whenever the player object is moved to a subscene (from the main or from another subscene), the observers lists for objects in both the new scene and the prior scene are updated accordingly. Loading the subscene(s) on the server is through the normal process with SceneManager : SceneManager.LoadSceneAsync(subScene, LoadSceneMode.Additive); Next, you will send a SceneMessage to the client telling it to load a subscene additively: SceneMessage msg = new SceneMessage { sceneName = subScene, sceneOperation = SceneOperation.LoadAdditive }; connectionToClient.Send(msg); Then, on the server only, you just move the player object to the subscene: // Position the player object in world space first // This assumes it has a NetworkTransform component that will update clients player.transform.position = new Vector3(100, 1, 100); // Then move the player object to the subscene SceneManager.MoveGameObjectToScene(player, subScene); Optionally you can send another SceneMessage to the client with SceneOperation.UnloadAdditive to remove any previous additive scene the client no longer needs. This would apply to a game that has levels after a level change. A short delay may be necessary before removal to allow the client to get fully synced. Depending on the complexity of your game, you may find it helpful when switching a player between subscenes to move the player object to the main scene first, yield 100 ms, re-position it, and finally move it to the new subscene."
  },
  "Components/NetworkTransform.html": {
    "href": "Components/NetworkTransform.html",
    "title": "Network Transform",
    "keywords": "Network Transform https://www.youtube.com/watch?v=Z0th49NERl4&list=PLkx8oFug638oBYF5EOwsSS-gOVBXj1dkP&index=3 The Network Transform component synchronizes the position, rotation, and scale of networked game objects across the network. A game object with a Network Transform component must also have a Network Identity component. When you add a Network Transform component to a game object, Mirror also adds a Network Identity component on that game object if it does not already have one. By default, Network Transform is server-authoritative unless you check the box for Client Authority . Client Authority applies to player objects as well as non-player objects that have been specifically assigned to a client, but only for this component. With this enabled, position changes are send from the client to the server. Under Sensitivity , you can set the minimum thresholds of change to the transform values in order for network messages to be generated. This helps minimize network \"noise\" for minor twitch and jitter. Normally, changes are sent to all observers of the object this component is on. Setting Sync Mode to Owner Only makes the changes private between the server and the client owner of the object. You can use the Sync Interval to specify how often it syncs (in seconds)."
  },
  "Components/NetworkManagerHUD.html": {
    "href": "Components/NetworkManagerHUD.html",
    "title": "Network Manager HUD",
    "keywords": "Network Manager HUD The Network Manager HUD (“heads-up display”) is a quick-start tool to help you start building your multiplayer game straight away, without first having to build a user interface for game creation/connection/joining. It allows you to jump straight into your game play programming, and means you can build your own version of these controls later in your development schedule. It is not, however, intended to be included in finished games. The idea is that these controls are useful to get you started, but you should create your own UI later on, to allow your players to find and join games in a way that suits your game. For example, you might want to stylize the design of the screens, buttons and list of available games to match the overall style of your game. To start using the Network Manager HUD, either add the component to the same scene object that has the Network Manager component, or create an empty game object in your scene (menu: game object > Create Empty) and add the Network Manager HUD component to the new game object. Show GUI Tick this checkbox to show the HUD GUI at run time. This allows you to reveal or hide it for quick debugging. Offset X Set the horizontal pixel offset of the HUD GUI, measured from the left edge of the screen. Offset Y Set the vertical pixel offset of the HUD GUI, measured from the top edge of the screen. The Network Manager HUD provides the basic functions so that people playing your game can start hosting a networked game, or find and join an existing networked game. Unity displays the Network Manager HUD as a collection of simple UI buttons in the Game view. Using the HUD The Network Manager HUD starts in Server + Client mode, and displays buttons relating to hosting and joining a multiplayer game. Host (Server + Client) Click the Host (Server + Client) button to start a game as a host on the local network. This client is both the host and one of the players in the game. It uses the information from the Network Info section in the inspector to host the game. When you click this button, the HUD switches to a simple display of network details, and a Stop button which allows you to stop hosting the game and return to the main HUD menu. When you have started a game as a host, other players of the game can then connect to the host to join the game. Click the Stop button to disconnect from the host. Clicking Stop also returns to the main HUD menu. Client To connect to a host on the internet use the text field to the right of the Client button to specify the address of the host. The default host address is “localhost”, which means the client looks on its own computer for the game host. In addition to localhost , you can specify an IPv4 address, and IPv6 address, or a fully-qualified domain name (FQDN), e.g. game.example.com , and the transport with resolve the name using DNS. Click Client to attempt to connect to the host address you have specified. Use the default “localhost” in this field if you are running multiple instances of your game on one computer, to test multiplayer interactivity. To do this, you can create a standalone build of your game, and then launch it multiple times on your computer. This is a common way to quickly test that your networked game interactions are functioning as you expect, without you needing to deploy your game to multiple computers or devices. When you want to test your game on multiple machines you need to put the address of the computer acting as host into the address text field. The computer acting as the host needs to tell their IP address to everyone running clients, so that you can type this into the box. For local clients on a LAN, that's the local IP address. For remote clients, that's the WAN IP address of the router of the host. Firewall rules and port-forwarding are generally required for a computer to act as host and accept connections from other computers, whether they're on the LAN or the internet. Enter the IP address (or leave it as “localhost” if you are testing it on your own machine), then click Client to attempt to connect to the host. When the client is attempting to connect, the HUD displays a Cancel Connection Attempt button. Click this if you want to stop trying to connect to the host. If the connection is successful, the HUD displays the Stop button. Click this if you want to stop the game on the client and disconnect from the host: Server Only Click Server Only to start a game which acts as a server that other clients can connect to, but which does not act as a client to the game itself. This type of game is often called a “dedicated server”. A user cannot play the game on this particular instance of your game. All players must connect as clients, and nobody plays on the instance that is running as the server. A dedicated server results in better performance for all connected players, because the server doesn’t need to process a local player’s game play in addition to acting as server. You might also choose this option if you want to host a game that can be played over the internet (rather than just within a local network), but want to maintain control of the server yourself - for example, to prevent cheating by one of the clients, because only the server has authority over the game. To do this, you would need to run the game in Server Only mode on a computer with a public IP address."
  },
  "api/Mirror.PlayerSpawner.html": {
    "href": "api/Mirror.PlayerSpawner.html",
    "title": "Class PlayerSpawner",
    "keywords": "Class PlayerSpawner Spawns a player as soon as the connection is authenticated Inheritance Object PlayerSpawner Namespace : Mirror Assembly : doc.dll Syntax public class PlayerSpawner : MonoBehaviour Fields | Improve this Doc View Source client Declaration public NetworkClient client Field Value Type Description NetworkClient | Improve this Doc View Source playerPrefab Declaration public NetworkIdentity playerPrefab Field Value Type Description NetworkIdentity | Improve this Doc View Source playerSpawnMethod The current method of spawning players used by the NetworkManager. Declaration public PlayerSpawner.PlayerSpawnMethod playerSpawnMethod Field Value Type Description PlayerSpawner.PlayerSpawnMethod | Improve this Doc View Source server Declaration public NetworkServer server Field Value Type Description NetworkServer | Improve this Doc View Source startPositionIndex Declaration public int startPositionIndex Field Value Type Description Int32 | Improve this Doc View Source startPositions List of transforms where players can be spawned Declaration public List<Transform> startPositions Field Value Type Description List < Transform > Methods | Improve this Doc View Source GetStartPosition() This finds a spawn position based on start position objects in the scene. This is used by the default implementation of OnServerAddPlayer. Declaration public virtual Transform GetStartPosition() Returns Type Description Transform Returns the transform to spawn a player at, or null. | Improve this Doc View Source OnServerAddPlayer(INetworkConnection) Called on the server when a client adds a new player with ClientScene.AddPlayer. The default implementation for this function creates a new player object from the playerPrefab. Declaration public virtual void OnServerAddPlayer(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Connection from client. | Improve this Doc View Source Start() Declaration public virtual void Start()"
  },
  "api/Mirror.MessageBase.html": {
    "href": "api/Mirror.MessageBase.html",
    "title": "Class MessageBase",
    "keywords": "Class MessageBase Inheritance Object MessageBase ServerRequest ServerResponse Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public abstract class MessageBase : object, IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public virtual void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public virtual void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkIdentity.ClientAuthorityCallback.html": {
    "href": "api/Mirror.NetworkIdentity.ClientAuthorityCallback.html",
    "title": "Delegate NetworkIdentity.ClientAuthorityCallback",
    "keywords": "Delegate NetworkIdentity.ClientAuthorityCallback The delegate type for the clientAuthorityCallback. Namespace : Mirror Assembly : doc.dll Syntax public delegate void ClientAuthorityCallback(INetworkConnection conn, NetworkIdentity identity, bool authorityState); Parameters Type Name Description INetworkConnection conn The network connection that is gaining or losing authority. NetworkIdentity identity The object whose client authority status is being changed. Boolean authorityState The new state of client authority of the object for the connection."
  },
  "api/Mirror.Channels.html": {
    "href": "api/Mirror.Channels.html",
    "title": "Class Channels",
    "keywords": "Class Channels Inheritance Object Channels Namespace : Mirror Assembly : doc.dll Syntax public static class Channels : object Fields | Improve this Doc View Source DefaultReliable Declaration public const int DefaultReliable = null Field Value Type Description Int32 | Improve this Doc View Source DefaultUnreliable Declaration public const int DefaultUnreliable = null Field Value Type Description Int32"
  },
  "api/Mirror.SyncHashSet-1.html": {
    "href": "api/Mirror.SyncHashSet-1.html",
    "title": "Class SyncHashSet<T>",
    "keywords": "Class SyncHashSet<T> Inheritance Object SyncSet <T> SyncHashSet<T> Implements ISyncObject Inherited Members SyncSet<T>.objects SyncSet<T>.Count SyncSet<T>.IsReadOnly SyncSet<T>.OnAdd SyncSet<T>.OnClear SyncSet<T>.OnRemove SyncSet<T>.OnChange SyncSet<T>.Reset() SyncSet<T>.SerializeItem(NetworkWriter, T) SyncSet<T>.DeserializeItem(NetworkReader) SyncSet<T>.IsDirty SyncSet<T>.Flush() SyncSet<T>.OnSerializeAll(NetworkWriter) SyncSet<T>.OnSerializeDelta(NetworkWriter) SyncSet<T>.OnDeserializeAll(NetworkReader) SyncSet<T>.OnDeserializeDelta(NetworkReader) SyncSet<T>.Add(T) SyncSet<T>.Clear() SyncSet<T>.Contains(T) SyncSet<T>.CopyTo(T[], Int32) SyncSet<T>.Remove(T) SyncSet<T>.ExceptWith(IEnumerable<T>) SyncSet<T>.IntersectWith(IEnumerable<T>) SyncSet<T>.IsProperSubsetOf(IEnumerable<T>) SyncSet<T>.IsProperSupersetOf(IEnumerable<T>) SyncSet<T>.IsSubsetOf(IEnumerable<T>) SyncSet<T>.IsSupersetOf(IEnumerable<T>) SyncSet<T>.Overlaps(IEnumerable<T>) SyncSet<T>.SetEquals(IEnumerable<T>) SyncSet<T>.SymmetricExceptWith(IEnumerable<T>) SyncSet<T>.UnionWith(IEnumerable<T>) Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncHashSet<T> : SyncSet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncHashSet(IEqualityComparer<T>) Declaration protected SyncHashSet(IEqualityComparer<T> comparer = null) Parameters Type Name Description IEqualityComparer <T> comparer Methods | Improve this Doc View Source GetEnumerator() Declaration public HashSet<T>.Enumerator GetEnumerator() Returns Type Description HashSet.Enumerator <> Implements ISyncObject"
  },
  "api/Mirror.ShowInInspectorAttribute.html": {
    "href": "api/Mirror.ShowInInspectorAttribute.html",
    "title": "Class ShowInInspectorAttribute",
    "keywords": "Class ShowInInspectorAttribute Used to show private SyncList in the inspector, Use instead of SerializeField for non Serializable types Inheritance Object ShowInInspectorAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ShowInInspectorAttribute : Attribute"
  },
  "api/Mirror.NetworkTransformBase.html": {
    "href": "api/Mirror.NetworkTransformBase.html",
    "title": "Class NetworkTransformBase",
    "keywords": "Class NetworkTransformBase Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransform NetworkTransformChild Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.Client NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRpc(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.GetDelegate(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirror Assembly : doc.dll Syntax public abstract class NetworkTransformBase : NetworkBehaviour Fields | Improve this Doc View Source ClientAuthority Declaration public bool ClientAuthority Field Value Type Description Boolean | Improve this Doc View Source LocalPositionSensitivity Declaration public float LocalPositionSensitivity Field Value Type Description Single | Improve this Doc View Source LocalRotationSensitivity Declaration public float LocalRotationSensitivity Field Value Type Description Single | Improve this Doc View Source LocalScaleSensitivity Declaration public float LocalScaleSensitivity Field Value Type Description Single Properties | Improve this Doc View Source TargetComponent Declaration protected abstract Transform TargetComponent { get; } Property Value Type Description Transform Methods | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Declaration public override void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Boolean initialState Overrides NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Declaration public override bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Boolean initialState Returns Type Description Boolean Overrides NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) | Improve this Doc View Source SerializeIntoWriter(NetworkWriter, Vector3, Quaternion, Vector3) Declaration public static void SerializeIntoWriter(NetworkWriter writer, Vector3 position, Quaternion rotation, Vector3 scale) Parameters Type Name Description NetworkWriter writer Vector3 position Quaternion rotation Vector3 scale"
  },
  "api/Mirror.ClientAttribute.html": {
    "href": "api/Mirror.ClientAttribute.html",
    "title": "Class ClientAttribute",
    "keywords": "Class ClientAttribute Prevents the server from running this method. Prints a warning if the server tries to execute this method. Inheritance Object ClientAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ClientAttribute : Attribute"
  },
  "api/Mirror.ObjectDestroyMessage.html": {
    "href": "api/Mirror.ObjectDestroyMessage.html",
    "title": "Struct ObjectDestroyMessage",
    "keywords": "Struct ObjectDestroyMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ObjectDestroyMessage : IMessageBase Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SyncEventAttribute.html": {
    "href": "api/Mirror.SyncEventAttribute.html",
    "title": "Class SyncEventAttribute",
    "keywords": "Class SyncEventAttribute SyncEvents are networked events like ClientRpc's, but instead of calling a function on the game object, they trigger Events instead. Inheritance Object SyncEventAttribute Namespace : Mirror Assembly : doc.dll Syntax public class SyncEventAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description Int32"
  },
  "api/Mirror.NetworkTransform.html": {
    "href": "api/Mirror.NetworkTransform.html",
    "title": "Class NetworkTransform",
    "keywords": "Class NetworkTransform Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransform Inherited Members NetworkTransformBase.ClientAuthority NetworkTransformBase.LocalPositionSensitivity NetworkTransformBase.LocalRotationSensitivity NetworkTransformBase.LocalScaleSensitivity NetworkTransformBase.SerializeIntoWriter(NetworkWriter, Vector3, Quaternion, Vector3) NetworkTransformBase.OnSerialize(NetworkWriter, Boolean) NetworkTransformBase.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.Client NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRpc(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.GetDelegate(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkTransform : NetworkTransformBase Properties | Improve this Doc View Source TargetComponent Declaration protected override Transform TargetComponent { get; } Property Value Type Description Transform Overrides NetworkTransformBase.TargetComponent"
  },
  "api/Mirror.RemovePlayerMessage.html": {
    "href": "api/Mirror.RemovePlayerMessage.html",
    "title": "Struct RemovePlayerMessage",
    "keywords": "Struct RemovePlayerMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct RemovePlayerMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SceneMessage.html": {
    "href": "api/Mirror.SceneMessage.html",
    "title": "Struct SceneMessage",
    "keywords": "Struct SceneMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct SceneMessage : IMessageBase Fields | Improve this Doc View Source customHandling Declaration public bool customHandling Field Value Type Description Boolean | Improve this Doc View Source sceneName Declaration public string sceneName Field Value Type Description String | Improve this Doc View Source sceneOperation Declaration public SceneOperation sceneOperation Field Value Type Description SceneOperation Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkDiagnostics.html": {
    "href": "api/Mirror.NetworkDiagnostics.html",
    "title": "Class NetworkDiagnostics",
    "keywords": "Class NetworkDiagnostics Provides profiling information from mirror A profiler can subscribe to these events and present the data in a friendly way to the user Inheritance Object NetworkDiagnostics Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkDiagnostics : object Events | Improve this Doc View Source InMessageEvent Event that gets raised when Mirror receives a message Subscribe to this if you want to profile the network Declaration public static event Action<NetworkDiagnostics.MessageInfo> InMessageEvent Event Type Type Description Action < NetworkDiagnostics.MessageInfo > | Improve this Doc View Source OutMessageEvent Event that gets raised when Mirror sends a message Subscribe to this if you want to diagnose the network Declaration public static event Action<NetworkDiagnostics.MessageInfo> OutMessageEvent Event Type Type Description Action < NetworkDiagnostics.MessageInfo >"
  },
  "api/Mirror.Version.html": {
    "href": "api/Mirror.Version.html",
    "title": "Enum Version",
    "keywords": "Enum Version Namespace : Mirror Assembly : doc.dll Syntax public enum Version : int Fields Name Description Current"
  },
  "api/Mirror.SyncEventMessage.html": {
    "href": "api/Mirror.SyncEventMessage.html",
    "title": "Struct SyncEventMessage",
    "keywords": "Struct SyncEventMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct SyncEventMessage : IMessageBase Fields | Improve this Doc View Source componentIndex Declaration public int componentIndex Field Value Type Description Int32 | Improve this Doc View Source functionHash Declaration public int functionHash Field Value Type Description Int32 | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte > Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SyncListUInt.html": {
    "href": "api/Mirror.SyncListUInt.html",
    "title": "Class SyncListUInt",
    "keywords": "Class SyncListUInt Inheritance Object SyncList < UInt32 > SyncListUInt Implements IReadOnlyList < UInt32 > ISyncObject Inherited Members SyncList<UInt32>.Count SyncList<UInt32>.IsReadOnly SyncList<UInt32>.OnInsert SyncList<UInt32>.OnClear SyncList<UInt32>.OnRemove SyncList<UInt32>.OnSet SyncList<UInt32>.OnChange SyncList<UInt32>.IsDirty SyncList<UInt32>.Flush() SyncList<UInt32>.Reset() SyncList<UInt32>.OnSerializeAll(NetworkWriter) SyncList<UInt32>.OnSerializeDelta(NetworkWriter) SyncList<UInt32>.OnDeserializeAll(NetworkReader) SyncList<UInt32>.OnDeserializeDelta(NetworkReader) SyncList<UInt32>.Add(UInt32) SyncList<UInt32>.Clear() SyncList<UInt32>.Contains(UInt32) SyncList<UInt32>.CopyTo(UInt32[], Int32) SyncList<UInt32>.IndexOf(UInt32) SyncList<UInt32>.FindIndex(Predicate<UInt32>) SyncList<UInt32>.Find(Predicate<UInt32>) SyncList<UInt32>.FindAll(Predicate<UInt32>) SyncList<UInt32>.Insert(Int32, UInt32) SyncList<UInt32>.Remove(UInt32) SyncList<UInt32>.RemoveAt(Int32) SyncList<UInt32>.Item[Int32] SyncList<UInt32>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListUInt : SyncList<uint>, IReadOnlyList<uint>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override uint DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt32 Overrides Mirror.SyncList<System.UInt32>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, UInt32) Declaration protected override void SerializeItem(NetworkWriter writer, uint item) Parameters Type Name Description NetworkWriter writer UInt32 item Overrides Mirror.SyncList<System.UInt32>.SerializeItem(Mirror.NetworkWriter, System.UInt32) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.Websocket.html": {
    "href": "api/Mirror.Websocket.html",
    "title": "Namespace Mirror.Websocket",
    "keywords": "Namespace Mirror.Websocket Classes AsyncWsTransport"
  },
  "api/Mirror.SyncIDictionary-2.html": {
    "href": "api/Mirror.SyncIDictionary-2.html",
    "title": "Class SyncIDictionary<TKey, TValue>",
    "keywords": "Class SyncIDictionary<TKey, TValue> Inheritance Object SyncIDictionary<TKey, TValue> SyncDictionary<TKey, TValue> Implements ISyncObject Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncIDictionary<TKey, TValue> : IDictionary<TKey, TValue>, ISyncObject Type Parameters Name Description TKey TValue Constructors | Improve this Doc View Source SyncIDictionary(IDictionary<TKey, TValue>) Declaration protected SyncIDictionary(IDictionary<TKey, TValue> objects) Parameters Type Name Description IDictionary <TKey, TValue> objects Fields | Improve this Doc View Source objects Declaration protected readonly IDictionary<TKey, TValue> objects Field Value Type Description IDictionary <TKey, TValue> Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source Item[TKey] Declaration public TValue this[TKey i] { get; set; } Parameters Type Name Description TKey i Property Value Type Description TValue | Improve this Doc View Source Keys Declaration public ICollection<TKey> Keys { get; } Property Value Type Description ICollection <TKey> | Improve this Doc View Source Values Declaration public ICollection<TValue> Values { get; } Property Value Type Description ICollection <TValue> Methods | Improve this Doc View Source Add(TKey, TValue) Declaration public void Add(TKey key, TValue value) Parameters Type Name Description TKey key TValue value | Improve this Doc View Source Add(KeyValuePair<TKey, TValue>) Declaration public void Add(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(KeyValuePair<TKey, TValue>) Declaration public bool Contains(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item Returns Type Description Boolean | Improve this Doc View Source ContainsKey(TKey) Declaration public bool ContainsKey(TKey key) Parameters Type Name Description TKey key Returns Type Description Boolean | Improve this Doc View Source CopyTo(KeyValuePair<TKey, TValue>[], Int32) Declaration public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex) Parameters Type Name Description KeyValuePair <TKey, TValue>[] array Int32 arrayIndex | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected virtual TValue DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description TValue | Improve this Doc View Source DeserializeKey(NetworkReader) Declaration protected virtual TKey DeserializeKey(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description TKey | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() Returns Type Description IEnumerator < KeyValuePair <TKey, TValue>> | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Remove(TKey) Declaration public bool Remove(TKey key) Parameters Type Name Description TKey key Returns Type Description Boolean | Improve this Doc View Source Remove(KeyValuePair<TKey, TValue>) Declaration public bool Remove(KeyValuePair<TKey, TValue> item) Parameters Type Name Description KeyValuePair <TKey, TValue> item Returns Type Description Boolean | Improve this Doc View Source Reset() Declaration public void Reset() | Improve this Doc View Source SerializeItem(NetworkWriter, TValue) Declaration protected virtual void SerializeItem(NetworkWriter writer, TValue item) Parameters Type Name Description NetworkWriter writer TValue item | Improve this Doc View Source SerializeKey(NetworkWriter, TKey) Declaration protected virtual void SerializeKey(NetworkWriter writer, TKey item) Parameters Type Name Description NetworkWriter writer TKey item | Improve this Doc View Source TryGetValue(TKey, out TValue) Declaration public bool TryGetValue(TKey key, out TValue value) Parameters Type Name Description TKey key TValue value Returns Type Description Boolean Events | Improve this Doc View Source OnChange Raised after the dictionary has been updated Note that if there are multiple changes this event is only raised once. Declaration public event Action OnChange Event Type Type Description Action | Improve this Doc View Source OnClear Raised when the dictionary is cleared Declaration public event Action OnClear Event Type Type Description Action | Improve this Doc View Source OnInsert Raised when an element is added to the dictionary. Receives the key and value of the new item Declaration public event Action<TKey, TValue> OnInsert Event Type Type Description Action <TKey, TValue> | Improve this Doc View Source OnRemove Raised when an item is removed from the dictionary receives the key and value of the old item Declaration public event Action<TKey, TValue> OnRemove Event Type Type Description Action <TKey, TValue> | Improve this Doc View Source OnSet Raised when an item is changed in a dictionary Receives key, the old value and the new value Declaration public event Action<TKey, TValue, TValue> OnSet Event Type Type Description Action <TKey, TValue, TValue> Implements ISyncObject"
  },
  "api/Mirror.NetworkIdentity.html": {
    "href": "api/Mirror.NetworkIdentity.html",
    "title": "Class NetworkIdentity",
    "keywords": "Class NetworkIdentity The NetworkIdentity identifies objects across the network, between server and clients. Its primary data is a NetworkInstanceId which is allocated by the server and then set on clients. This is used in network communications to be able to lookup game objects on different machines. Inheritance Object NetworkIdentity Namespace : Mirror Assembly : doc.dll Syntax public sealed class NetworkIdentity : MonoBehaviour Remarks The NetworkIdentity is used to synchronize information in the object with the network. Only the server should create instances of objects which have NetworkIdentity as otherwise they will not be properly connected to the system. For complex objects with a hierarchy of subcomponents, the NetworkIdentity must be on the root of the hierarchy. It is not supported to have multiple NetworkIdentity components on subcomponents of a hierarchy. NetworkBehaviour scripts require a NetworkIdentity on the game object to be able to function. The NetworkIdentity manages the dirty state of the NetworkBehaviours of the object. When it discovers that NetworkBehaviours are dirty, it causes an update packet to be created and sent to clients. The flow for serialization updates managed by the NetworkIdentity is: * Each NetworkBehaviour has a dirty mask. This mask is available inside OnSerialize as syncVarDirtyBits * Each SyncVar in a NetworkBehaviour script is assigned a bit in the dirty mask. * Changing the value of SyncVars causes the bit for that SyncVar to be set in the dirty mask * Alternatively, calling SetDirtyBit() writes directly to the dirty mask * NetworkIdentity objects are checked on the server as part of it's update loop * If any NetworkBehaviours on a NetworkIdentity are dirty, then an UpdateVars packet is created for that object * The UpdateVars packet is populated by calling OnSerialize on each NetworkBehaviour on the object * NetworkBehaviours that are NOT dirty write a zero to the packet for their dirty bits * NetworkBehaviours that are dirty write their dirty mask, then the values for the SyncVars that have changed * If OnSerialize returns true for a NetworkBehaviour, the dirty mask is reset for that NetworkBehaviour, so it will not send again until its value changes. * The UpdateVars packet is sent to ready clients that are observing the object On the client: * an UpdateVars packet is received for an object * The OnDeserialize function is called for each NetworkBehaviour script on the object * Each NetworkBehaviour script on the object reads a dirty mask. * If the dirty mask for a NetworkBehaviour is zero, the OnDeserialize functions returns without reading any more * If the dirty mask is non-zero value, then the OnDeserialize function reads the values for the SyncVars that correspond to the dirty bits that are set * If there are SyncVar hook functions, those are invoked with the value read from the stream. Fields | Improve this Doc View Source observers The set of network connections (players) that can see this object. null until OnStartServer was called. this is necessary for SendTo* to work properly in server-only mode. Declaration public readonly HashSet<INetworkConnection> observers Field Value Type Description HashSet < INetworkConnection > | Improve this Doc View Source OnStartAuthority This is invoked on behaviours that have authority, based on context and HasAuthority . This is called after OnStartServer and before OnStartClient When AssignClientAuthority(INetworkConnection) is called on the server, this will be called on the client that owns the object. When an object is spawned with Spawn(GameObject, GameObject) with a NetworkConnection parameter included, this will be called on the client that owns the object. Declaration public UnityEvent OnStartAuthority Field Value Type Description UnityEvent | Improve this Doc View Source OnStartClient Called on every NetworkBehaviour when it is activated on a client. Objects on the host have this function called, as there is a local client on the host. The values of SyncVars on object are guaranteed to be initialized correctly with the latest state from the server when this function is called on the client. Declaration public UnityEvent OnStartClient Field Value Type Description UnityEvent | Improve this Doc View Source OnStartLocalPlayer Called when the local player object has been set up. This happens after OnStartClient(), as it is triggered by an ownership message from the server. This is an appropriate place to activate components or functionality that should only be active for the local player, such as cameras and input. Declaration public UnityEvent OnStartLocalPlayer Field Value Type Description UnityEvent | Improve this Doc View Source OnStartServer This is invoked for NetworkBehaviour objects when they become active on the server. This could be triggered by NetworkServer.Listen() for objects in the scene, or by NetworkServer.Spawn() for objects that are dynamically created. This will be called for objects on a \"host\" as well as for object on a dedicated server. Declaration public UnityEvent OnStartServer Field Value Type Description UnityEvent | Improve this Doc View Source OnStopAuthority This is invoked on behaviours when authority is removed. When NetworkIdentity.RemoveClientAuthority is called on the server, this will be called on the client that owns the object. Declaration public UnityEvent OnStopAuthority Field Value Type Description UnityEvent | Improve this Doc View Source OnStopClient This is invoked on clients when the server has caused this object to be destroyed. This can be used as a hook to invoke effects or do client specific cleanup. Declaration public UnityEvent OnStopClient Field Value Type Description UnityEvent | Improve this Doc View Source OnStopServer This is called on the server when the object is unspawned Declaration public UnityEvent OnStopServer Field Value Type Description UnityEvent Remarks Can be used as hook to save player information | Improve this Doc View Source sceneId A unique identifier for NetworkIdentity objects within a scene. This is used for spawning scene objects on clients. Declaration public ulong sceneId Field Value Type Description UInt64 | Improve this Doc View Source serverOnly Flag to make this object only exist when the game is running as a server (or host). Declaration public bool serverOnly Field Value Type Description Boolean Properties | Improve this Doc View Source AssetId Unique identifier used to find the source assets when server spawns the on clients. Declaration public Guid AssetId { get; } Property Value Type Description Guid | Improve this Doc View Source Client The NetworkClient associated with this NetworkIdentity. Declaration public NetworkClient Client { get; } Property Value Type Description NetworkClient | Improve this Doc View Source ConnectionToClient The NetworkConnection associated with this NetworkIdentity This is valid for player and other owned objects in the server. Use it to return details such as the connection's identity, IP address and ready status. Declaration public INetworkConnection ConnectionToClient { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source ConnectionToServer The NetworkConnection associated with this NetworkIdentity. This is only valid for player objects on a local client. Declaration public INetworkConnection ConnectionToServer { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source HasAuthority This returns true if this object is the authoritative player object on the client. This value is determined at runtime. For most objects, authority is held by the server. For objects that had their authority set by AssignClientAuthority on the server, this will be true on the client that owns the object. NOT on other clients. Declaration public bool HasAuthority { get; } Property Value Type Description Boolean | Improve this Doc View Source IsClient Returns true if running as a client and this object was spawned by a server. Declaration public bool IsClient { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalClient Returns true if we're on host mode. Declaration public bool IsLocalClient { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalPlayer This returns true if this object is the one that represents the player on the local machine. This is set when the server has spawned an object for this particular client. Declaration public bool IsLocalPlayer { get; } Property Value Type Description Boolean | Improve this Doc View Source IsServer Returns true if NetworkServer.active and server is not stopped. Declaration public bool IsServer { get; } Property Value Type Description Boolean | Improve this Doc View Source NetId Unique identifier for this particular object instance, used for tracking objects between networked clients and the server. This is a unique identifier for this particular GameObject instance. Use it to track GameObjects between networked clients and the server. Declaration public uint NetId { get; } Property Value Type Description UInt32 | Improve this Doc View Source NetworkBehaviours Declaration public NetworkBehaviour[] NetworkBehaviours { get; } Property Value Type Description NetworkBehaviour [] | Improve this Doc View Source Server The NetworkServer associated with this NetworkIdentity. Declaration public NetworkServer Server { get; } Property Value Type Description NetworkServer | Improve this Doc View Source Visibility Declaration public NetworkVisibility Visibility { get; } Property Value Type Description NetworkVisibility Methods | Improve this Doc View Source AssignClientAuthority(INetworkConnection) Assign control of an object to a client via the client's NetworkConnection This causes hasAuthority to be set on the client that owns the object, and NetworkBehaviour.OnStartAuthority will be called on that client. This object then will be in the NetworkConnection.clientOwnedObjects list for the connection. Authority can be removed with RemoveClientAuthority. Only one client can own an object at any time. This does not need to be called for player objects, as their authority is setup automatically. Declaration public void AssignClientAuthority(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn The connection of the client to assign authority to. | Improve this Doc View Source GetSceneIdentity(UInt64) Gets the NetworkIdentity from the sceneIds dictionary with the corresponding id Declaration public static NetworkIdentity GetSceneIdentity(ulong id) Parameters Type Name Description UInt64 id Returns Type Description NetworkIdentity NetworkIdentity from the sceneIds dictionary | Improve this Doc View Source RebuildObservers(Boolean) This causes the set of players that can see this object to be rebuild. The OnRebuildObservers callback function will be invoked on each NetworkBehaviour. Declaration public void RebuildObservers(bool initialize) Parameters Type Name Description Boolean initialize True if this is the first time. | Improve this Doc View Source RemoveClientAuthority() Removes ownership for an object. This applies to objects that had authority set by AssignClientAuthority, or Spawn(GameObject, GameObject) with a NetworkConnection parameter included. Authority cannot be removed for player objects. Declaration public void RemoveClientAuthority() | Improve this Doc View Source ResetNextNetworkId() Resets nextNetworkId = 1 Declaration public static void ResetNextNetworkId() Events | Improve this Doc View Source clientAuthorityCallback A callback that can be populated to be notified when the client-authority state of objects changes. Whenever an object is spawned with client authority, or the client authority status of an object is changed with AssignClientAuthority or RemoveClientAuthority, then this callback will be invoked. This callback is only invoked on the server. Declaration public static event NetworkIdentity.ClientAuthorityCallback clientAuthorityCallback Event Type Type Description NetworkIdentity.ClientAuthorityCallback"
  },
  "api/Mirror.NetworkWriterExtensions.html": {
    "href": "api/Mirror.NetworkWriterExtensions.html",
    "title": "Class NetworkWriterExtensions",
    "keywords": "Class NetworkWriterExtensions Inheritance Object NetworkWriterExtensions Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkWriterExtensions : object Methods | Improve this Doc View Source WriteBoolean(NetworkWriter, Boolean) Declaration public static void WriteBoolean(this NetworkWriter writer, bool value) Parameters Type Name Description NetworkWriter writer Boolean value | Improve this Doc View Source WriteByte(NetworkWriter, Byte) Declaration public static void WriteByte(this NetworkWriter writer, byte value) Parameters Type Name Description NetworkWriter writer Byte value | Improve this Doc View Source WriteBytesAndSize(NetworkWriter, Byte[]) Declaration public static void WriteBytesAndSize(this NetworkWriter writer, byte[] buffer) Parameters Type Name Description NetworkWriter writer Byte [] buffer | Improve this Doc View Source WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32) Declaration public static void WriteBytesAndSize(this NetworkWriter writer, byte[] buffer, int offset, int count) Parameters Type Name Description NetworkWriter writer Byte [] buffer Int32 offset Int32 count | Improve this Doc View Source WriteBytesAndSizeSegment(NetworkWriter, ArraySegment<Byte>) Declaration public static void WriteBytesAndSizeSegment(this NetworkWriter writer, ArraySegment<byte> buffer) Parameters Type Name Description NetworkWriter writer ArraySegment < Byte > buffer | Improve this Doc View Source WriteChar(NetworkWriter, Char) Declaration public static void WriteChar(this NetworkWriter writer, char value) Parameters Type Name Description NetworkWriter writer Char value | Improve this Doc View Source WriteColor(NetworkWriter, Color) Declaration public static void WriteColor(this NetworkWriter writer, Color value) Parameters Type Name Description NetworkWriter writer Color value | Improve this Doc View Source WriteColor32(NetworkWriter, Color32) Declaration public static void WriteColor32(this NetworkWriter writer, Color32 value) Parameters Type Name Description NetworkWriter writer Color32 value | Improve this Doc View Source WriteDecimal(NetworkWriter, Decimal) Declaration public static void WriteDecimal(this NetworkWriter writer, decimal value) Parameters Type Name Description NetworkWriter writer Decimal value | Improve this Doc View Source WriteDouble(NetworkWriter, Double) Declaration public static void WriteDouble(this NetworkWriter writer, double value) Parameters Type Name Description NetworkWriter writer Double value | Improve this Doc View Source WriteGameObject(NetworkWriter, GameObject) Declaration public static void WriteGameObject(this NetworkWriter writer, GameObject value) Parameters Type Name Description NetworkWriter writer GameObject value | Improve this Doc View Source WriteGuid(NetworkWriter, Guid) Declaration public static void WriteGuid(this NetworkWriter writer, Guid value) Parameters Type Name Description NetworkWriter writer Guid value | Improve this Doc View Source WriteInt16(NetworkWriter, Int16) Declaration public static void WriteInt16(this NetworkWriter writer, short value) Parameters Type Name Description NetworkWriter writer Int16 value | Improve this Doc View Source WriteMatrix4x4(NetworkWriter, Matrix4x4) Declaration public static void WriteMatrix4x4(this NetworkWriter writer, Matrix4x4 value) Parameters Type Name Description NetworkWriter writer Matrix4x4 value | Improve this Doc View Source WriteMessage<T>(NetworkWriter, T) Declaration public static void WriteMessage<T>(this NetworkWriter writer, T msg) where T : IMessageBase Parameters Type Name Description NetworkWriter writer T msg Type Parameters Name Description T | Improve this Doc View Source WriteNetworkIdentity(NetworkWriter, NetworkIdentity) Declaration public static void WriteNetworkIdentity(this NetworkWriter writer, NetworkIdentity value) Parameters Type Name Description NetworkWriter writer NetworkIdentity value | Improve this Doc View Source WritePackedInt32(NetworkWriter, Int32) Declaration public static void WritePackedInt32(this NetworkWriter writer, int i) Parameters Type Name Description NetworkWriter writer Int32 i | Improve this Doc View Source WritePackedInt64(NetworkWriter, Int64) Declaration public static void WritePackedInt64(this NetworkWriter writer, long i) Parameters Type Name Description NetworkWriter writer Int64 i | Improve this Doc View Source WritePackedUInt32(NetworkWriter, UInt32) Declaration public static void WritePackedUInt32(this NetworkWriter writer, uint value) Parameters Type Name Description NetworkWriter writer UInt32 value | Improve this Doc View Source WritePackedUInt64(NetworkWriter, UInt64) Declaration public static void WritePackedUInt64(this NetworkWriter writer, ulong value) Parameters Type Name Description NetworkWriter writer UInt64 value | Improve this Doc View Source WritePlane(NetworkWriter, Plane) Declaration public static void WritePlane(this NetworkWriter writer, Plane value) Parameters Type Name Description NetworkWriter writer Plane value | Improve this Doc View Source WriteQuaternion(NetworkWriter, Quaternion) Declaration public static void WriteQuaternion(this NetworkWriter writer, Quaternion value) Parameters Type Name Description NetworkWriter writer Quaternion value | Improve this Doc View Source WriteRay(NetworkWriter, Ray) Declaration public static void WriteRay(this NetworkWriter writer, Ray value) Parameters Type Name Description NetworkWriter writer Ray value | Improve this Doc View Source WriteRect(NetworkWriter, Rect) Declaration public static void WriteRect(this NetworkWriter writer, Rect value) Parameters Type Name Description NetworkWriter writer Rect value | Improve this Doc View Source WriteSByte(NetworkWriter, SByte) Declaration public static void WriteSByte(this NetworkWriter writer, sbyte value) Parameters Type Name Description NetworkWriter writer SByte value | Improve this Doc View Source WriteSingle(NetworkWriter, Single) Declaration public static void WriteSingle(this NetworkWriter writer, float value) Parameters Type Name Description NetworkWriter writer Single value | Improve this Doc View Source WriteString(NetworkWriter, String) Declaration public static void WriteString(this NetworkWriter writer, string value) Parameters Type Name Description NetworkWriter writer String value | Improve this Doc View Source WriteTransform(NetworkWriter, Transform) Declaration public static void WriteTransform(this NetworkWriter writer, Transform value) Parameters Type Name Description NetworkWriter writer Transform value | Improve this Doc View Source WriteUInt16(NetworkWriter, UInt16) Declaration public static void WriteUInt16(this NetworkWriter writer, ushort value) Parameters Type Name Description NetworkWriter writer UInt16 value | Improve this Doc View Source WriteUri(NetworkWriter, Uri) Declaration public static void WriteUri(this NetworkWriter writer, Uri uri) Parameters Type Name Description NetworkWriter writer Uri uri | Improve this Doc View Source WriteVector2(NetworkWriter, Vector2) Declaration public static void WriteVector2(this NetworkWriter writer, Vector2 value) Parameters Type Name Description NetworkWriter writer Vector2 value | Improve this Doc View Source WriteVector2Int(NetworkWriter, Vector2Int) Declaration public static void WriteVector2Int(this NetworkWriter writer, Vector2Int value) Parameters Type Name Description NetworkWriter writer Vector2Int value | Improve this Doc View Source WriteVector3(NetworkWriter, Vector3) Declaration public static void WriteVector3(this NetworkWriter writer, Vector3 value) Parameters Type Name Description NetworkWriter writer Vector3 value | Improve this Doc View Source WriteVector3Int(NetworkWriter, Vector3Int) Declaration public static void WriteVector3Int(this NetworkWriter writer, Vector3Int value) Parameters Type Name Description NetworkWriter writer Vector3Int value | Improve this Doc View Source WriteVector4(NetworkWriter, Vector4) Declaration public static void WriteVector4(this NetworkWriter writer, Vector4 value) Parameters Type Name Description NetworkWriter writer Vector4 value"
  },
  "api/Mirror.NetworkBehaviour.Invoker.html": {
    "href": "api/Mirror.NetworkBehaviour.Invoker.html",
    "title": "Class NetworkBehaviour.Invoker",
    "keywords": "Class NetworkBehaviour.Invoker Inheritance Object NetworkBehaviour.Invoker Namespace : Mirror Assembly : doc.dll Syntax protected class Invoker : object Fields | Improve this Doc View Source invokeClass Declaration public Type invokeClass Field Value Type Description Type | Improve this Doc View Source invokeFunction Declaration public NetworkBehaviour.CmdDelegate invokeFunction Field Value Type Description NetworkBehaviour.CmdDelegate | Improve this Doc View Source invokeType Declaration public MirrorInvokeType invokeType Field Value Type Description MirrorInvokeType"
  },
  "api/Mirror.NetworkClient.html": {
    "href": "api/Mirror.NetworkClient.html",
    "title": "Class NetworkClient",
    "keywords": "Class NetworkClient This is a network client class used by the networking system. It contains a NetworkConnection that is used to connect to a network server. The NetworkClient handle connection state, messages handlers, and connection configuration. There can be many NetworkClient instances in a process at a time, but only one that is connected to a game server ( NetworkServer ) that uses spawned objects. NetworkClient has an internal update function where it handles events from the transport layer. This includes asynchronous connect events, disconnect events and incoming data from a server. The NetworkManager has a NetworkClient instance that it uses for games that it starts, but the NetworkClient may be used by itself. Inheritance Object NetworkClient Implements INetworkClient IClientObjectManager IClientSceneManager Namespace : Mirror Assembly : doc.dll Syntax public class NetworkClient : MonoBehaviour, INetworkClient, IClientObjectManager, IClientSceneManager Fields | Improve this Doc View Source Authenticated Event fires after the Client connection has sucessfully been authenticated with its Server. Declaration public NetworkClient.NetworkConnectionEvent Authenticated Field Value Type Description NetworkClient.NetworkConnectionEvent | Improve this Doc View Source authenticator Declaration public NetworkAuthenticator authenticator Field Value Type Description NetworkAuthenticator | Improve this Doc View Source ClientChangeScene Event fires when the Client starts changing scene. Declaration public NetworkClient.ClientSceneChangeEvent ClientChangeScene Field Value Type Description NetworkClient.ClientSceneChangeEvent | Improve this Doc View Source ClientNotReady Declaration public NetworkClient.NetworkConnectionEvent ClientNotReady Field Value Type Description NetworkClient.NetworkConnectionEvent | Improve this Doc View Source ClientSceneChanged Event fires after the Client has completed its scene change. Declaration public NetworkClient.NetworkConnectionEvent ClientSceneChanged Field Value Type Description NetworkClient.NetworkConnectionEvent | Improve this Doc View Source Connected Event fires once the Client has connected its Server. Declaration public NetworkClient.NetworkConnectionEvent Connected Field Value Type Description NetworkClient.NetworkConnectionEvent | Improve this Doc View Source Disconnected Event fires after the Client has disconnected from its Server and Cleanup has been called. Declaration public UnityEvent Disconnected Field Value Type Description UnityEvent | Improve this Doc View Source spawnableObjects This is dictionary of the disabled NetworkIdentity objects in the scene that could be spawned by messages from the server. The key to the dictionary is the NetworkIdentity sceneId. Declaration public readonly Dictionary<ulong, NetworkIdentity> spawnableObjects Field Value Type Description Dictionary < UInt64 , NetworkIdentity > | Improve this Doc View Source spawnPrefabs List of prefabs that will be registered with the spawning system. For each of these prefabs, ClientManager.RegisterPrefab() will be automatically invoke. Declaration public List<GameObject> spawnPrefabs Field Value Type Description List < GameObject > | Improve this Doc View Source Time Declaration public readonly NetworkTime Time Field Value Type Description NetworkTime | Improve this Doc View Source Transport Declaration public AsyncTransport Transport Field Value Type Description AsyncTransport Properties | Improve this Doc View Source Active active is true while a client is connecting/connected (= while the network is active) Declaration public bool Active { get; } Property Value Type Description Boolean | Improve this Doc View Source Connection The NetworkConnection object this client is using. Declaration public INetworkConnection Connection { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source IsConnected This gives the current connection status of the client. Declaration public bool IsConnected { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalClient NetworkClient can connect to local server in host mode too Declaration public bool IsLocalClient { get; } Property Value Type Description Boolean | Improve this Doc View Source LocalPlayer NetworkIdentity of the localPlayer Declaration public NetworkIdentity LocalPlayer { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source ready Returns true when a client's connection has been set to ready. A client that is ready recieves state updates from the server, while a client that is not ready does not. This useful when the state of the game is not normal, such as a scene change or end-of-game. This is read-only. To change the ready state of a client, use ClientScene.Ready(). The server is able to set the ready state of clients using NetworkServer.SetClientReady(), NetworkServer.SetClientNotReady() and NetworkServer.SetAllClientsNotReady(). This is done when changing scenes so that clients don't receive state update messages during scene loading. Declaration public bool ready { get; } Property Value Type Description Boolean | Improve this Doc View Source Spawned List of all objects spawned in this client Declaration public Dictionary<uint, NetworkIdentity> Spawned { get; } Property Value Type Description Dictionary < UInt32 , NetworkIdentity > Methods | Improve this Doc View Source ClearSpawners() This clears the registered spawn prefabs and spawn handler functions for this client. Declaration public void ClearSpawners() | Improve this Doc View Source ConnectAsync(Uri) Connect client to a NetworkServer instance. Declaration public Task ConnectAsync(Uri uri) Parameters Type Name Description Uri uri Address of the server to connect to Returns Type Description Task | Improve this Doc View Source DestroyAllClientObjects() Destroys all networked objects on the client. This can be used to clean up when a network connection is closed. Declaration public void DestroyAllClientObjects() | Improve this Doc View Source Disconnect() Disconnect from server. The disconnect message will be invoked. Declaration public void Disconnect() | Improve this Doc View Source GetPrefab(System.Guid, out GameObject) Find the registered prefab for this asset id. Useful for debuggers Declaration public bool GetPrefab(System.Guid assetId, out GameObject prefab) Parameters Type Name Description System.Guid assetId asset id of the prefab GameObject prefab the prefab gameobject Returns Type Description Boolean true if prefab was registered | Improve this Doc View Source PrepareToSpawnSceneObjects() Call this after loading/unloading a scene in the client after connection to register the spawnable objects Declaration public void PrepareToSpawnSceneObjects() | Improve this Doc View Source Ready(INetworkConnection) Signal that the client connection is ready to enter the game. This could be for example when a client enters an ongoing game and has finished loading the current scene. The server should respond to the SYSTEM_READY event with an appropriate handler which instantiates the players object for example. Declaration public void Ready(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn The client connection which is ready. | Improve this Doc View Source RegisterPrefab(GameObject) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The NetworkManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public void RegisterPrefab(GameObject prefab) Parameters Type Name Description GameObject prefab A Prefab that will be spawned. | Improve this Doc View Source RegisterPrefab(GameObject, SpawnDelegate, UnSpawnDelegate) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The NetworkManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public void RegisterPrefab(GameObject prefab, SpawnDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description GameObject prefab A Prefab that will be spawned. SpawnDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RegisterPrefab(GameObject, SpawnHandlerDelegate, UnSpawnDelegate) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The NetworkManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public void RegisterPrefab(GameObject prefab, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description GameObject prefab A Prefab that will be spawned. SpawnHandlerDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RegisterPrefab(GameObject, System.Guid) Registers a prefab with the spawning system. When a NetworkIdentity object is spawned on a server with NetworkServer.SpawnObject(), and the prefab that the object was created from was registered with RegisterPrefab(), the client will use that prefab to instantiate a corresponding client object with the same netId. The NetworkManager has a list of spawnable prefabs, it uses this function to register those prefabs with the ClientScene. The set of current spawnable object is available in the ClientScene static member variable ClientScene.prefabs, which is a dictionary of NetworkAssetIds and prefab references. Declaration public void RegisterPrefab(GameObject prefab, System.Guid newAssetId) Parameters Type Name Description GameObject prefab A Prefab that will be spawned. System.Guid newAssetId An assetId to be assigned to this prefab. This allows a dynamically created game object to be registered for an already known asset Id. | Improve this Doc View Source RegisterSpawnHandler(System.Guid, SpawnDelegate, UnSpawnDelegate) This is an advanced spawning function that registers a custom assetId with the UNET spawning system. This can be used to register custom spawning methods for an assetId - instead of the usual method of registering spawning methods for a prefab. This should be used when no prefab exists for the spawned objects - such as when they are constructed dynamically at runtime from configuration data. Declaration public void RegisterSpawnHandler(System.Guid assetId, SpawnDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description System.Guid assetId Custom assetId string. SpawnDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RegisterSpawnHandler(System.Guid, SpawnHandlerDelegate, UnSpawnDelegate) This is an advanced spawning function that registers a custom assetId with the UNET spawning system. This can be used to register custom spawning methods for an assetId - instead of the usual method of registering spawning methods for a prefab. This should be used when no prefab exists for the spawned objects - such as when they are constructed dynamically at runtime from configuration data. Declaration public void RegisterSpawnHandler(System.Guid assetId, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description System.Guid assetId Custom assetId string. SpawnHandlerDelegate spawnHandler A method to use as a custom spawnhandler on clients. UnSpawnDelegate unspawnHandler A method to use as a custom un-spawnhandler on clients. | Improve this Doc View Source RemovePlayer() Removes the player from the game. Declaration public bool RemovePlayer() Returns Type Description Boolean True if succcessful | Improve this Doc View Source Send<T>(T, Int32) Declaration public void Send<T>(T message, int channelId = null) where T : IMessageBase Parameters Type Name Description T message Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendAsync<T>(T, Int32) This sends a network message with a message Id to the server. This message is sent on channel zero, which by default is the reliable channel. The message must be an instance of a class derived from MessageBase. The message id passed to Send() is used to identify the handler function to invoke on the server when the message is received. Declaration public Task SendAsync<T>(T message, int channelId = null) where T : IMessageBase Parameters Type Name Description T message Int32 channelId Returns Type Description Task True if message was sent. Type Parameters Name Description T The message type to unregister. | Improve this Doc View Source UnregisterPrefab(GameObject) Removes a registered spawn prefab that was setup with ClientScene.RegisterPrefab. Declaration public void UnregisterPrefab(GameObject prefab) Parameters Type Name Description GameObject prefab The prefab to be removed from registration. | Improve this Doc View Source UnregisterSpawnHandler(System.Guid) Removes a registered spawn handler function that was registered with ClientScene.RegisterHandler(). Declaration public void UnregisterSpawnHandler(System.Guid assetId) Parameters Type Name Description System.Guid assetId The assetId for the handler to be removed for. Implements INetworkClient IClientObjectManager IClientSceneManager"
  },
  "api/Mirror.AddPlayerMessage.html": {
    "href": "api/Mirror.AddPlayerMessage.html",
    "title": "Struct AddPlayerMessage",
    "keywords": "Struct AddPlayerMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct AddPlayerMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.Discovery.NetworkDiscovery.html": {
    "href": "api/Mirror.Discovery.NetworkDiscovery.html",
    "title": "Class NetworkDiscovery",
    "keywords": "Class NetworkDiscovery Inheritance Object NetworkDiscoveryBase < ServerRequest , ServerResponse > NetworkDiscovery Inherited Members NetworkDiscoveryBase<ServerRequest, ServerResponse>.SupportedOnThisPlatform NetworkDiscoveryBase<ServerRequest, ServerResponse>.secretHandshake NetworkDiscoveryBase<ServerRequest, ServerResponse>.serverUdpClient NetworkDiscoveryBase<ServerRequest, ServerResponse>.clientUdpClient NetworkDiscoveryBase<ServerRequest, ServerResponse>.RandomLong() NetworkDiscoveryBase<ServerRequest, ServerResponse>.Start() NetworkDiscoveryBase<ServerRequest, ServerResponse>.AdvertiseServer() NetworkDiscoveryBase<ServerRequest, ServerResponse>.ServerListenAsync() NetworkDiscoveryBase<ServerRequest, ServerResponse>.ProcessClientRequest(ServerRequest, IPEndPoint) NetworkDiscoveryBase<ServerRequest, ServerResponse>.ProcessRequest(ServerRequest, IPEndPoint) NetworkDiscoveryBase<ServerRequest, ServerResponse>.StartDiscovery() NetworkDiscoveryBase<ServerRequest, ServerResponse>.StopDiscovery() NetworkDiscoveryBase<ServerRequest, ServerResponse>.ClientListenAsync() NetworkDiscoveryBase<ServerRequest, ServerResponse>.BroadcastDiscoveryRequest() NetworkDiscoveryBase<ServerRequest, ServerResponse>.GetRequest() NetworkDiscoveryBase<ServerRequest, ServerResponse>.ProcessResponse(ServerResponse, IPEndPoint) Namespace : Mirror.Discovery Assembly : doc.dll Syntax public class NetworkDiscovery : NetworkDiscoveryBase<ServerRequest, ServerResponse> Fields | Improve this Doc View Source OnServerFound Declaration public ServerFoundUnityEvent OnServerFound Field Value Type Description ServerFoundUnityEvent | Improve this Doc View Source transport Declaration public AsyncTransport transport Field Value Type Description AsyncTransport Properties | Improve this Doc View Source ServerId Declaration public long ServerId { get; } Property Value Type Description Int64 Methods | Improve this Doc View Source GetRequest() Create a message that will be broadcasted on the network to discover servers Declaration protected override ServerRequest GetRequest() Returns Type Description ServerRequest An instance of ServerRequest with data to be broadcasted Overrides Mirror.Discovery.NetworkDiscoveryBase<Mirror.Discovery.ServerRequest, Mirror.Discovery.ServerResponse>.GetRequest() Remarks Override if you wish to include additional data in the discovery message such as desired game mode, language, difficulty, etc... | Improve this Doc View Source ProcessRequest(ServerRequest, IPEndPoint) Process the request from a client Declaration protected override ServerResponse ProcessRequest(ServerRequest request, IPEndPoint endpoint) Parameters Type Name Description ServerRequest request Request comming from client IPEndPoint endpoint Address of the client that sent the request Returns Type Description ServerResponse The message to be sent back to the client or null Overrides Mirror.Discovery.NetworkDiscoveryBase<Mirror.Discovery.ServerRequest, Mirror.Discovery.ServerResponse>.ProcessRequest(Mirror.Discovery.ServerRequest, IPEndPoint) Remarks Override if you wish to provide more information to the clients such as the name of the host player | Improve this Doc View Source ProcessResponse(ServerResponse, IPEndPoint) Process the answer from a server Declaration protected override void ProcessResponse(ServerResponse response, IPEndPoint endpoint) Parameters Type Name Description ServerResponse response Response that came from the server IPEndPoint endpoint Address of the server that replied Overrides Mirror.Discovery.NetworkDiscoveryBase<Mirror.Discovery.ServerRequest, Mirror.Discovery.ServerResponse>.ProcessResponse(Mirror.Discovery.ServerResponse, IPEndPoint) Remarks A client receives a reply from a server, this method processes the reply and raises an event | Improve this Doc View Source Start() Declaration public override void Start() Overrides Mirror.Discovery.NetworkDiscoveryBase<Mirror.Discovery.ServerRequest, Mirror.Discovery.ServerResponse>.Start()"
  },
  "api/Mirror.NetworkDiagnostics.MessageInfo.html": {
    "href": "api/Mirror.NetworkDiagnostics.MessageInfo.html",
    "title": "Struct NetworkDiagnostics.MessageInfo",
    "keywords": "Struct NetworkDiagnostics.MessageInfo Describes an outgoing message Namespace : Mirror Assembly : doc.dll Syntax public struct MessageInfo Fields | Improve this Doc View Source bytes how big was the message (does not include transport headers) Declaration public readonly int bytes Field Value Type Description Int32 | Improve this Doc View Source channel channel through which the message was sent Declaration public readonly int channel Field Value Type Description Int32 | Improve this Doc View Source count How many connections was the message sent to If an object has a lot of observers this count could be high Declaration public readonly int count Field Value Type Description Int32 | Improve this Doc View Source message The message being sent Declaration public readonly IMessageBase message Field Value Type Description IMessageBase"
  },
  "api/Mirror.AsyncTransport.html": {
    "href": "api/Mirror.AsyncTransport.html",
    "title": "Class AsyncTransport",
    "keywords": "Class AsyncTransport Base transport class, any transport should implement this class and it's abstract methods Inheritance Object AsyncTransport AsyncFallbackTransport AsyncMultiplexTransport AsyncTcpTransport AsyncWsTransport Namespace : Mirror Assembly : doc.dll Syntax public abstract class AsyncTransport : MonoBehaviour Properties | Improve this Doc View Source Scheme Declaration public abstract string Scheme { get; } Property Value Type Description String Methods | Improve this Doc View Source AcceptAsync() Accepts a connection from a client. After ListenAsync completes, clients will queue up until you call AcceptAsync then you get the connection to the client Declaration public abstract Task<IConnection> AcceptAsync() Returns Type Description Task < IConnection > The connection to a client | Improve this Doc View Source ConnectAsync(Uri) Connect to a server located at a provided uri Declaration public abstract Task<IConnection> ConnectAsync(Uri uri) Parameters Type Name Description Uri uri address of the server to connect to Returns Type Description Task < IConnection > The connection to the server | Improve this Doc View Source Disconnect() Stop listening to the port Declaration public abstract void Disconnect() | Improve this Doc View Source ListenAsync() Open up the port and listen for connections Use in servers. Declaration public abstract Task ListenAsync() Returns Type Description Task | Improve this Doc View Source ServerUri() Retrieves the address of this server. Useful for network discovery Declaration public abstract Uri ServerUri() Returns Type Description Uri the url at which this server can be reached"
  },
  "api/Mirror.ObjectHideMessage.html": {
    "href": "api/Mirror.ObjectHideMessage.html",
    "title": "Struct ObjectHideMessage",
    "keywords": "Struct ObjectHideMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ObjectHideMessage : IMessageBase Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SpawnHandlerDelegate.html": {
    "href": "api/Mirror.SpawnHandlerDelegate.html",
    "title": "Delegate SpawnHandlerDelegate",
    "keywords": "Delegate SpawnHandlerDelegate Namespace : Mirror Assembly : doc.dll Syntax public delegate GameObject SpawnHandlerDelegate(SpawnMessage msg); Parameters Type Name Description SpawnMessage msg Returns Type Description GameObject"
  },
  "api/Mirror.ClientCallbackAttribute.html": {
    "href": "api/Mirror.ClientCallbackAttribute.html",
    "title": "Class ClientCallbackAttribute",
    "keywords": "Class ClientCallbackAttribute Prevents the server from running this method. No warning is printed. Inheritance Object ClientCallbackAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ClientCallbackAttribute : Attribute"
  },
  "api/Mirror.NetworkProximityChecker.CheckMethod.html": {
    "href": "api/Mirror.NetworkProximityChecker.CheckMethod.html",
    "title": "Enum NetworkProximityChecker.CheckMethod",
    "keywords": "Enum NetworkProximityChecker.CheckMethod Enumeration of methods to use to check proximity. Namespace : Mirror Assembly : doc.dll Syntax public enum CheckMethod : int Fields Name Description Physics2D Physics3D"
  },
  "api/Mirror.INetworkClient.html": {
    "href": "api/Mirror.INetworkClient.html",
    "title": "Interface INetworkClient",
    "keywords": "Interface INetworkClient Inherited Members IClientObjectManager.GetPrefab(Guid, GameObject) IClientObjectManager.RemovePlayer() IClientObjectManager.RegisterPrefab(GameObject) IClientObjectManager.RegisterPrefab(GameObject, Guid) IClientObjectManager.RegisterPrefab(GameObject, SpawnDelegate, UnSpawnDelegate) IClientObjectManager.RegisterPrefab(GameObject, SpawnHandlerDelegate, UnSpawnDelegate) IClientObjectManager.UnregisterPrefab(GameObject) IClientObjectManager.RegisterSpawnHandler(Guid, SpawnDelegate, UnSpawnDelegate) IClientObjectManager.RegisterSpawnHandler(Guid, SpawnHandlerDelegate, UnSpawnDelegate) IClientObjectManager.UnregisterSpawnHandler(Guid) IClientObjectManager.ClearSpawners() IClientObjectManager.DestroyAllClientObjects() IClientSceneManager.PrepareToSpawnSceneObjects() Namespace : Mirror Assembly : doc.dll Syntax public interface INetworkClient : IClientObjectManager, IClientSceneManager Methods | Improve this Doc View Source Disconnect() Declaration void Disconnect() | Improve this Doc View Source Ready(INetworkConnection) Declaration void Ready(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn | Improve this Doc View Source Send<T>(T, Int32) Declaration void Send<T>(T message, int channelId = null) where T : IMessageBase Parameters Type Name Description T message Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendAsync<T>(T, Int32) Declaration Task SendAsync<T>(T message, int channelId = null) where T : IMessageBase Parameters Type Name Description T message Int32 channelId Returns Type Description Task Type Parameters Name Description T"
  },
  "api/Mirror.INetworkConnection.html": {
    "href": "api/Mirror.INetworkConnection.html",
    "title": "Interface INetworkConnection",
    "keywords": "Interface INetworkConnection A connection to a remote endpoint. May be from the server to client or from client to server Inherited Members IMessageHandler.RegisterHandler<T>(Action<INetworkConnection, T>) IMessageHandler.RegisterHandler<T>(Action<T>) IMessageHandler.UnregisterHandler<T>() IMessageHandler.ClearHandlers() IMessageHandler.Send<T>(T, Int32) IMessageHandler.SendAsync<T>(T, Int32) IMessageHandler.ProcessMessagesAsync() IVisibilityTracker.AddToVisList(NetworkIdentity) IVisibilityTracker.RemoveFromVisList(NetworkIdentity) IVisibilityTracker.RemoveObservers() IObjectOwner.Identity IObjectOwner.RemoveOwnedObject(NetworkIdentity) IObjectOwner.AddOwnedObject(NetworkIdentity) IObjectOwner.DestroyOwnedObjects() Namespace : Mirror Assembly : doc.dll Syntax public interface INetworkConnection : IMessageHandler, IVisibilityTracker, IObjectOwner Properties | Improve this Doc View Source Address Declaration EndPoint Address { get; } Property Value Type Description EndPoint | Improve this Doc View Source AuthenticationData Declaration object AuthenticationData { get; set; } Property Value Type Description Object | Improve this Doc View Source IsReady Declaration bool IsReady { get; set; } Property Value Type Description Boolean Methods | Improve this Doc View Source Disconnect() Declaration void Disconnect()"
  },
  "api/Mirror.Discovery.ServerRequest.html": {
    "href": "api/Mirror.Discovery.ServerRequest.html",
    "title": "Class ServerRequest",
    "keywords": "Class ServerRequest Inheritance Object MessageBase ServerRequest Implements IMessageBase Inherited Members MessageBase.Deserialize(NetworkReader) MessageBase.Serialize(NetworkWriter) Namespace : Mirror.Discovery Assembly : doc.dll Syntax public class ServerRequest : MessageBase, IMessageBase Implements IMessageBase"
  },
  "api/Mirror.NetworkTransformChild.html": {
    "href": "api/Mirror.NetworkTransformChild.html",
    "title": "Class NetworkTransformChild",
    "keywords": "Class NetworkTransformChild A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values. Inheritance Object NetworkBehaviour NetworkTransformBase NetworkTransformChild Inherited Members NetworkTransformBase.ClientAuthority NetworkTransformBase.LocalPositionSensitivity NetworkTransformBase.LocalRotationSensitivity NetworkTransformBase.LocalScaleSensitivity NetworkTransformBase.SerializeIntoWriter(NetworkWriter, Vector3, Quaternion, Vector3) NetworkTransformBase.OnSerialize(NetworkWriter, Boolean) NetworkTransformBase.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.Client NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRpc(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.GetDelegate(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkTransformChild : NetworkTransformBase Fields | Improve this Doc View Source Target Declaration public Transform Target Field Value Type Description Transform Properties | Improve this Doc View Source TargetComponent Declaration protected override Transform TargetComponent { get; } Property Value Type Description Transform Overrides NetworkTransformBase.TargetComponent"
  },
  "api/Mirror.UnityEventInt.html": {
    "href": "api/Mirror.UnityEventInt.html",
    "title": "Class UnityEventInt",
    "keywords": "Class UnityEventInt Inheritance Object UnityEventInt Namespace : Mirror Assembly : doc.dll Syntax public class UnityEventInt : UnityEvent<int>"
  },
  "api/Mirror.Discovery.ServerFoundUnityEvent.html": {
    "href": "api/Mirror.Discovery.ServerFoundUnityEvent.html",
    "title": "Class ServerFoundUnityEvent",
    "keywords": "Class ServerFoundUnityEvent Inheritance Object ServerFoundUnityEvent Namespace : Mirror.Discovery Assembly : doc.dll Syntax public class ServerFoundUnityEvent : UnityEvent<ServerResponse>"
  },
  "api/Mirror.IClientObjectManager.html": {
    "href": "api/Mirror.IClientObjectManager.html",
    "title": "Interface IClientObjectManager",
    "keywords": "Interface IClientObjectManager Namespace : Mirror Assembly : doc.dll Syntax public interface IClientObjectManager Methods | Improve this Doc View Source ClearSpawners() Declaration void ClearSpawners() | Improve this Doc View Source DestroyAllClientObjects() Declaration void DestroyAllClientObjects() | Improve this Doc View Source GetPrefab(Guid, out GameObject) Declaration bool GetPrefab(Guid assetId, out GameObject prefab) Parameters Type Name Description Guid assetId GameObject prefab Returns Type Description Boolean | Improve this Doc View Source RegisterPrefab(GameObject) Declaration void RegisterPrefab(GameObject prefab) Parameters Type Name Description GameObject prefab | Improve this Doc View Source RegisterPrefab(GameObject, Guid) Declaration void RegisterPrefab(GameObject prefab, Guid newAssetId) Parameters Type Name Description GameObject prefab Guid newAssetId | Improve this Doc View Source RegisterPrefab(GameObject, SpawnDelegate, UnSpawnDelegate) Declaration void RegisterPrefab(GameObject prefab, SpawnDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description GameObject prefab SpawnDelegate spawnHandler UnSpawnDelegate unspawnHandler | Improve this Doc View Source RegisterPrefab(GameObject, SpawnHandlerDelegate, UnSpawnDelegate) Declaration void RegisterPrefab(GameObject prefab, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description GameObject prefab SpawnHandlerDelegate spawnHandler UnSpawnDelegate unspawnHandler | Improve this Doc View Source RegisterSpawnHandler(Guid, SpawnDelegate, UnSpawnDelegate) Declaration void RegisterSpawnHandler(Guid assetId, SpawnDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description Guid assetId SpawnDelegate spawnHandler UnSpawnDelegate unspawnHandler | Improve this Doc View Source RegisterSpawnHandler(Guid, SpawnHandlerDelegate, UnSpawnDelegate) Declaration void RegisterSpawnHandler(Guid assetId, SpawnHandlerDelegate spawnHandler, UnSpawnDelegate unspawnHandler) Parameters Type Name Description Guid assetId SpawnHandlerDelegate spawnHandler UnSpawnDelegate unspawnHandler | Improve this Doc View Source RemovePlayer() Declaration bool RemovePlayer() Returns Type Description Boolean | Improve this Doc View Source UnregisterPrefab(GameObject) Declaration void UnregisterPrefab(GameObject prefab) Parameters Type Name Description GameObject prefab | Improve this Doc View Source UnregisterSpawnHandler(Guid) Declaration void UnregisterSpawnHandler(Guid assetId) Parameters Type Name Description Guid assetId"
  },
  "api/Mirror.PipeConnection.html": {
    "href": "api/Mirror.PipeConnection.html",
    "title": "Class PipeConnection",
    "keywords": "Class PipeConnection A connection that is directly connected to another connection If you send data in one of them, you receive it on the other one Inheritance Object PipeConnection Implements IConnection Namespace : Mirror Assembly : doc.dll Syntax public class PipeConnection : object, IConnection Methods | Improve this Doc View Source CreatePipe() Declaration public static (IConnection, IConnection)CreatePipe() Returns Type Description ValueTuple < IConnection , IConnection > | Improve this Doc View Source Disconnect() Declaration public void Disconnect() | Improve this Doc View Source GetEndPointAddress() Declaration public EndPoint GetEndPointAddress() Returns Type Description EndPoint | Improve this Doc View Source ReceiveAsync(MemoryStream) Declaration public Task<bool> ReceiveAsync(MemoryStream buffer) Parameters Type Name Description MemoryStream buffer Returns Type Description Task < Boolean > | Improve this Doc View Source SendAsync(ArraySegment<Byte>) Declaration public Task SendAsync(ArraySegment<byte> data) Parameters Type Name Description ArraySegment < Byte > data Returns Type Description Task Implements IConnection"
  },
  "api/Mirror.IServerObjectManager.html": {
    "href": "api/Mirror.IServerObjectManager.html",
    "title": "Interface IServerObjectManager",
    "keywords": "Interface IServerObjectManager Namespace : Mirror Assembly : doc.dll Syntax public interface IServerObjectManager Methods | Improve this Doc View Source AddPlayerForConnection(INetworkConnection, GameObject) Declaration bool AddPlayerForConnection(INetworkConnection conn, GameObject player) Parameters Type Name Description INetworkConnection conn GameObject player Returns Type Description Boolean | Improve this Doc View Source AddPlayerForConnection(INetworkConnection, GameObject, Guid) Declaration bool AddPlayerForConnection(INetworkConnection conn, GameObject player, Guid assetId) Parameters Type Name Description INetworkConnection conn GameObject player Guid assetId Returns Type Description Boolean | Improve this Doc View Source Destroy(GameObject) Declaration void Destroy(GameObject obj) Parameters Type Name Description GameObject obj | Improve this Doc View Source ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Guid, Boolean) Declaration bool ReplacePlayerForConnection(INetworkConnection conn, NetworkClient client, GameObject player, Guid assetId, bool keepAuthority = false) Parameters Type Name Description INetworkConnection conn NetworkClient client GameObject player Guid assetId Boolean keepAuthority Returns Type Description Boolean | Improve this Doc View Source ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Boolean) Declaration bool ReplacePlayerForConnection(INetworkConnection conn, NetworkClient client, GameObject player, bool keepAuthority = false) Parameters Type Name Description INetworkConnection conn NetworkClient client GameObject player Boolean keepAuthority Returns Type Description Boolean | Improve this Doc View Source Spawn(GameObject, GameObject) Declaration void Spawn(GameObject obj, GameObject player) Parameters Type Name Description GameObject obj GameObject player | Improve this Doc View Source Spawn(GameObject, Guid, INetworkConnection) Declaration void Spawn(GameObject obj, Guid assetId, INetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj Guid assetId INetworkConnection ownerConnection | Improve this Doc View Source Spawn(GameObject, INetworkConnection) Declaration void Spawn(GameObject obj, INetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj INetworkConnection ownerConnection | Improve this Doc View Source SpawnObjects() Declaration bool SpawnObjects() Returns Type Description Boolean | Improve this Doc View Source UnSpawn(GameObject) Declaration void UnSpawn(GameObject obj) Parameters Type Name Description GameObject obj"
  },
  "api/Mirror.NetworkVisibility.html": {
    "href": "api/Mirror.NetworkVisibility.html",
    "title": "Class NetworkVisibility",
    "keywords": "Class NetworkVisibility Inheritance Object NetworkBehaviour NetworkVisibility NetworkMatchChecker NetworkProximityChecker NetworkSceneChecker Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.Client NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRpc(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.GetDelegate(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirror Assembly : doc.dll Syntax public abstract class NetworkVisibility : NetworkBehaviour Methods | Improve this Doc View Source OnCheckObserver(INetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public abstract bool OnCheckObserver(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection of a player. Returns Type Description Boolean True if the player can see this object. | Improve this Doc View Source OnRebuildObservers(HashSet<INetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public abstract void OnRebuildObservers(HashSet<INetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < INetworkConnection > observers The new set of observers for this object. Boolean initialize True if the set of observers is being built for the first time. | Improve this Doc View Source OnSetHostVisibility(Boolean) Callback used by the visibility system for objects on a host. Objects on a host (with a local client) cannot be disabled or destroyed when they are not visible to the local client. So this function is called to allow custom code to hide these objects. A typical implementation will disable renderer components on the object. This is only called on local clients on a host. Declaration public virtual void OnSetHostVisibility(bool visible) Parameters Type Name Description Boolean visible New visibility state."
  },
  "api/Mirror.IMessageHandler.html": {
    "href": "api/Mirror.IMessageHandler.html",
    "title": "Interface IMessageHandler",
    "keywords": "Interface IMessageHandler An object that can send and receive messages Namespace : Mirror Assembly : doc.dll Syntax public interface IMessageHandler Methods | Improve this Doc View Source ClearHandlers() Declaration void ClearHandlers() | Improve this Doc View Source ProcessMessagesAsync() Declaration Task ProcessMessagesAsync() Returns Type Description Task | Improve this Doc View Source RegisterHandler<T>(Action<T>) Declaration void RegisterHandler<T>(Action<T> handler) where T : IMessageBase, new() Parameters Type Name Description Action <T> handler Type Parameters Name Description T | Improve this Doc View Source RegisterHandler<T>(Action<INetworkConnection, T>) Declaration void RegisterHandler<T>(Action<INetworkConnection, T> handler) where T : IMessageBase, new() Parameters Type Name Description Action < INetworkConnection , T> handler Type Parameters Name Description T | Improve this Doc View Source Send<T>(T, Int32) Declaration void Send<T>(T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description T msg Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendAsync<T>(T, Int32) Declaration Task SendAsync<T>(T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description T msg Int32 channelId Returns Type Description Task Type Parameters Name Description T | Improve this Doc View Source UnregisterHandler<T>() Declaration void UnregisterHandler<T>() where T : IMessageBase Type Parameters Name Description T"
  },
  "api/Mirror.NetworkConnection.html": {
    "href": "api/Mirror.NetworkConnection.html",
    "title": "Class NetworkConnection",
    "keywords": "Class NetworkConnection A High level network connection. This is used for connections from client-to-server and for connection from server-to-client. Inheritance Object NetworkConnection Implements INetworkConnection IMessageHandler IVisibilityTracker IObjectOwner Namespace : Mirror Assembly : doc.dll Syntax public class NetworkConnection : object, INetworkConnection, IMessageHandler, IVisibilityTracker, IObjectOwner Remarks A NetworkConnection corresponds to a specific connection for a host in the transport layer. It has a connectionId that is assigned by the transport layer and passed to the Initialize function. A NetworkClient has one NetworkConnection. A NetworkServerSimple manages multiple NetworkConnections. The NetworkServer has multiple \"remote\" connections and a \"local\" connection for the local client. The NetworkConnection class provides message sending and handling facilities. For sending data over a network, there are methods to send message objects, byte arrays, and NetworkWriter objects. To handle data arriving from the network, handler functions can be registered for message Ids, byte arrays can be processed by HandleBytes(), and NetworkReader object can be processed by HandleReader(). NetworkConnection objects also act as observers for networked objects. When a connection is an observer of a networked object with a NetworkIdentity, then the object will be visible to corresponding client for the connection, and incremental state changes will be sent to the client. There are many virtual functions on NetworkConnection that allow its behaviour to be customized. NetworkClient and NetworkServer can both be made to instantiate custom classes derived from NetworkConnection by setting their networkConnectionClass member variable. Constructors | Improve this Doc View Source NetworkConnection(IConnection) Creates a new NetworkConnection with the specified address and connectionId Declaration public NetworkConnection(IConnection connection) Parameters Type Name Description IConnection connection Properties | Improve this Doc View Source Address The IP address / URL / FQDN associated with the connection. Can be useful for a game master to do IP Bans etc. Declaration public virtual EndPoint Address { get; } Property Value Type Description EndPoint | Improve this Doc View Source AuthenticationData General purpose object to hold authentication data, character selection, tokens, etc. associated with the connection for reference after Authentication completes. Declaration public object AuthenticationData { get; set; } Property Value Type Description Object | Improve this Doc View Source Identity The NetworkIdentity for this connection. Declaration public NetworkIdentity Identity { get; set; } Property Value Type Description NetworkIdentity | Improve this Doc View Source IsReady Flag that tells if the connection has been marked as \"ready\" by a client calling ClientScene.Ready(). This property is read-only. It is set by the system on the client when ClientScene.Ready() is called, and set by the system on the server when a ready message is received from a client. A client that is ready is sent spawned objects by the server and updates to the state of spawned objects. A client that is not ready is not sent spawned objects. Declaration public bool IsReady { get; set; } Property Value Type Description Boolean Methods | Improve this Doc View Source AddOwnedObject(NetworkIdentity) Declaration public void AddOwnedObject(NetworkIdentity networkIdentity) Parameters Type Name Description NetworkIdentity networkIdentity | Improve this Doc View Source AddToVisList(NetworkIdentity) Declaration public void AddToVisList(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source ClearHandlers() Clear all registered callback handlers. Declaration public void ClearHandlers() | Improve this Doc View Source DestroyOwnedObjects() Declaration public void DestroyOwnedObjects() | Improve this Doc View Source Disconnect() Disconnects this connection. Declaration public virtual void Disconnect() | Improve this Doc View Source ProcessMessagesAsync() Declaration public Task ProcessMessagesAsync() Returns Type Description Task | Improve this Doc View Source RegisterHandler<T>(Action<T>) Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration public void RegisterHandler<T>(Action<T> handler) where T : IMessageBase, new() Parameters Type Name Description Action <T> handler Function handler which will be invoked for when this message type is received. Type Parameters Name Description T Message type | Improve this Doc View Source RegisterHandler<T>(Action<INetworkConnection, T>) Register a handler for a particular message type. There are several system message types which you can add handlers for. You can also add your own message types. Declaration public void RegisterHandler<T>(Action<INetworkConnection, T> handler) where T : IMessageBase, new() Parameters Type Name Description Action < INetworkConnection , T> handler Function handler which will be invoked for when this message type is received. Type Parameters Name Description T Message type | Improve this Doc View Source RemoveFromVisList(NetworkIdentity) Declaration public void RemoveFromVisList(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source RemoveObservers() Declaration public void RemoveObservers() | Improve this Doc View Source RemoveOwnedObject(NetworkIdentity) Declaration public void RemoveOwnedObject(NetworkIdentity networkIdentity) Parameters Type Name Description NetworkIdentity networkIdentity | Improve this Doc View Source Send<T>(T, Int32) This sends a network message to the connection. Declaration public virtual void Send<T>(T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description T msg The message to send Int32 channelId The transport layer channel to send on. Type Parameters Name Description T The message type | Improve this Doc View Source Send<T>(IEnumerable<INetworkConnection>, T, Int32) Declaration public static void Send<T>(IEnumerable<INetworkConnection> connections, T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description IEnumerable < INetworkConnection > connections T msg Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendAsync<T>(T, Int32) This sends a network message to the connection. You can await it to check for errors Declaration public virtual Task SendAsync<T>(T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description T msg The message to send. Int32 channelId The transport layer channel to send on. Returns Type Description Task Type Parameters Name Description T The message type | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description String | Improve this Doc View Source UnregisterHandler<T>() Unregisters a handler for a particular message type. Declaration public void UnregisterHandler<T>() where T : IMessageBase Type Parameters Name Description T Message type Implements INetworkConnection IMessageHandler IVisibilityTracker IObjectOwner"
  },
  "api/Mirror.CommandAttribute.html": {
    "href": "api/Mirror.CommandAttribute.html",
    "title": "Class CommandAttribute",
    "keywords": "Class CommandAttribute Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. Inheritance Object CommandAttribute Namespace : Mirror Assembly : doc.dll Syntax public class CommandAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description Int32"
  },
  "api/Mirror.SyncList-1.html": {
    "href": "api/Mirror.SyncList-1.html",
    "title": "Class SyncList<T>",
    "keywords": "Class SyncList<T> Inheritance Object SyncList<T> SyncListBool SyncListFloat SyncListInt SyncListString SyncListUInt Implements IReadOnlyList <T> ISyncObject Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncList<T> : IList<T>, IReadOnlyList<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncList(IEqualityComparer<T>) Declaration protected SyncList(IEqualityComparer<T> comparer = null) Parameters Type Name Description IEqualityComparer <T> comparer | Improve this Doc View Source SyncList(IList<T>, IEqualityComparer<T>) Declaration protected SyncList(IList<T> objects, IEqualityComparer<T> comparer = null) Parameters Type Name Description IList <T> objects IEqualityComparer <T> comparer Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source Item[Int32] Declaration public T this[int i] { get; set; } Parameters Type Name Description Int32 i Property Value Type Description T Methods | Improve this Doc View Source Add(T) Declaration public void Add(T item) Parameters Type Name Description T item | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(T) Declaration public bool Contains(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source CopyTo(T[], Int32) Declaration public void CopyTo(T[] array, int arrayIndex) Parameters Type Name Description T[] array Int32 arrayIndex | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected virtual T DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description T | Improve this Doc View Source Find(Predicate<T>) Declaration public T Find(Predicate<T> match) Parameters Type Name Description Predicate <T> match Returns Type Description T | Improve this Doc View Source FindAll(Predicate<T>) Declaration public List<T> FindAll(Predicate<T> match) Parameters Type Name Description Predicate <T> match Returns Type Description List <T> | Improve this Doc View Source FindIndex(Predicate<T>) Declaration public int FindIndex(Predicate<T> match) Parameters Type Name Description Predicate <T> match Returns Type Description Int32 | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public SyncList<T>.Enumerator GetEnumerator() Returns Type Description SyncList.Enumerator <> | Improve this Doc View Source IndexOf(T) Declaration public int IndexOf(T item) Parameters Type Name Description T item Returns Type Description Int32 | Improve this Doc View Source Insert(Int32, T) Declaration public void Insert(int index, T item) Parameters Type Name Description Int32 index T item | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Remove(T) Declaration public bool Remove(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source RemoveAt(Int32) Declaration public void RemoveAt(int index) Parameters Type Name Description Int32 index | Improve this Doc View Source Reset() Declaration public void Reset() | Improve this Doc View Source SerializeItem(NetworkWriter, T) Declaration protected virtual void SerializeItem(NetworkWriter writer, T item) Parameters Type Name Description NetworkWriter writer T item Events | Improve this Doc View Source OnChange Raised after the list has been updated Note that if there are multiple changes this event is only raised once. Declaration public event Action OnChange Event Type Type Description Action | Improve this Doc View Source OnClear Raised when the list is cleared Declaration public event Action OnClear Event Type Type Description Action | Improve this Doc View Source OnInsert Raised when an element is added to the list. Receives index and new item Declaration public event Action<int, T> OnInsert Event Type Type Description Action < Int32 , T> | Improve this Doc View Source OnRemove Raised when an item is removed from the list receives the index and the old item Declaration public event Action<int, T> OnRemove Event Type Type Description Action < Int32 , T> | Improve this Doc View Source OnSet Raised when an item is changed in a list Receives index, old item and new item Declaration public event Action<int, T, T> OnSet Event Type Type Description Action < Int32 , T, T> Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.INetworkManager.html": {
    "href": "api/Mirror.INetworkManager.html",
    "title": "Interface INetworkManager",
    "keywords": "Interface INetworkManager Namespace : Mirror Assembly : doc.dll Syntax public interface INetworkManager Methods | Improve this Doc View Source OnDestroy() Declaration void OnDestroy() | Improve this Doc View Source ServerChangeScene(String) Declaration void ServerChangeScene(string newSceneName) Parameters Type Name Description String newSceneName | Improve this Doc View Source StartClient(Uri) Declaration void StartClient(Uri uri) Parameters Type Name Description Uri uri | Improve this Doc View Source StopClient() Declaration void StopClient() | Improve this Doc View Source StopHost() Declaration void StopHost() | Improve this Doc View Source StopServer() Declaration void StopServer()"
  },
  "api/Mirror.SyncListString.html": {
    "href": "api/Mirror.SyncListString.html",
    "title": "Class SyncListString",
    "keywords": "Class SyncListString Inheritance Object SyncList < String > SyncListString Implements IReadOnlyList < String > ISyncObject Inherited Members SyncList<String>.Count SyncList<String>.IsReadOnly SyncList<String>.OnInsert SyncList<String>.OnClear SyncList<String>.OnRemove SyncList<String>.OnSet SyncList<String>.OnChange SyncList<String>.IsDirty SyncList<String>.Flush() SyncList<String>.Reset() SyncList<String>.OnSerializeAll(NetworkWriter) SyncList<String>.OnSerializeDelta(NetworkWriter) SyncList<String>.OnDeserializeAll(NetworkReader) SyncList<String>.OnDeserializeDelta(NetworkReader) SyncList<String>.Add(String) SyncList<String>.Clear() SyncList<String>.Contains(String) SyncList<String>.CopyTo(String[], Int32) SyncList<String>.IndexOf(String) SyncList<String>.FindIndex(Predicate<String>) SyncList<String>.Find(Predicate<String>) SyncList<String>.FindAll(Predicate<String>) SyncList<String>.Insert(Int32, String) SyncList<String>.Remove(String) SyncList<String>.RemoveAt(Int32) SyncList<String>.Item[Int32] SyncList<String>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListString : SyncList<string>, IReadOnlyList<string>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override string DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description String Overrides Mirror.SyncList<System.String>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, String) Declaration protected override void SerializeItem(NetworkWriter writer, string item) Parameters Type Name Description NetworkWriter writer String item Overrides Mirror.SyncList<System.String>.SerializeItem(Mirror.NetworkWriter, System.String) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.Discovery.ServerResponse.html": {
    "href": "api/Mirror.Discovery.ServerResponse.html",
    "title": "Class ServerResponse",
    "keywords": "Class ServerResponse Inheritance Object MessageBase ServerResponse Implements IMessageBase Inherited Members MessageBase.Deserialize(NetworkReader) MessageBase.Serialize(NetworkWriter) Namespace : Mirror.Discovery Assembly : doc.dll Syntax public class ServerResponse : MessageBase, IMessageBase Fields | Improve this Doc View Source serverId Declaration public long serverId Field Value Type Description Int64 | Improve this Doc View Source uri Declaration public Uri uri Field Value Type Description Uri Properties | Improve this Doc View Source EndPoint Declaration public IPEndPoint EndPoint { get; set; } Property Value Type Description IPEndPoint Implements IMessageBase"
  },
  "api/Mirror.NetworkAnimator.html": {
    "href": "api/Mirror.NetworkAnimator.html",
    "title": "Class NetworkAnimator",
    "keywords": "Class NetworkAnimator A component to synchronize Mecanim animation states for networked objects. Inheritance Object NetworkBehaviour NetworkAnimator Inherited Members NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.Client NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRpc(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.GetDelegate(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkAnimator : NetworkBehaviour Remarks The animation of game objects can be networked by this component. There are two models of authority for networked movement: If the object has authority on the client, then it should be animated locally on the owning client. The animation state information will be sent from the owning client to the server, then broadcast to all of the other clients. This is common for player objects. If the object has authority on the server, then it should be animated on the server and state information will be sent to all clients. This is common for objects not related to a specific client, such as an enemy unit. The NetworkAnimator synchronizes all animation parameters of the selected Animator. It does not automatically sychronize triggers. The function SetTrigger can by used by an object with authority to fire an animation trigger on other clients. Fields | Improve this Doc View Source Animator The animator component to synchronize. Declaration public Animator Animator Field Value Type Description Animator | Improve this Doc View Source ClientAuthority Declaration public bool ClientAuthority Field Value Type Description Boolean Methods | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Custom Deserialization Declaration public override void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Boolean initialState Overrides NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Custom Serialization Declaration public override bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Boolean initialState Returns Type Description Boolean Overrides NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) | Improve this Doc View Source ResetTrigger(Int32) Causes an animation trigger to be reset for a networked object. Declaration public void ResetTrigger(int hash) Parameters Type Name Description Int32 hash Hash id of trigger (from the Animator). | Improve this Doc View Source ResetTrigger(String) Causes an animation trigger to be reset for a networked object. If local authority is set, and this is called from the client, then the trigger will be reset on the server and all clients. If not, then this is called on the server, and the trigger will be reset on all clients. Declaration public void ResetTrigger(string triggerName) Parameters Type Name Description String triggerName Name of trigger. | Improve this Doc View Source SetTrigger(Int32) Causes an animation trigger to be invoked for a networked object. Declaration public void SetTrigger(int hash) Parameters Type Name Description Int32 hash Hash id of trigger (from the Animator). | Improve this Doc View Source SetTrigger(String) Causes an animation trigger to be invoked for a networked object. If local authority is set, and this is called from the client, then the trigger will be invoked on the server and all clients. If not, then this is called on the server, and the trigger will be called on all clients. Declaration public void SetTrigger(string triggerName) Parameters Type Name Description String triggerName Name of trigger."
  },
  "api/Mirror.NetworkServer.html": {
    "href": "api/Mirror.NetworkServer.html",
    "title": "Class NetworkServer",
    "keywords": "Class NetworkServer The NetworkServer. Inheritance Object NetworkServer Implements INetworkServer IServerObjectManager Namespace : Mirror Assembly : doc.dll Syntax public class NetworkServer : MonoBehaviour, INetworkServer, IServerObjectManager Remarks NetworkServer handles remote connections from remote clients via a NetworkServerSimple instance, and also has a local connection for a local client. The NetworkManager uses the NetworkServer, but it can be used without the NetworkManager. The set of networked objects that have been spawned is managed by NetworkServer. Objects are spawned with NetworkServer.Spawn() which adds them to this set, and makes them be created on clients. Spawned objects are removed automatically when they are destroyed, or than they can be removed from the spawned set by calling NetworkServer.UnSpawn() - this does not destroy the object. There are a number of internal messages used by NetworkServer, these are setup when NetworkServer.Listen() is called. Fields | Improve this Doc View Source Authenticated Event fires once a new Client has passed Authentication to the Server. Declaration public NetworkServer.NetworkConnectionEvent Authenticated Field Value Type Description NetworkServer.NetworkConnectionEvent | Improve this Doc View Source authenticator Declaration public NetworkAuthenticator authenticator Field Value Type Description NetworkAuthenticator | Improve this Doc View Source Connected Event fires once a new Client has connect to the Server. Declaration public NetworkServer.NetworkConnectionEvent Connected Field Value Type Description NetworkServer.NetworkConnectionEvent | Improve this Doc View Source connections A list of local connections on the server. Declaration public readonly HashSet<INetworkConnection> connections Field Value Type Description HashSet < INetworkConnection > | Improve this Doc View Source Disconnected Event fires once a Client has Disconnected from the Server. Declaration public NetworkServer.NetworkConnectionEvent Disconnected Field Value Type Description NetworkServer.NetworkConnectionEvent | Improve this Doc View Source Listening If you enable this, the server will not listen for incoming connections on the regular network port. This can be used if the game is running in host mode and does not want external players to be able to connect - making it like a single-player game. Also this can be useful when using AddExternalConnection(). Declaration public bool Listening Field Value Type Description Boolean | Improve this Doc View Source MaxConnections The maximum number of concurrent network connections to support. This effects the memory usage of the network layer. Declaration public int MaxConnections Field Value Type Description Int32 | Improve this Doc View Source ServerChangeScene Event fires before Server changes scene. Declaration public NetworkServer.NetworkSceneEvent ServerChangeScene Field Value Type Description NetworkServer.NetworkSceneEvent | Improve this Doc View Source ServerSceneChanged Event fires after Server has completed scene change. Declaration public NetworkServer.NetworkSceneEvent ServerSceneChanged Field Value Type Description NetworkServer.NetworkSceneEvent | Improve this Doc View Source spawned Declaration public readonly Dictionary<uint, NetworkIdentity> spawned Field Value Type Description Dictionary < UInt32 , NetworkIdentity > | Improve this Doc View Source Started This is invoked when a server is started - including when a host is started. Declaration public UnityEvent Started Field Value Type Description UnityEvent | Improve this Doc View Source Stopped Declaration public UnityEvent Stopped Field Value Type Description UnityEvent | Improve this Doc View Source Time Declaration public readonly NetworkTime Time Field Value Type Description NetworkTime | Improve this Doc View Source transport Declaration public AsyncTransport transport Field Value Type Description AsyncTransport Properties | Improve this Doc View Source Active Checks if the server has been started. This will be true after NetworkServer.Listen() has been called. Declaration public bool Active { get; } Property Value Type Description Boolean | Improve this Doc View Source LocalClient Declaration public NetworkClient LocalClient { get; } Property Value Type Description NetworkClient | Improve this Doc View Source LocalClientActive True if there is a local client connected to this server (host mode) Declaration public bool LocalClientActive { get; } Property Value Type Description Boolean | Improve this Doc View Source LocalConnection The connection to the host mode client (if any). Declaration public INetworkConnection LocalConnection { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source NumPlayers Number of active player objects across all connections on the server. This is only valid on the host / server. Declaration public int NumPlayers { get; } Property Value Type Description Int32 Methods | Improve this Doc View Source AddConnection(INetworkConnection) This accepts a network connection and adds it to the server. This connection will use the callbacks registered with the server. Declaration public void AddConnection(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection to add. | Improve this Doc View Source AddPlayerForConnection(INetworkConnection, GameObject) When an AddPlayer message handler has received a request from a player, the server calls this to associate the player object with the connection. When a player is added for a connection, the client for that connection is made ready automatically. The player object is automatically spawned, so you do not need to call NetworkServer.Spawn for that object. This function is used for \"adding\" a player, not for \"replacing\" the player on a connection. If there is already a player on this playerControllerId for this connection, this will fail. Declaration public bool AddPlayerForConnection(INetworkConnection conn, GameObject player) Parameters Type Name Description INetworkConnection conn Connection which is adding the player. GameObject player Player object spawned for the player. Returns Type Description Boolean | Improve this Doc View Source AddPlayerForConnection(INetworkConnection, GameObject, Guid) When an AddPlayer message handler has received a request from a player, the server calls this to associate the player object with the connection. When a player is added for a connection, the client for that connection is made ready automatically. The player object is automatically spawned, so you do not need to call NetworkServer.Spawn for that object. This function is used for \"adding\" a player, not for \"replacing\" the player on a connection. If there is already a player on this playerControllerId for this connection, this will fail. Declaration public bool AddPlayerForConnection(INetworkConnection conn, GameObject player, Guid assetId) Parameters Type Name Description INetworkConnection conn Connection which is adding the player. GameObject player Player object spawned for the player. Guid assetId Returns Type Description Boolean | Improve this Doc View Source Destroy(GameObject) Destroys this object and corresponding objects on all clients. In some cases it is useful to remove an object but not delete it on the server. For that, use NetworkServer.UnSpawn() instead of NetworkServer.Destroy(). Declaration public void Destroy(GameObject obj) Parameters Type Name Description GameObject obj Game object to destroy. | Improve this Doc View Source Disconnect() This shuts down the server and disconnects all clients. Declaration public void Disconnect() | Improve this Doc View Source ListenAsync() Start the server, setting the maximum number of connections. Declaration public Task ListenAsync() Returns Type Description Task | Improve this Doc View Source RemoveConnection(INetworkConnection) This removes an external connection added with AddExternalConnection(). Declaration public void RemoveConnection(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn | Improve this Doc View Source ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Guid, Boolean) This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration public bool ReplacePlayerForConnection(INetworkConnection conn, NetworkClient client, GameObject player, Guid assetId, bool keepAuthority = false) Parameters Type Name Description INetworkConnection conn Connection which is adding the player. NetworkClient client Client associated to the player. GameObject player Player object spawned for the player. Guid assetId Boolean keepAuthority Does the previous player remain attached to this connection? Returns Type Description Boolean | Improve this Doc View Source ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Boolean) This replaces the player object for a connection with a different player object. The old player object is not destroyed. If a connection already has a player object, this can be used to replace that object with a different player object. This does NOT change the ready state of the connection, so it can safely be used while changing scenes. Declaration public bool ReplacePlayerForConnection(INetworkConnection conn, NetworkClient client, GameObject player, bool keepAuthority = false) Parameters Type Name Description INetworkConnection conn Connection which is adding the player. NetworkClient client Client associated to the player. GameObject player Player object spawned for the player. Boolean keepAuthority Does the previous player remain attached to this connection? Returns Type Description Boolean | Improve this Doc View Source SendToAll<T>(T, Int32) Send a message to all connected clients, both ready and not-ready. See IsReady Declaration public void SendToAll<T>(T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description T msg Message Int32 channelId Transport channel to use Type Parameters Name Description T Message type | Improve this Doc View Source SendToClientOfPlayer<T>(NetworkIdentity, T, Int32) send this message to the player only Declaration public void SendToClientOfPlayer<T>(NetworkIdentity identity, T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity T msg Int32 channelId Type Parameters Name Description T Message type | Improve this Doc View Source SendToReady<T>(NetworkIdentity, T, Boolean, Int32) Send a message to only clients which are ready with option to include the owner of the object identity. See IsReady Declaration public void SendToReady<T>(NetworkIdentity identity, T msg, bool includeOwner = true, int channelId = null) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity Identity of the owner T msg Message Boolean includeOwner Should the owner of the object be included Int32 channelId Transport channel to use Type Parameters Name Description T Message type. | Improve this Doc View Source SendToReady<T>(NetworkIdentity, T, Int32) Send a message to only clients which are ready including the owner of the object identity. See IsReady Declaration public void SendToReady<T>(NetworkIdentity identity, T msg, int channelId) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity identity of the object T msg Message Int32 channelId Transport channel to use Type Parameters Name Description T Message type | Improve this Doc View Source SetAllClientsNotReady() Marks all connected clients as no longer ready. All clients will no longer be sent state synchronization updates. The player's clients can call ClientManager.Ready() again to re-enter the ready state. This is useful when switching scenes. Declaration public void SetAllClientsNotReady() | Improve this Doc View Source SetClientNotReady(INetworkConnection) Sets the client of the connection to be not-ready. Clients that are not ready do not receive spawned objects or state synchronization updates. They client can be made ready again by calling SetClientReady(). Declaration public void SetClientNotReady(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn The connection of the client to make not ready. | Improve this Doc View Source SetClientReady(INetworkConnection) Sets the client to be ready. When a client has signaled that it is ready, this method tells the server that the client is ready to receive spawned objects and state synchronization updates. This is usually called in a handler for the SYSTEM_READY message. If there is not specific action a game needs to take for this message, relying on the default ready handler function is probably fine, so this call wont be needed. Declaration public void SetClientReady(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn The connection of the client to make ready. | Improve this Doc View Source Spawn(GameObject, GameObject) This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client. This is the same as calling NetworkIdentity.AssignClientAuthority on the spawned object. Declaration public void Spawn(GameObject obj, GameObject player) Parameters Type Name Description GameObject obj The object to spawn. GameObject player The player object to set Client Authority to. | Improve this Doc View Source Spawn(GameObject, Guid, INetworkConnection) This spawns an object like NetworkServer.Spawn() but also assigns Client Authority to the specified client. This is the same as calling NetworkIdentity.AssignClientAuthority on the spawned object. Declaration public void Spawn(GameObject obj, Guid assetId, INetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj The object to spawn. Guid assetId The assetId of the object to spawn. Used for custom spawn handlers. INetworkConnection ownerConnection The connection that has authority over the object | Improve this Doc View Source Spawn(GameObject, INetworkConnection) Spawn the given game object on all clients which are ready. This will cause a new object to be instantiated from the registered prefab, or from a custom spawn function. Declaration public void Spawn(GameObject obj, INetworkConnection ownerConnection = null) Parameters Type Name Description GameObject obj Game object with NetworkIdentity to spawn. INetworkConnection ownerConnection The connection that has authority over the object | Improve this Doc View Source SpawnObjects() This causes NetworkIdentity objects in a scene to be spawned on a server. NetworkIdentity objects in a scene are disabled by default. Calling SpawnObjects() causes these scene objects to be enabled and spawned. It is like calling NetworkServer.Spawn() for each of them. Declaration public bool SpawnObjects() Returns Type Description Boolean Success if objects where spawned. | Improve this Doc View Source UnSpawn(GameObject) This takes an object that has been spawned and un-spawns it. The object will be removed from clients that it was spawned on, or the custom spawn handler function on the client will be called for the object. Unlike when calling NetworkServer.Destroy(), on the server the object will NOT be destroyed. This allows the server to re-use the object, even spawn it again later. Declaration public void UnSpawn(GameObject obj) Parameters Type Name Description GameObject obj The spawned object to be unspawned. Implements INetworkServer IServerObjectManager"
  },
  "api/Mirror.NetworkClient.ClientSceneChangeEvent.html": {
    "href": "api/Mirror.NetworkClient.ClientSceneChangeEvent.html",
    "title": "Class NetworkClient.ClientSceneChangeEvent",
    "keywords": "Class NetworkClient.ClientSceneChangeEvent Inheritance Object NetworkClient.ClientSceneChangeEvent Namespace : Mirror Assembly : doc.dll Syntax public class ClientSceneChangeEvent : UnityEvent<string, SceneOperation, bool>"
  },
  "api/Mirror.PlayerSpawner.PlayerSpawnMethod.html": {
    "href": "api/Mirror.PlayerSpawner.PlayerSpawnMethod.html",
    "title": "Enum PlayerSpawner.PlayerSpawnMethod",
    "keywords": "Enum PlayerSpawner.PlayerSpawnMethod Enumeration of methods of where to spawn player objects in multiplayer games. Namespace : Mirror Assembly : doc.dll Syntax public enum PlayerSpawnMethod : int Fields Name Description Random RoundRobin"
  },
  "api/Mirror.SyncVarAttribute.html": {
    "href": "api/Mirror.SyncVarAttribute.html",
    "title": "Class SyncVarAttribute",
    "keywords": "Class SyncVarAttribute SyncVars are used to synchronize a variable from the server to all clients automatically. Value must be changed on server, not directly by clients. Hook parameter allows you to define a client-side method to be invoked when the client gets an update from the server. Inheritance Object SyncVarAttribute Namespace : Mirror Assembly : doc.dll Syntax public class SyncVarAttribute : PropertyAttribute Fields | Improve this Doc View Source hook A function that should be called on the client when the value changes. Declaration public string hook Field Value Type Description String"
  },
  "api/Mirror.ObjectSpawnStartedMessage.html": {
    "href": "api/Mirror.ObjectSpawnStartedMessage.html",
    "title": "Struct ObjectSpawnStartedMessage",
    "keywords": "Struct ObjectSpawnStartedMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ObjectSpawnStartedMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.ILoggerExtensions.html": {
    "href": "api/Mirror.ILoggerExtensions.html",
    "title": "Class ILoggerExtensions",
    "keywords": "Class ILoggerExtensions Inheritance Object ILoggerExtensions Namespace : Mirror Assembly : doc.dll Syntax public static class ILoggerExtensions : object Methods | Improve this Doc View Source LogEnabled(ILogger) Declaration public static bool LogEnabled(this ILogger logger) Parameters Type Name Description ILogger logger Returns Type Description Boolean | Improve this Doc View Source LogError(ILogger, Object) Declaration public static void LogError(this ILogger logger, object message) Parameters Type Name Description ILogger logger Object message | Improve this Doc View Source LogWarning(ILogger, Object) Declaration public static void LogWarning(this ILogger logger, object message) Parameters Type Name Description ILogger logger Object message"
  },
  "api/Mirror.ReadyMessage.html": {
    "href": "api/Mirror.ReadyMessage.html",
    "title": "Struct ReadyMessage",
    "keywords": "Struct ReadyMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ReadyMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.InvalidMessageException.html": {
    "href": "api/Mirror.InvalidMessageException.html",
    "title": "Class InvalidMessageException",
    "keywords": "Class InvalidMessageException Inheritance Object InvalidMessageException Namespace : Mirror Assembly : doc.dll Syntax public class InvalidMessageException : Exception Constructors | Improve this Doc View Source InvalidMessageException() Declaration public InvalidMessageException() | Improve this Doc View Source InvalidMessageException(SerializationInfo, StreamingContext) Declaration protected InvalidMessageException(SerializationInfo info, StreamingContext context) Parameters Type Name Description SerializationInfo info StreamingContext context | Improve this Doc View Source InvalidMessageException(String) Declaration public InvalidMessageException(string message) Parameters Type Name Description String message | Improve this Doc View Source InvalidMessageException(String, Exception) Declaration public InvalidMessageException(string message, Exception innerException) Parameters Type Name Description String message Exception innerException"
  },
  "api/Mirror.LogFactory.html": {
    "href": "api/Mirror.LogFactory.html",
    "title": "Class LogFactory",
    "keywords": "Class LogFactory Inheritance Object LogFactory Namespace : Mirror Assembly : doc.dll Syntax public static class LogFactory : object Methods | Improve this Doc View Source GetLogger(String, LogType) Declaration public static ILogger GetLogger(string loggerName, LogType defaultLogLevel = null) Parameters Type Name Description String loggerName LogType defaultLogLevel Returns Type Description ILogger | Improve this Doc View Source GetLogger(System.Type, LogType) Declaration public static ILogger GetLogger(System.Type type, LogType defaultLogLevel = null) Parameters Type Name Description System.Type type LogType defaultLogLevel Returns Type Description ILogger | Improve this Doc View Source GetLogger<T>(LogType) Declaration public static ILogger GetLogger<T>(LogType defaultLogLevel = null) Parameters Type Name Description LogType defaultLogLevel Returns Type Description ILogger Type Parameters Name Description T"
  },
  "api/Mirror.Websocket.AsyncWsTransport.html": {
    "href": "api/Mirror.Websocket.AsyncWsTransport.html",
    "title": "Class AsyncWsTransport",
    "keywords": "Class AsyncWsTransport Inheritance Object AsyncTransport AsyncWsTransport Namespace : Mirror.Websocket Assembly : doc.dll Syntax public class AsyncWsTransport : AsyncTransport Fields | Improve this Doc View Source Port Declaration public int Port Field Value Type Description Int32 Properties | Improve this Doc View Source Scheme Declaration public override string Scheme { get; } Property Value Type Description String Overrides AsyncTransport.Scheme Methods | Improve this Doc View Source AcceptAsync() Declaration public override Task<IConnection> AcceptAsync() Returns Type Description Task < IConnection > Overrides AsyncTransport.AcceptAsync() | Improve this Doc View Source ConnectAsync(Uri) Declaration public override Task<IConnection> ConnectAsync(Uri uri) Parameters Type Name Description Uri uri Returns Type Description Task < IConnection > Overrides AsyncTransport.ConnectAsync(Uri) | Improve this Doc View Source Disconnect() Declaration public override void Disconnect() Overrides AsyncTransport.Disconnect() | Improve this Doc View Source ListenAsync() Declaration public override Task ListenAsync() Returns Type Description Task Overrides AsyncTransport.ListenAsync() | Improve this Doc View Source ServerUri() Declaration public override Uri ServerUri() Returns Type Description Uri Overrides AsyncTransport.ServerUri()"
  },
  "api/Mirror.SyncListBool.html": {
    "href": "api/Mirror.SyncListBool.html",
    "title": "Class SyncListBool",
    "keywords": "Class SyncListBool Inheritance Object SyncList < Boolean > SyncListBool Implements IReadOnlyList < Boolean > ISyncObject Inherited Members SyncList<Boolean>.Count SyncList<Boolean>.IsReadOnly SyncList<Boolean>.OnInsert SyncList<Boolean>.OnClear SyncList<Boolean>.OnRemove SyncList<Boolean>.OnSet SyncList<Boolean>.OnChange SyncList<Boolean>.IsDirty SyncList<Boolean>.Flush() SyncList<Boolean>.Reset() SyncList<Boolean>.OnSerializeAll(NetworkWriter) SyncList<Boolean>.OnSerializeDelta(NetworkWriter) SyncList<Boolean>.OnDeserializeAll(NetworkReader) SyncList<Boolean>.OnDeserializeDelta(NetworkReader) SyncList<Boolean>.Add(Boolean) SyncList<Boolean>.Clear() SyncList<Boolean>.Contains(Boolean) SyncList<Boolean>.CopyTo(Boolean[], Int32) SyncList<Boolean>.IndexOf(Boolean) SyncList<Boolean>.FindIndex(Predicate<Boolean>) SyncList<Boolean>.Find(Predicate<Boolean>) SyncList<Boolean>.FindAll(Predicate<Boolean>) SyncList<Boolean>.Insert(Int32, Boolean) SyncList<Boolean>.Remove(Boolean) SyncList<Boolean>.RemoveAt(Int32) SyncList<Boolean>.Item[Int32] SyncList<Boolean>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListBool : SyncList<bool>, IReadOnlyList<bool>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override bool DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Boolean Overrides Mirror.SyncList<System.Boolean>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, Boolean) Declaration protected override void SerializeItem(NetworkWriter writer, bool item) Parameters Type Name Description NetworkWriter writer Boolean item Overrides Mirror.SyncList<System.Boolean>.SerializeItem(Mirror.NetworkWriter, System.Boolean) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.SyncSet-1.html": {
    "href": "api/Mirror.SyncSet-1.html",
    "title": "Class SyncSet<T>",
    "keywords": "Class SyncSet<T> Inheritance Object SyncSet<T> SyncHashSet<T> SyncSortedSet<T> Implements ISyncObject Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncSet<T> : ISet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncSet(ISet<T>) Declaration protected SyncSet(ISet<T> objects) Parameters Type Name Description ISet <T> objects Fields | Improve this Doc View Source objects Declaration protected readonly ISet<T> objects Field Value Type Description ISet <T> Properties | Improve this Doc View Source Count Declaration public int Count { get; } Property Value Type Description Int32 | Improve this Doc View Source IsDirty Declaration public bool IsDirty { get; } Property Value Type Description Boolean | Improve this Doc View Source IsReadOnly Declaration public bool IsReadOnly { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source Add(T) Declaration public bool Add(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source Clear() Declaration public void Clear() | Improve this Doc View Source Contains(T) Declaration public bool Contains(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source CopyTo(T[], Int32) Declaration public void CopyTo(T[] array, int arrayIndex) Parameters Type Name Description T[] array Int32 arrayIndex | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected virtual T DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description T | Improve this Doc View Source ExceptWith(IEnumerable<T>) Declaration public void ExceptWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source Flush() Declaration public void Flush() | Improve this Doc View Source GetEnumerator() Declaration public IEnumerator<T> GetEnumerator() Returns Type Description IEnumerator <T> | Improve this Doc View Source IntersectWith(IEnumerable<T>) Declaration public void IntersectWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source IsProperSubsetOf(IEnumerable<T>) Declaration public bool IsProperSubsetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source IsProperSupersetOf(IEnumerable<T>) Declaration public bool IsProperSupersetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source IsSubsetOf(IEnumerable<T>) Declaration public bool IsSubsetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source IsSupersetOf(IEnumerable<T>) Declaration public bool IsSupersetOf(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration public void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration public void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration public void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration public void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Overlaps(IEnumerable<T>) Declaration public bool Overlaps(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source Remove(T) Declaration public bool Remove(T item) Parameters Type Name Description T item Returns Type Description Boolean | Improve this Doc View Source Reset() Declaration public void Reset() | Improve this Doc View Source SerializeItem(NetworkWriter, T) Declaration protected virtual void SerializeItem(NetworkWriter writer, T item) Parameters Type Name Description NetworkWriter writer T item | Improve this Doc View Source SetEquals(IEnumerable<T>) Declaration public bool SetEquals(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Returns Type Description Boolean | Improve this Doc View Source SymmetricExceptWith(IEnumerable<T>) Declaration public void SymmetricExceptWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other | Improve this Doc View Source UnionWith(IEnumerable<T>) Declaration public void UnionWith(IEnumerable<T> other) Parameters Type Name Description IEnumerable <T> other Events | Improve this Doc View Source OnAdd Raised when an element is added to the list. Receives the new item Declaration public event Action<T> OnAdd Event Type Type Description Action <T> | Improve this Doc View Source OnChange Raised after the set has been updated Note that if there are multiple changes this event is only raised once. Declaration public event Action OnChange Event Type Type Description Action | Improve this Doc View Source OnClear Raised when the set is cleared Declaration public event Action OnClear Event Type Type Description Action | Improve this Doc View Source OnRemove Raised when an item is removed from the set receives the old item Declaration public event Action<T> OnRemove Event Type Type Description Action <T> Implements ISyncObject"
  },
  "api/Mirror.AsyncTcp.html": {
    "href": "api/Mirror.AsyncTcp.html",
    "title": "Namespace Mirror.AsyncTcp",
    "keywords": "Namespace Mirror.AsyncTcp Classes AsyncTcpTransport"
  },
  "api/Mirror.NetworkReaderPool.html": {
    "href": "api/Mirror.NetworkReaderPool.html",
    "title": "Class NetworkReaderPool",
    "keywords": "Class NetworkReaderPool Pool of NetworkReaders Use this pool instead of NetworkReader to reduce memory allocation Use Capacity to change size of pool Inheritance Object NetworkReaderPool Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkReaderPool : object Properties | Improve this Doc View Source Capacity Size of the pool If pool is too small getting readers will causes memory allocation Default value: 100 Declaration public static int Capacity { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source GetReader(ArraySegment<Byte>) Get the next reader in the pool If pool is empty, creates a new Reader Declaration public static PooledNetworkReader GetReader(ArraySegment<byte> segment) Parameters Type Name Description ArraySegment < Byte > segment Returns Type Description PooledNetworkReader | Improve this Doc View Source GetReader(Byte[]) Get the next reader in the pool If pool is empty, creates a new Reader Declaration public static PooledNetworkReader GetReader(byte[] bytes) Parameters Type Name Description Byte [] bytes Returns Type Description PooledNetworkReader | Improve this Doc View Source Recycle(PooledNetworkReader) Puts reader back into pool When pool is full, the extra reader is left for the GC Declaration public static void Recycle(PooledNetworkReader reader) Parameters Type Name Description PooledNetworkReader reader"
  },
  "api/Mirror.IVisibilityTracker.html": {
    "href": "api/Mirror.IVisibilityTracker.html",
    "title": "Interface IVisibilityTracker",
    "keywords": "Interface IVisibilityTracker An object that can observe NetworkIdentities. this is useful for interest management Namespace : Mirror Assembly : doc.dll Syntax public interface IVisibilityTracker Methods | Improve this Doc View Source AddToVisList(NetworkIdentity) Declaration void AddToVisList(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source RemoveFromVisList(NetworkIdentity) Declaration void RemoveFromVisList(NetworkIdentity identity) Parameters Type Name Description NetworkIdentity identity | Improve this Doc View Source RemoveObservers() Declaration void RemoveObservers()"
  },
  "api/Mirror.ObjectSpawnFinishedMessage.html": {
    "href": "api/Mirror.ObjectSpawnFinishedMessage.html",
    "title": "Struct ObjectSpawnFinishedMessage",
    "keywords": "Struct ObjectSpawnFinishedMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct ObjectSpawnFinishedMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.PooledNetworkWriter.html": {
    "href": "api/Mirror.PooledNetworkWriter.html",
    "title": "Class PooledNetworkWriter",
    "keywords": "Class PooledNetworkWriter NetworkWriter to be used with NetworkWriterPool Inheritance Object NetworkWriter PooledNetworkWriter Implements IDisposable Inherited Members NetworkWriter.MaxStringLength NetworkWriter.Length NetworkWriter.Position NetworkWriter.Reset() NetworkWriter.SetLength(Int32) NetworkWriter.ToArray() NetworkWriter.ToArraySegment() NetworkWriter.WriteByte(Byte) NetworkWriter.WriteBytes(Byte[], Int32, Int32) NetworkWriter.WriteUInt32(UInt32) NetworkWriter.WriteInt32(Int32) NetworkWriter.WriteUInt64(UInt64) NetworkWriter.WriteInt64(Int64) Namespace : Mirror Assembly : doc.dll Syntax public class PooledNetworkWriter : NetworkWriter, IDisposable Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() Implements IDisposable Extension Methods NetworkWriterExtensions.WriteByte(NetworkWriter, Byte) NetworkWriterExtensions.WriteSByte(NetworkWriter, SByte) NetworkWriterExtensions.WriteChar(NetworkWriter, Char) NetworkWriterExtensions.WriteBoolean(NetworkWriter, Boolean) NetworkWriterExtensions.WriteUInt16(NetworkWriter, UInt16) NetworkWriterExtensions.WriteInt16(NetworkWriter, Int16) NetworkWriterExtensions.WriteSingle(NetworkWriter, Single) NetworkWriterExtensions.WriteDouble(NetworkWriter, Double) NetworkWriterExtensions.WriteDecimal(NetworkWriter, Decimal) NetworkWriterExtensions.WriteString(NetworkWriter, String) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[]) NetworkWriterExtensions.WriteBytesAndSizeSegment(NetworkWriter, ArraySegment<Byte>) NetworkWriterExtensions.WritePackedInt32(NetworkWriter, Int32) NetworkWriterExtensions.WritePackedUInt32(NetworkWriter, UInt32) NetworkWriterExtensions.WritePackedInt64(NetworkWriter, Int64) NetworkWriterExtensions.WritePackedUInt64(NetworkWriter, UInt64) NetworkWriterExtensions.WriteVector2(NetworkWriter, Vector2) NetworkWriterExtensions.WriteVector3(NetworkWriter, Vector3) NetworkWriterExtensions.WriteVector4(NetworkWriter, Vector4) NetworkWriterExtensions.WriteVector2Int(NetworkWriter, Vector2Int) NetworkWriterExtensions.WriteVector3Int(NetworkWriter, Vector3Int) NetworkWriterExtensions.WriteColor(NetworkWriter, Color) NetworkWriterExtensions.WriteColor32(NetworkWriter, Color32) NetworkWriterExtensions.WriteQuaternion(NetworkWriter, Quaternion) NetworkWriterExtensions.WriteRect(NetworkWriter, Rect) NetworkWriterExtensions.WritePlane(NetworkWriter, Plane) NetworkWriterExtensions.WriteRay(NetworkWriter, Ray) NetworkWriterExtensions.WriteMatrix4x4(NetworkWriter, Matrix4x4) NetworkWriterExtensions.WriteGuid(NetworkWriter, Guid) NetworkWriterExtensions.WriteNetworkIdentity(NetworkWriter, NetworkIdentity) NetworkWriterExtensions.WriteTransform(NetworkWriter, Transform) NetworkWriterExtensions.WriteGameObject(NetworkWriter, GameObject) NetworkWriterExtensions.WriteUri(NetworkWriter, Uri) NetworkWriterExtensions.WriteMessage<T>(NetworkWriter, T)"
  },
  "api/Mirror.AsyncQueue-1.html": {
    "href": "api/Mirror.AsyncQueue-1.html",
    "title": "Class AsyncQueue<T>",
    "keywords": "Class AsyncQueue<T> Inheritance Object AsyncQueue<T> Namespace : Mirror Assembly : doc.dll Syntax public class AsyncQueue<T> : object Type Parameters Name Description T"
  },
  "api/Mirror.SceneAttribute.html": {
    "href": "api/Mirror.SceneAttribute.html",
    "title": "Class SceneAttribute",
    "keywords": "Class SceneAttribute Converts a string property into a Scene property in the inspector Inheritance Object SceneAttribute Namespace : Mirror Assembly : doc.dll Syntax public class SceneAttribute : PropertyAttribute"
  },
  "api/Mirror.NetworkReaderExtensions.html": {
    "href": "api/Mirror.NetworkReaderExtensions.html",
    "title": "Class NetworkReaderExtensions",
    "keywords": "Class NetworkReaderExtensions Inheritance Object NetworkReaderExtensions Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkReaderExtensions : object Methods | Improve this Doc View Source ReadBoolean(NetworkReader) Declaration public static bool ReadBoolean(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Boolean | Improve this Doc View Source ReadByte(NetworkReader) Declaration public static byte ReadByte(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Byte | Improve this Doc View Source ReadBytes(NetworkReader, Int32) Declaration public static byte[] ReadBytes(this NetworkReader reader, int count) Parameters Type Name Description NetworkReader reader Int32 count Returns Type Description Byte [] | Improve this Doc View Source ReadBytesAndSize(NetworkReader) Declaration public static byte[] ReadBytesAndSize(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Byte [] | Improve this Doc View Source ReadBytesAndSizeSegment(NetworkReader) Declaration public static ArraySegment<byte> ReadBytesAndSizeSegment(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description ArraySegment < Byte > | Improve this Doc View Source ReadChar(NetworkReader) Declaration public static char ReadChar(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Char | Improve this Doc View Source ReadColor(NetworkReader) Declaration public static Color ReadColor(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Color | Improve this Doc View Source ReadColor32(NetworkReader) Declaration public static Color32 ReadColor32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Color32 | Improve this Doc View Source ReadDecimal(NetworkReader) Declaration public static decimal ReadDecimal(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Decimal | Improve this Doc View Source ReadDouble(NetworkReader) Declaration public static double ReadDouble(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Double | Improve this Doc View Source ReadGameObject(NetworkReader) Declaration public static GameObject ReadGameObject(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description GameObject | Improve this Doc View Source ReadGuid(NetworkReader) Declaration public static Guid ReadGuid(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Guid | Improve this Doc View Source ReadInt16(NetworkReader) Declaration public static short ReadInt16(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int16 | Improve this Doc View Source ReadInt32(NetworkReader) Declaration public static int ReadInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int32 | Improve this Doc View Source ReadInt64(NetworkReader) Declaration public static long ReadInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int64 | Improve this Doc View Source ReadMatrix4x4(NetworkReader) Declaration public static Matrix4x4 ReadMatrix4x4(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Matrix4x4 | Improve this Doc View Source ReadMessage<T>(NetworkReader, T) Declaration public static void ReadMessage<T>(this NetworkReader reader, T msg) where T : IMessageBase Parameters Type Name Description NetworkReader reader T msg Type Parameters Name Description T | Improve this Doc View Source ReadNetworkIdentity(NetworkReader) Declaration public static NetworkIdentity ReadNetworkIdentity(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description NetworkIdentity | Improve this Doc View Source ReadPackedInt32(NetworkReader) Declaration public static int ReadPackedInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int32 | Improve this Doc View Source ReadPackedInt64(NetworkReader) Declaration public static long ReadPackedInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int64 | Improve this Doc View Source ReadPackedUInt32(NetworkReader) Declaration public static uint ReadPackedUInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt32 | Improve this Doc View Source ReadPackedUInt64(NetworkReader) Declaration public static ulong ReadPackedUInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt64 | Improve this Doc View Source ReadPlane(NetworkReader) Declaration public static Plane ReadPlane(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Plane | Improve this Doc View Source ReadQuaternion(NetworkReader) Declaration public static Quaternion ReadQuaternion(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Quaternion | Improve this Doc View Source ReadRay(NetworkReader) Declaration public static Ray ReadRay(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Ray | Improve this Doc View Source ReadRect(NetworkReader) Declaration public static Rect ReadRect(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Rect | Improve this Doc View Source ReadSByte(NetworkReader) Declaration public static sbyte ReadSByte(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description SByte | Improve this Doc View Source ReadSingle(NetworkReader) Declaration public static float ReadSingle(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Single | Improve this Doc View Source ReadString(NetworkReader) Declaration public static string ReadString(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description String | Improve this Doc View Source ReadTransform(NetworkReader) Declaration public static Transform ReadTransform(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Transform | Improve this Doc View Source ReadUInt16(NetworkReader) Declaration public static ushort ReadUInt16(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt16 | Improve this Doc View Source ReadUInt32(NetworkReader) Declaration public static uint ReadUInt32(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt32 | Improve this Doc View Source ReadUInt64(NetworkReader) Declaration public static ulong ReadUInt64(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description UInt64 | Improve this Doc View Source ReadUri(NetworkReader) Declaration public static Uri ReadUri(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Uri | Improve this Doc View Source ReadVector2(NetworkReader) Declaration public static Vector2 ReadVector2(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector2 | Improve this Doc View Source ReadVector2Int(NetworkReader) Declaration public static Vector2Int ReadVector2Int(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector2Int | Improve this Doc View Source ReadVector3(NetworkReader) Declaration public static Vector3 ReadVector3(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector3 | Improve this Doc View Source ReadVector3Int(NetworkReader) Declaration public static Vector3Int ReadVector3Int(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector3Int | Improve this Doc View Source ReadVector4(NetworkReader) Declaration public static Vector4 ReadVector4(this NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Vector4"
  },
  "api/Mirror.IClientSceneManager.html": {
    "href": "api/Mirror.IClientSceneManager.html",
    "title": "Interface IClientSceneManager",
    "keywords": "Interface IClientSceneManager Namespace : Mirror Assembly : doc.dll Syntax public interface IClientSceneManager Methods | Improve this Doc View Source PrepareToSpawnSceneObjects() Declaration void PrepareToSpawnSceneObjects()"
  },
  "api/Mirror.SpawnDelegate.html": {
    "href": "api/Mirror.SpawnDelegate.html",
    "title": "Delegate SpawnDelegate",
    "keywords": "Delegate SpawnDelegate Namespace : Mirror Assembly : doc.dll Syntax public delegate GameObject SpawnDelegate(Vector3 position, Guid assetId); Parameters Type Name Description Vector3 position Guid assetId Returns Type Description GameObject"
  },
  "api/Mirror.NotReadyMessage.html": {
    "href": "api/Mirror.NotReadyMessage.html",
    "title": "Struct NotReadyMessage",
    "keywords": "Struct NotReadyMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct NotReadyMessage : IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkClient.NetworkConnectionEvent.html": {
    "href": "api/Mirror.NetworkClient.NetworkConnectionEvent.html",
    "title": "Class NetworkClient.NetworkConnectionEvent",
    "keywords": "Class NetworkClient.NetworkConnectionEvent Inheritance Object NetworkClient.NetworkConnectionEvent Namespace : Mirror Assembly : doc.dll Syntax public class NetworkConnectionEvent : UnityEvent<INetworkConnection>"
  },
  "api/Mirror.SyncMode.html": {
    "href": "api/Mirror.SyncMode.html",
    "title": "Enum SyncMode",
    "keywords": "Enum SyncMode Sync to everyone, or only to owner. Namespace : Mirror Assembly : doc.dll Syntax public enum SyncMode : int Fields Name Description Observers Owner"
  },
  "api/Mirror.Discovery.NetworkDiscoveryBase-2.html": {
    "href": "api/Mirror.Discovery.NetworkDiscoveryBase-2.html",
    "title": "Class NetworkDiscoveryBase<Request, Response>",
    "keywords": "Class NetworkDiscoveryBase<Request, Response> Base implementation for Network Discovery. Extend this component to provide custom discovery with game specific data NetworkDiscovery for a sample implementation Inheritance Object NetworkDiscoveryBase<Request, Response> NetworkDiscovery Namespace : Mirror.Discovery Assembly : doc.dll Syntax public abstract class NetworkDiscoveryBase<Request, Response> : MonoBehaviour where Request : IMessageBase, new() where Response : IMessageBase, new() Type Parameters Name Description Request Response Fields | Improve this Doc View Source clientUdpClient Declaration protected UdpClient clientUdpClient Field Value Type Description UdpClient | Improve this Doc View Source secretHandshake Declaration public long secretHandshake Field Value Type Description Int64 | Improve this Doc View Source serverUdpClient Declaration protected UdpClient serverUdpClient Field Value Type Description UdpClient Properties | Improve this Doc View Source SupportedOnThisPlatform Declaration public static bool SupportedOnThisPlatform { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source AdvertiseServer() Advertise this server in the local network Declaration public void AdvertiseServer() | Improve this Doc View Source BroadcastDiscoveryRequest() Sends discovery request from client Declaration public void BroadcastDiscoveryRequest() | Improve this Doc View Source ClientListenAsync() Awaits for server response Declaration public Task ClientListenAsync() Returns Type Description Task ClientListenAsync Task | Improve this Doc View Source GetRequest() Create a message that will be broadcasted on the network to discover servers Declaration protected virtual Request GetRequest() Returns Type Description Request An instance of ServerRequest with data to be broadcasted Remarks Override if you wish to include additional data in the discovery message such as desired game mode, language, difficulty, etc... | Improve this Doc View Source ProcessClientRequest(Request, IPEndPoint) Reply to the client to inform it of this server Declaration protected virtual void ProcessClientRequest(Request request, IPEndPoint endpoint) Parameters Type Name Description Request request Request comming from client IPEndPoint endpoint Address of the client that sent the request Remarks Override if you wish to ignore server requests based on custom criteria such as language, full server game mode or difficulty | Improve this Doc View Source ProcessRequest(Request, IPEndPoint) Process the request from a client Declaration protected abstract Response ProcessRequest(Request request, IPEndPoint endpoint) Parameters Type Name Description Request request Request comming from client IPEndPoint endpoint Address of the client that sent the request Returns Type Description Response The message to be sent back to the client or null Remarks Override if you wish to provide more information to the clients such as the name of the host player | Improve this Doc View Source ProcessResponse(Response, IPEndPoint) Process the answer from a server Declaration protected abstract void ProcessResponse(Response response, IPEndPoint endpoint) Parameters Type Name Description Response response Response that came from the server IPEndPoint endpoint Address of the server that replied Remarks A client receives a reply from a server, this method processes the reply and raises an event | Improve this Doc View Source RandomLong() Declaration public static long RandomLong() Returns Type Description Int64 | Improve this Doc View Source ServerListenAsync() Declaration public Task ServerListenAsync() Returns Type Description Task | Improve this Doc View Source Start() virtual so that inheriting classes' Start() can call base.Start() too Declaration public virtual void Start() | Improve this Doc View Source StartDiscovery() Start Active Discovery Declaration public void StartDiscovery() | Improve this Doc View Source StopDiscovery() Stop Active Discovery Declaration public void StopDiscovery()"
  },
  "api/Mirror.ClientDataReceivedEvent.html": {
    "href": "api/Mirror.ClientDataReceivedEvent.html",
    "title": "Class ClientDataReceivedEvent",
    "keywords": "Class ClientDataReceivedEvent Inheritance Object ClientDataReceivedEvent Namespace : Mirror Assembly : doc.dll Syntax public class ClientDataReceivedEvent : UnityEvent<ArraySegment<byte>, int>"
  },
  "api/Mirror.NetworkServer.NetworkSceneEvent.html": {
    "href": "api/Mirror.NetworkServer.NetworkSceneEvent.html",
    "title": "Class NetworkServer.NetworkSceneEvent",
    "keywords": "Class NetworkServer.NetworkSceneEvent Inheritance Object NetworkServer.NetworkSceneEvent Namespace : Mirror Assembly : doc.dll Syntax public class NetworkSceneEvent : UnityEvent<string>"
  },
  "api/Mirror.SyncDictionary-2.html": {
    "href": "api/Mirror.SyncDictionary-2.html",
    "title": "Class SyncDictionary<TKey, TValue>",
    "keywords": "Class SyncDictionary<TKey, TValue> Inheritance Object SyncIDictionary <TKey, TValue> SyncDictionary<TKey, TValue> Implements ISyncObject Inherited Members SyncIDictionary<TKey, TValue>.objects SyncIDictionary<TKey, TValue>.Count SyncIDictionary<TKey, TValue>.IsReadOnly SyncIDictionary<TKey, TValue>.OnInsert SyncIDictionary<TKey, TValue>.OnClear SyncIDictionary<TKey, TValue>.OnRemove SyncIDictionary<TKey, TValue>.OnSet SyncIDictionary<TKey, TValue>.OnChange SyncIDictionary<TKey, TValue>.Reset() SyncIDictionary<TKey, TValue>.SerializeKey(NetworkWriter, TKey) SyncIDictionary<TKey, TValue>.SerializeItem(NetworkWriter, TValue) SyncIDictionary<TKey, TValue>.DeserializeKey(NetworkReader) SyncIDictionary<TKey, TValue>.DeserializeItem(NetworkReader) SyncIDictionary<TKey, TValue>.IsDirty SyncIDictionary<TKey, TValue>.Keys SyncIDictionary<TKey, TValue>.Values SyncIDictionary<TKey, TValue>.Flush() SyncIDictionary<TKey, TValue>.OnSerializeAll(NetworkWriter) SyncIDictionary<TKey, TValue>.OnSerializeDelta(NetworkWriter) SyncIDictionary<TKey, TValue>.OnDeserializeAll(NetworkReader) SyncIDictionary<TKey, TValue>.OnDeserializeDelta(NetworkReader) SyncIDictionary<TKey, TValue>.Clear() SyncIDictionary<TKey, TValue>.ContainsKey(TKey) SyncIDictionary<TKey, TValue>.Remove(TKey) SyncIDictionary<TKey, TValue>.Item[TKey] SyncIDictionary<TKey, TValue>.TryGetValue(TKey, TValue) SyncIDictionary<TKey, TValue>.Add(TKey, TValue) SyncIDictionary<TKey, TValue>.Add(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.Contains(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.CopyTo(KeyValuePair<TKey, TValue>[], Int32) SyncIDictionary<TKey, TValue>.Remove(KeyValuePair<TKey, TValue>) SyncIDictionary<TKey, TValue>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncDictionary<TKey, TValue> : SyncIDictionary<TKey, TValue>, ISyncObject Type Parameters Name Description TKey TValue Constructors | Improve this Doc View Source SyncDictionary() Declaration protected SyncDictionary() | Improve this Doc View Source SyncDictionary(IEqualityComparer<TKey>) Declaration protected SyncDictionary(IEqualityComparer<TKey> eq) Parameters Type Name Description IEqualityComparer <TKey> eq Properties | Improve this Doc View Source Keys Declaration public Dictionary<TKey, TValue>.KeyCollection Keys { get; } Property Value Type Description Dictionary.KeyCollection <> | Improve this Doc View Source Values Declaration public Dictionary<TKey, TValue>.ValueCollection Values { get; } Property Value Type Description Dictionary.ValueCollection <> Methods | Improve this Doc View Source GetEnumerator() Declaration public Dictionary<TKey, TValue>.Enumerator GetEnumerator() Returns Type Description Dictionary.Enumerator <> Implements ISyncObject"
  },
  "api/Mirror.NetworkWriter.html": {
    "href": "api/Mirror.NetworkWriter.html",
    "title": "Class NetworkWriter",
    "keywords": "Class NetworkWriter Binary stream Writer. Supports simple types, buffers, arrays, structs, and nested types Use GetWriter() to reduce memory allocation Inheritance Object NetworkWriter PooledNetworkWriter Namespace : Mirror Assembly : doc.dll Syntax public class NetworkWriter : object Fields | Improve this Doc View Source MaxStringLength Declaration public const int MaxStringLength = null Field Value Type Description Int32 Properties | Improve this Doc View Source Length Declaration public int Length { get; } Property Value Type Description Int32 | Improve this Doc View Source Position Declaration public int Position { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source Reset() Reset both the position and length of the stream Declaration public void Reset() Remarks Leaves the capacity the same so that we can reuse this writer without extra allocations | Improve this Doc View Source SetLength(Int32) Sets length, moves position if it is greater than new length Declaration public void SetLength(int newLength) Parameters Type Name Description Int32 newLength Remarks Zeros out any extra length created by setlength | Improve this Doc View Source ToArray() Declaration public byte[] ToArray() Returns Type Description Byte [] | Improve this Doc View Source ToArraySegment() Declaration public ArraySegment<byte> ToArraySegment() Returns Type Description ArraySegment < Byte > | Improve this Doc View Source WriteByte(Byte) Declaration public void WriteByte(byte value) Parameters Type Name Description Byte value | Improve this Doc View Source WriteBytes(Byte[], Int32, Int32) Declaration public void WriteBytes(byte[] buffer, int offset, int count) Parameters Type Name Description Byte [] buffer Int32 offset Int32 count | Improve this Doc View Source WriteInt32(Int32) Declaration public void WriteInt32(int value) Parameters Type Name Description Int32 value | Improve this Doc View Source WriteInt64(Int64) Declaration public void WriteInt64(long value) Parameters Type Name Description Int64 value | Improve this Doc View Source WriteUInt32(UInt32) Declaration public void WriteUInt32(uint value) Parameters Type Name Description UInt32 value | Improve this Doc View Source WriteUInt64(UInt64) Declaration public void WriteUInt64(ulong value) Parameters Type Name Description UInt64 value Extension Methods NetworkWriterExtensions.WriteByte(NetworkWriter, Byte) NetworkWriterExtensions.WriteSByte(NetworkWriter, SByte) NetworkWriterExtensions.WriteChar(NetworkWriter, Char) NetworkWriterExtensions.WriteBoolean(NetworkWriter, Boolean) NetworkWriterExtensions.WriteUInt16(NetworkWriter, UInt16) NetworkWriterExtensions.WriteInt16(NetworkWriter, Int16) NetworkWriterExtensions.WriteSingle(NetworkWriter, Single) NetworkWriterExtensions.WriteDouble(NetworkWriter, Double) NetworkWriterExtensions.WriteDecimal(NetworkWriter, Decimal) NetworkWriterExtensions.WriteString(NetworkWriter, String) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[], Int32, Int32) NetworkWriterExtensions.WriteBytesAndSize(NetworkWriter, Byte[]) NetworkWriterExtensions.WriteBytesAndSizeSegment(NetworkWriter, ArraySegment<Byte>) NetworkWriterExtensions.WritePackedInt32(NetworkWriter, Int32) NetworkWriterExtensions.WritePackedUInt32(NetworkWriter, UInt32) NetworkWriterExtensions.WritePackedInt64(NetworkWriter, Int64) NetworkWriterExtensions.WritePackedUInt64(NetworkWriter, UInt64) NetworkWriterExtensions.WriteVector2(NetworkWriter, Vector2) NetworkWriterExtensions.WriteVector3(NetworkWriter, Vector3) NetworkWriterExtensions.WriteVector4(NetworkWriter, Vector4) NetworkWriterExtensions.WriteVector2Int(NetworkWriter, Vector2Int) NetworkWriterExtensions.WriteVector3Int(NetworkWriter, Vector3Int) NetworkWriterExtensions.WriteColor(NetworkWriter, Color) NetworkWriterExtensions.WriteColor32(NetworkWriter, Color32) NetworkWriterExtensions.WriteQuaternion(NetworkWriter, Quaternion) NetworkWriterExtensions.WriteRect(NetworkWriter, Rect) NetworkWriterExtensions.WritePlane(NetworkWriter, Plane) NetworkWriterExtensions.WriteRay(NetworkWriter, Ray) NetworkWriterExtensions.WriteMatrix4x4(NetworkWriter, Matrix4x4) NetworkWriterExtensions.WriteGuid(NetworkWriter, Guid) NetworkWriterExtensions.WriteNetworkIdentity(NetworkWriter, NetworkIdentity) NetworkWriterExtensions.WriteTransform(NetworkWriter, Transform) NetworkWriterExtensions.WriteGameObject(NetworkWriter, GameObject) NetworkWriterExtensions.WriteUri(NetworkWriter, Uri) NetworkWriterExtensions.WriteMessage<T>(NetworkWriter, T)"
  },
  "api/Mirror.SpawnMessage.html": {
    "href": "api/Mirror.SpawnMessage.html",
    "title": "Struct SpawnMessage",
    "keywords": "Struct SpawnMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct SpawnMessage : IMessageBase Fields | Improve this Doc View Source assetId Declaration public Guid assetId Field Value Type Description Guid | Improve this Doc View Source isLocalPlayer Declaration public bool isLocalPlayer Field Value Type Description Boolean | Improve this Doc View Source isOwner Declaration public bool isOwner Field Value Type Description Boolean | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte > | Improve this Doc View Source position Declaration public Vector3 position Field Value Type Description Vector3 | Improve this Doc View Source rotation Declaration public Quaternion rotation Field Value Type Description Quaternion | Improve this Doc View Source scale Declaration public Vector3 scale Field Value Type Description Vector3 | Improve this Doc View Source sceneId Declaration public ulong sceneId Field Value Type Description UInt64 Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkServer.NetworkConnectionEvent.html": {
    "href": "api/Mirror.NetworkServer.NetworkConnectionEvent.html",
    "title": "Class NetworkServer.NetworkConnectionEvent",
    "keywords": "Class NetworkServer.NetworkConnectionEvent Inheritance Object NetworkServer.NetworkConnectionEvent Namespace : Mirror Assembly : doc.dll Syntax public class NetworkConnectionEvent : UnityEvent<INetworkConnection>"
  },
  "api/Mirror.NetworkTransformBase.DataPoint.html": {
    "href": "api/Mirror.NetworkTransformBase.DataPoint.html",
    "title": "Class NetworkTransformBase.DataPoint",
    "keywords": "Class NetworkTransformBase.DataPoint Inheritance Object NetworkTransformBase.DataPoint Namespace : Mirror Assembly : doc.dll Syntax public class DataPoint : object Fields | Improve this Doc View Source LocalPosition Declaration public Vector3 LocalPosition Field Value Type Description Vector3 | Improve this Doc View Source LocalRotation Declaration public Quaternion LocalRotation Field Value Type Description Quaternion | Improve this Doc View Source LocalScale Declaration public Vector3 LocalScale Field Value Type Description Vector3 | Improve this Doc View Source MovementSpeed Declaration public float MovementSpeed Field Value Type Description Single | Improve this Doc View Source TimeStamp Declaration public float TimeStamp Field Value Type Description Single"
  },
  "api/Mirror.UnityEventException.html": {
    "href": "api/Mirror.UnityEventException.html",
    "title": "Class UnityEventException",
    "keywords": "Class UnityEventException Inheritance Object UnityEventException Namespace : Mirror Assembly : doc.dll Syntax public class UnityEventException : UnityEvent<Exception>"
  },
  "api/Mirror.NetworkBehaviour.html": {
    "href": "api/Mirror.NetworkBehaviour.html",
    "title": "Class NetworkBehaviour",
    "keywords": "Class NetworkBehaviour Base class which should be inherited by scripts which contain networking functionality. Inheritance Object NetworkBehaviour NetworkAnimator NetworkTransformBase NetworkVisibility Namespace : Mirror Assembly : doc.dll Syntax public abstract class NetworkBehaviour : MonoBehaviour Remarks This is a MonoBehaviour class so scripts which need to use the networking feature should inherit this class instead of MonoBehaviour. It allows you to invoke networked actions, receive various callbacks, and automatically synchronize state from server-to-client. The NetworkBehaviour component requires a NetworkIdentity on the game object. There can be multiple NetworkBehaviours on a single game object. For an object with sub-components in a hierarchy, the NetworkIdentity must be on the root object, and NetworkBehaviour scripts must also be on the root object. Some of the built-in components of the networking system are derived from NetworkBehaviour, including NetworkTransport, NetworkAnimator and NetworkProximityChecker. Fields | Improve this Doc View Source syncInterval sync interval for OnSerialize (in seconds) Declaration public float syncInterval Field Value Type Description Single | Improve this Doc View Source syncMode sync mode for OnSerialize Declaration public SyncMode syncMode Field Value Type Description SyncMode | Improve this Doc View Source syncObjects objects that can synchronize themselves, such as synclists Declaration protected readonly List<ISyncObject> syncObjects Field Value Type Description List < ISyncObject > Properties | Improve this Doc View Source Client The NetworkClient associated to this object. Declaration public NetworkClient Client { get; } Property Value Type Description NetworkClient | Improve this Doc View Source ComponentIndex Returns the index of the component on this object Declaration public int ComponentIndex { get; } Property Value Type Description Int32 | Improve this Doc View Source ConnectionToClient The NetworkConnection associated with this NetworkIdentity This is only valid for player objects on the server. Declaration public INetworkConnection ConnectionToClient { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source ConnectionToServer The NetworkConnection associated with this NetworkIdentity This is only valid for player objects on the server. Declaration public INetworkConnection ConnectionToServer { get; } Property Value Type Description INetworkConnection | Improve this Doc View Source HasAuthority This returns true if this object is the authoritative version of the object in the distributed network application. The HasAuthority value on the NetworkIdentity determines how authority is determined. For most objects, authority is held by the server. For objects with HasAuthority set, authority is held by the client of that player. Declaration public bool HasAuthority { get; } Property Value Type Description Boolean | Improve this Doc View Source IsClient Returns true if running as a client and this object was spawned by a server. Declaration public bool IsClient { get; } Property Value Type Description Boolean | Improve this Doc View Source IsClientOnly True if this object exists on a client that is not also acting as a server Declaration public bool IsClientOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalClient Returns true if we're on host mode. Declaration public bool IsLocalClient { get; } Property Value Type Description Boolean | Improve this Doc View Source IsLocalPlayer This returns true if this object is the one that represents the player on the local machine. In multiplayer games, there are multiple instances of the Player object. The client needs to know which one is for \"themselves\" so that only that player processes input and potentially has a camera attached. The IsLocalPlayer function will return true only for the player instance that belongs to the player on the local machine, so it can be used to filter out input for non-local players. Declaration public bool IsLocalPlayer { get; } Property Value Type Description Boolean | Improve this Doc View Source IsServer Returns true if this object is active on an active server. This is only true if the object has been spawned. This is different from NetworkServer.active, which is true if the server itself is active rather than this object being active. Declaration public bool IsServer { get; } Property Value Type Description Boolean | Improve this Doc View Source IsServerOnly True if this object only exists on the server Declaration public bool IsServerOnly { get; } Property Value Type Description Boolean | Improve this Doc View Source NetId The unique network Id of this object. This is assigned at runtime by the network server and will be unique for all objects for that network session. Declaration public uint NetId { get; } Property Value Type Description UInt32 | Improve this Doc View Source NetIdentity Returns the NetworkIdentity of this object Declaration public NetworkIdentity NetIdentity { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source NetworkTime Declaration public NetworkTime NetworkTime { get; } Property Value Type Description NetworkTime | Improve this Doc View Source Server The NetworkServer associated to this object. Declaration public NetworkServer Server { get; } Property Value Type Description NetworkServer | Improve this Doc View Source SyncVarDirtyBits Declaration protected ulong SyncVarDirtyBits { get; } Property Value Type Description UInt64 Methods | Improve this Doc View Source ClearAllDirtyBits() This clears all the dirty bits that were set on this script by SetDirtyBits(); This is automatically invoked when an update is sent for this object, but can be called manually as well. Declaration public void ClearAllDirtyBits() | Improve this Doc View Source DeserializeSyncVars(NetworkReader, Boolean) Declaration public virtual void DeserializeSyncVars(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Boolean initialState | Improve this Doc View Source GetDelegate(Int32) Gets the handler function for a given hash Can be used by profilers and debuggers Declaration public static NetworkBehaviour.CmdDelegate GetDelegate(int cmdHash) Parameters Type Name Description Int32 cmdHash rpc function hash Returns Type Description NetworkBehaviour.CmdDelegate The function delegate that will handle the command | Improve this Doc View Source GetRpcHandler(Int32) Declaration public static NetworkBehaviour.CmdDelegate GetRpcHandler(int cmdHash) Parameters Type Name Description Int32 cmdHash Returns Type Description NetworkBehaviour.CmdDelegate | Improve this Doc View Source GetSyncVarGameObject(UInt32, ref GameObject) Declaration protected GameObject GetSyncVarGameObject(uint netId, ref GameObject gameObjectField) Parameters Type Name Description UInt32 netId GameObject gameObjectField Returns Type Description GameObject | Improve this Doc View Source GetSyncVarHookGuard(UInt64) Declaration protected bool GetSyncVarHookGuard(ulong dirtyBit) Parameters Type Name Description UInt64 dirtyBit Returns Type Description Boolean | Improve this Doc View Source GetSyncVarNetworkIdentity(UInt32, ref NetworkIdentity) Declaration protected NetworkIdentity GetSyncVarNetworkIdentity(uint netId, ref NetworkIdentity identityField) Parameters Type Name Description UInt32 netId NetworkIdentity identityField Returns Type Description NetworkIdentity | Improve this Doc View Source InitSyncObject(ISyncObject) Declaration protected void InitSyncObject(ISyncObject syncObject) Parameters Type Name Description ISyncObject syncObject | Improve this Doc View Source InvokeCommand(Int32, NetworkReader) Manually invoke a Command. Declaration public virtual bool InvokeCommand(int cmdHash, NetworkReader reader) Parameters Type Name Description Int32 cmdHash Hash of the Command name. NetworkReader reader Parameters to pass to the command. Returns Type Description Boolean Returns true if successful. | Improve this Doc View Source InvokeRpc(Int32, NetworkReader) Manually invoke an RPC function. Declaration public virtual bool InvokeRpc(int rpcHash, NetworkReader reader) Parameters Type Name Description Int32 rpcHash Hash of the RPC name. NetworkReader reader Parameters to pass to the RPC function. Returns Type Description Boolean Returns true if successful. | Improve this Doc View Source InvokeSyncEvent(Int32, NetworkReader) Manually invoke a SyncEvent. Declaration public virtual bool InvokeSyncEvent(int eventHash, NetworkReader reader) Parameters Type Name Description Int32 eventHash Hash of the SyncEvent name. NetworkReader reader Parameters to pass to the SyncEvent. Returns Type Description Boolean Returns true if successful. | Improve this Doc View Source OnDeserialize(NetworkReader, Boolean) Virtual function to override to receive custom serialization data. The corresponding function to send serialization data is OnSerialize(). Declaration public virtual void OnDeserialize(NetworkReader reader, bool initialState) Parameters Type Name Description NetworkReader reader Reader to read from the stream. Boolean initialState True if being sent initial state. | Improve this Doc View Source OnSerialize(NetworkWriter, Boolean) Virtual function to override to send custom serialization data. The corresponding function to send serialization data is OnDeserialize(). Declaration public virtual bool OnSerialize(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Writer to use to write to the stream. Boolean initialState If this is being called to send initial state. Returns Type Description Boolean True if data was written. Remarks The initialState flag is useful to differentiate between the first time an object is serialized and when incremental updates can be sent. The first time an object is sent to a client, it must include a full state snapshot, but subsequent updates can save on bandwidth by including only incremental changes. Note that SyncVar hook functions are not called when initialState is true, only for incremental updates. If a class has SyncVars, then an implementation of this function and OnDeserialize() are added automatically to the class. So a class that has SyncVars cannot also have custom serialization functions. The OnSerialize function should return true to indicate that an update should be sent. If it returns true, then the dirty bits for that script are set to zero, if it returns false then the dirty bits are not changed. This allows multiple changes to a script to be accumulated over time and sent when the system is ready, instead of every frame. | Improve this Doc View Source RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) Declaration public static void RegisterCommandDelegate(Type invokeClass, string cmdName, NetworkBehaviour.CmdDelegate func) Parameters Type Name Description Type invokeClass String cmdName NetworkBehaviour.CmdDelegate func | Improve this Doc View Source RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) Declaration protected static void RegisterDelegate(Type invokeClass, string cmdName, MirrorInvokeType invokerType, NetworkBehaviour.CmdDelegate func) Parameters Type Name Description Type invokeClass String cmdName MirrorInvokeType invokerType NetworkBehaviour.CmdDelegate func | Improve this Doc View Source RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) Declaration public static void RegisterEventDelegate(Type invokeClass, string eventName, NetworkBehaviour.CmdDelegate func) Parameters Type Name Description Type invokeClass String eventName NetworkBehaviour.CmdDelegate func | Improve this Doc View Source RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) Declaration public static void RegisterRpcDelegate(Type invokeClass, string rpcName, NetworkBehaviour.CmdDelegate func) Parameters Type Name Description Type invokeClass String rpcName NetworkBehaviour.CmdDelegate func | Improve this Doc View Source SendCommandInternal(Type, String, NetworkWriter, Int32) Declaration protected void SendCommandInternal(Type invokeClass, string cmdName, NetworkWriter writer, int channelId) Parameters Type Name Description Type invokeClass String cmdName NetworkWriter writer Int32 channelId | Improve this Doc View Source SendEventInternal(Type, String, NetworkWriter, Int32) Declaration protected void SendEventInternal(Type invokeClass, string eventName, NetworkWriter writer, int channelId) Parameters Type Name Description Type invokeClass String eventName NetworkWriter writer Int32 channelId | Improve this Doc View Source SendRpcInternal(Type, String, NetworkWriter, Int32) Declaration protected void SendRpcInternal(Type invokeClass, string rpcName, NetworkWriter writer, int channelId) Parameters Type Name Description Type invokeClass String rpcName NetworkWriter writer Int32 channelId | Improve this Doc View Source SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) Declaration protected void SendTargetRpcInternal(INetworkConnection conn, Type invokeClass, string rpcName, NetworkWriter writer, int channelId) Parameters Type Name Description INetworkConnection conn Type invokeClass String rpcName NetworkWriter writer Int32 channelId | Improve this Doc View Source SerializeObjectsAll(NetworkWriter) Declaration public bool SerializeObjectsAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Returns Type Description Boolean | Improve this Doc View Source SerializeObjectsDelta(NetworkWriter) Declaration public bool SerializeObjectsDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Returns Type Description Boolean | Improve this Doc View Source SerializeSyncVars(NetworkWriter, Boolean) Declaration public virtual bool SerializeSyncVars(NetworkWriter writer, bool initialState) Parameters Type Name Description NetworkWriter writer Boolean initialState Returns Type Description Boolean | Improve this Doc View Source SetDirtyBit(UInt64) Used to set the behaviour as dirty, so that a network update will be sent for the object. these are masks, not bit numbers, ie. 0x004 not 2 Declaration public void SetDirtyBit(ulong dirtyBit) Parameters Type Name Description UInt64 dirtyBit Bit mask to set. | Improve this Doc View Source SetSyncVar<T>(T, ref T, UInt64) Declaration protected void SetSyncVar<T>(T value, ref T fieldValue, ulong dirtyBit) Parameters Type Name Description T value T fieldValue UInt64 dirtyBit Type Parameters Name Description T | Improve this Doc View Source SetSyncVarGameObject(GameObject, ref GameObject, UInt64, ref UInt32) Declaration protected void SetSyncVarGameObject(GameObject newGameObject, ref GameObject gameObjectField, ulong dirtyBit, ref uint netIdField) Parameters Type Name Description GameObject newGameObject GameObject gameObjectField UInt64 dirtyBit UInt32 netIdField | Improve this Doc View Source SetSyncVarHookGuard(UInt64, Boolean) Declaration protected void SetSyncVarHookGuard(ulong dirtyBit, bool value) Parameters Type Name Description UInt64 dirtyBit Boolean value | Improve this Doc View Source SetSyncVarNetworkIdentity(NetworkIdentity, ref NetworkIdentity, UInt64, ref UInt32) Declaration protected void SetSyncVarNetworkIdentity(NetworkIdentity newIdentity, ref NetworkIdentity identityField, ulong dirtyBit, ref uint netIdField) Parameters Type Name Description NetworkIdentity newIdentity NetworkIdentity identityField UInt64 dirtyBit UInt32 netIdField | Improve this Doc View Source SyncVarEqual<T>(T, ref T) Declaration protected bool SyncVarEqual<T>(T value, ref T fieldValue) Parameters Type Name Description T value T fieldValue Returns Type Description Boolean Type Parameters Name Description T | Improve this Doc View Source SyncVarGameObjectEqual(GameObject, UInt32) Declaration protected bool SyncVarGameObjectEqual(GameObject newGameObject, uint netIdField) Parameters Type Name Description GameObject newGameObject UInt32 netIdField Returns Type Description Boolean | Improve this Doc View Source SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) Declaration protected bool SyncVarNetworkIdentityEqual(NetworkIdentity newIdentity, uint netIdField) Parameters Type Name Description NetworkIdentity newIdentity UInt32 netIdField Returns Type Description Boolean"
  },
  "api/Mirror.UnSpawnDelegate.html": {
    "href": "api/Mirror.UnSpawnDelegate.html",
    "title": "Delegate UnSpawnDelegate",
    "keywords": "Delegate UnSpawnDelegate Namespace : Mirror Assembly : doc.dll Syntax public delegate void UnSpawnDelegate(GameObject spawned); Parameters Type Name Description GameObject spawned"
  },
  "api/Mirror.RpcMessage.html": {
    "href": "api/Mirror.RpcMessage.html",
    "title": "Struct RpcMessage",
    "keywords": "Struct RpcMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct RpcMessage : IMessageBase Fields | Improve this Doc View Source componentIndex Declaration public int componentIndex Field Value Type Description Int32 | Improve this Doc View Source functionHash Declaration public int functionHash Field Value Type Description Int32 | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte > Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.ConnectState.html": {
    "href": "api/Mirror.ConnectState.html",
    "title": "Enum ConnectState",
    "keywords": "Enum ConnectState Namespace : Mirror Assembly : doc.dll Syntax public enum ConnectState : int Fields Name Description Connected Connecting Disconnected None"
  },
  "api/Mirror.MirrorInvokeType.html": {
    "href": "api/Mirror.MirrorInvokeType.html",
    "title": "Enum MirrorInvokeType",
    "keywords": "Enum MirrorInvokeType Namespace : Mirror Assembly : doc.dll Syntax public enum MirrorInvokeType : int Fields Name Description ClientRpc Command SyncEvent"
  },
  "api/Mirror.IConnection.html": {
    "href": "api/Mirror.IConnection.html",
    "title": "Interface IConnection",
    "keywords": "Interface IConnection Namespace : Mirror Assembly : doc.dll Syntax public interface IConnection Methods | Improve this Doc View Source Disconnect() Disconnect this connection Declaration void Disconnect() | Improve this Doc View Source GetEndPointAddress() the address of endpoint we are connected to Note this can be IPEndPoint or a custom implementation of EndPoint, which depends on the transport Declaration EndPoint GetEndPointAddress() Returns Type Description EndPoint | Improve this Doc View Source ReceiveAsync(MemoryStream) reads a message from connection Declaration Task<bool> ReceiveAsync(MemoryStream buffer) Parameters Type Name Description MemoryStream buffer buffer where the message will be written Returns Type Description Task < Boolean > true if we got a message, false if we got disconnected | Improve this Doc View Source SendAsync(ArraySegment<Byte>) Declaration Task SendAsync(ArraySegment<byte> data) Parameters Type Name Description ArraySegment < Byte > data Returns Type Description Task"
  },
  "api/Mirror.Discovery.html": {
    "href": "api/Mirror.Discovery.html",
    "title": "Namespace Mirror.Discovery",
    "keywords": "Namespace Mirror.Discovery Classes NetworkDiscovery NetworkDiscoveryBase<Request, Response> Base implementation for Network Discovery. Extend this component to provide custom discovery with game specific data NetworkDiscovery for a sample implementation NetworkDiscoveryHUD ServerFoundUnityEvent ServerRequest ServerResponse"
  },
  "api/Mirror.CommandMessage.html": {
    "href": "api/Mirror.CommandMessage.html",
    "title": "Struct CommandMessage",
    "keywords": "Struct CommandMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct CommandMessage : IMessageBase Fields | Improve this Doc View Source componentIndex Declaration public int componentIndex Field Value Type Description Int32 | Improve this Doc View Source functionHash Declaration public int functionHash Field Value Type Description Int32 | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte > Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.SyncListFloat.html": {
    "href": "api/Mirror.SyncListFloat.html",
    "title": "Class SyncListFloat",
    "keywords": "Class SyncListFloat Inheritance Object SyncList < Single > SyncListFloat Implements IReadOnlyList < Single > ISyncObject Inherited Members SyncList<Single>.Count SyncList<Single>.IsReadOnly SyncList<Single>.OnInsert SyncList<Single>.OnClear SyncList<Single>.OnRemove SyncList<Single>.OnSet SyncList<Single>.OnChange SyncList<Single>.IsDirty SyncList<Single>.Flush() SyncList<Single>.Reset() SyncList<Single>.OnSerializeAll(NetworkWriter) SyncList<Single>.OnSerializeDelta(NetworkWriter) SyncList<Single>.OnDeserializeAll(NetworkReader) SyncList<Single>.OnDeserializeDelta(NetworkReader) SyncList<Single>.Add(Single) SyncList<Single>.Clear() SyncList<Single>.Contains(Single) SyncList<Single>.CopyTo(Single[], Int32) SyncList<Single>.IndexOf(Single) SyncList<Single>.FindIndex(Predicate<Single>) SyncList<Single>.Find(Predicate<Single>) SyncList<Single>.FindAll(Predicate<Single>) SyncList<Single>.Insert(Int32, Single) SyncList<Single>.Remove(Single) SyncList<Single>.RemoveAt(Int32) SyncList<Single>.Item[Int32] SyncList<Single>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListFloat : SyncList<float>, IReadOnlyList<float>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override float DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Single Overrides Mirror.SyncList<System.Single>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, Single) Declaration protected override void SerializeItem(NetworkWriter writer, float item) Parameters Type Name Description NetworkWriter writer Single item Overrides Mirror.SyncList<System.Single>.SerializeItem(Mirror.NetworkWriter, System.Single) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.ServerAttribute.html": {
    "href": "api/Mirror.ServerAttribute.html",
    "title": "Class ServerAttribute",
    "keywords": "Class ServerAttribute Prevents clients from running this method. Prints a warning if a client tries to execute this method. Inheritance Object ServerAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ServerAttribute : Attribute"
  },
  "api/Mirror.INetworkServer.html": {
    "href": "api/Mirror.INetworkServer.html",
    "title": "Interface INetworkServer",
    "keywords": "Interface INetworkServer Inherited Members IServerObjectManager.AddPlayerForConnection(INetworkConnection, GameObject) IServerObjectManager.AddPlayerForConnection(INetworkConnection, GameObject, Guid) IServerObjectManager.ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Boolean) IServerObjectManager.ReplacePlayerForConnection(INetworkConnection, NetworkClient, GameObject, Guid, Boolean) IServerObjectManager.Spawn(GameObject, GameObject) IServerObjectManager.Spawn(GameObject, INetworkConnection) IServerObjectManager.Spawn(GameObject, Guid, INetworkConnection) IServerObjectManager.Destroy(GameObject) IServerObjectManager.UnSpawn(GameObject) IServerObjectManager.SpawnObjects() Namespace : Mirror Assembly : doc.dll Syntax public interface INetworkServer : IServerObjectManager Methods | Improve this Doc View Source AddConnection(INetworkConnection) Declaration void AddConnection(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn | Improve this Doc View Source Disconnect() Declaration void Disconnect() | Improve this Doc View Source RemoveConnection(INetworkConnection) Declaration void RemoveConnection(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn | Improve this Doc View Source SendToAll<T>(T, Int32) Declaration void SendToAll<T>(T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description T msg Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendToClientOfPlayer<T>(NetworkIdentity, T, Int32) Declaration void SendToClientOfPlayer<T>(NetworkIdentity identity, T msg, int channelId = null) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity T msg Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendToReady<T>(NetworkIdentity, T, Boolean, Int32) Declaration void SendToReady<T>(NetworkIdentity identity, T msg, bool includeOwner = true, int channelId = null) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity T msg Boolean includeOwner Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SendToReady<T>(NetworkIdentity, T, Int32) Declaration void SendToReady<T>(NetworkIdentity identity, T msg, int channelId) where T : IMessageBase Parameters Type Name Description NetworkIdentity identity T msg Int32 channelId Type Parameters Name Description T | Improve this Doc View Source SetAllClientsNotReady() Declaration void SetAllClientsNotReady() | Improve this Doc View Source SetClientNotReady(INetworkConnection) Declaration void SetClientNotReady(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn | Improve this Doc View Source SetClientReady(INetworkConnection) Declaration void SetClientReady(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn"
  },
  "api/Mirror.NetworkPingMessage.html": {
    "href": "api/Mirror.NetworkPingMessage.html",
    "title": "Struct NetworkPingMessage",
    "keywords": "Struct NetworkPingMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct NetworkPingMessage : IMessageBase Constructors | Improve this Doc View Source NetworkPingMessage(Double) Declaration public NetworkPingMessage(double value) Parameters Type Name Description Double value Fields | Improve this Doc View Source clientTime Declaration public double clientTime Field Value Type Description Double Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkWriterPool.html": {
    "href": "api/Mirror.NetworkWriterPool.html",
    "title": "Class NetworkWriterPool",
    "keywords": "Class NetworkWriterPool Pool of NetworkWriters Use this pool instead of NetworkWriter to reduce memory allocation Use Capacity to change size of pool Inheritance Object NetworkWriterPool Namespace : Mirror Assembly : doc.dll Syntax public static class NetworkWriterPool : object Properties | Improve this Doc View Source Capacity Size of the pool If pool is too small getting writers will causes memory allocation Default value: 100 Declaration public static int Capacity { get; set; } Property Value Type Description Int32 Methods | Improve this Doc View Source GetWriter() Get the next writer in the pool If pool is empty, creates a new Writer Declaration public static PooledNetworkWriter GetWriter() Returns Type Description PooledNetworkWriter | Improve this Doc View Source Recycle(PooledNetworkWriter) Puts writer back into pool When pool is full, the extra writer is left for the GC Declaration public static void Recycle(PooledNetworkWriter writer) Parameters Type Name Description PooledNetworkWriter writer"
  },
  "api/Mirror.NetworkReader.html": {
    "href": "api/Mirror.NetworkReader.html",
    "title": "Class NetworkReader",
    "keywords": "Class NetworkReader Binary stream Reader. Supports simple types, buffers, arrays, structs, and nested types Use GetReader(Byte[]) to reduce memory allocation Inheritance Object NetworkReader PooledNetworkReader Namespace : Mirror Assembly : doc.dll Syntax public class NetworkReader : object Constructors | Improve this Doc View Source NetworkReader(ArraySegment<Byte>) Declaration public NetworkReader(ArraySegment<byte> segment) Parameters Type Name Description ArraySegment < Byte > segment | Improve this Doc View Source NetworkReader(Byte[]) Declaration public NetworkReader(byte[] bytes) Parameters Type Name Description Byte [] bytes Fields | Improve this Doc View Source Position Declaration public int Position Field Value Type Description Int32 Properties | Improve this Doc View Source Length Declaration public int Length { get; } Property Value Type Description Int32 Methods | Improve this Doc View Source ReadByte() Declaration public byte ReadByte() Returns Type Description Byte | Improve this Doc View Source ReadBytes(Byte[], Int32) Declaration public byte[] ReadBytes(byte[] bytes, int count) Parameters Type Name Description Byte [] bytes Int32 count Returns Type Description Byte [] | Improve this Doc View Source ReadBytesSegment(Int32) Declaration public ArraySegment<byte> ReadBytesSegment(int count) Parameters Type Name Description Int32 count Returns Type Description ArraySegment < Byte > | Improve this Doc View Source ReadInt32() Declaration public int ReadInt32() Returns Type Description Int32 | Improve this Doc View Source ReadInt64() Declaration public long ReadInt64() Returns Type Description Int64 | Improve this Doc View Source ReadUInt32() Declaration public uint ReadUInt32() Returns Type Description UInt32 | Improve this Doc View Source ReadUInt64() Declaration public ulong ReadUInt64() Returns Type Description UInt64 | Improve this Doc View Source ToString() Declaration public override string ToString() Returns Type Description String Extension Methods NetworkReaderExtensions.ReadByte(NetworkReader) NetworkReaderExtensions.ReadSByte(NetworkReader) NetworkReaderExtensions.ReadChar(NetworkReader) NetworkReaderExtensions.ReadBoolean(NetworkReader) NetworkReaderExtensions.ReadInt16(NetworkReader) NetworkReaderExtensions.ReadUInt16(NetworkReader) NetworkReaderExtensions.ReadInt32(NetworkReader) NetworkReaderExtensions.ReadUInt32(NetworkReader) NetworkReaderExtensions.ReadInt64(NetworkReader) NetworkReaderExtensions.ReadUInt64(NetworkReader) NetworkReaderExtensions.ReadSingle(NetworkReader) NetworkReaderExtensions.ReadDouble(NetworkReader) NetworkReaderExtensions.ReadDecimal(NetworkReader) NetworkReaderExtensions.ReadString(NetworkReader) NetworkReaderExtensions.ReadBytesAndSize(NetworkReader) NetworkReaderExtensions.ReadBytesAndSizeSegment(NetworkReader) NetworkReaderExtensions.ReadPackedInt32(NetworkReader) NetworkReaderExtensions.ReadPackedUInt32(NetworkReader) NetworkReaderExtensions.ReadPackedInt64(NetworkReader) NetworkReaderExtensions.ReadPackedUInt64(NetworkReader) NetworkReaderExtensions.ReadVector2(NetworkReader) NetworkReaderExtensions.ReadVector3(NetworkReader) NetworkReaderExtensions.ReadVector4(NetworkReader) NetworkReaderExtensions.ReadVector2Int(NetworkReader) NetworkReaderExtensions.ReadVector3Int(NetworkReader) NetworkReaderExtensions.ReadColor(NetworkReader) NetworkReaderExtensions.ReadColor32(NetworkReader) NetworkReaderExtensions.ReadQuaternion(NetworkReader) NetworkReaderExtensions.ReadRect(NetworkReader) NetworkReaderExtensions.ReadPlane(NetworkReader) NetworkReaderExtensions.ReadRay(NetworkReader) NetworkReaderExtensions.ReadMatrix4x4(NetworkReader) NetworkReaderExtensions.ReadBytes(NetworkReader, Int32) NetworkReaderExtensions.ReadGuid(NetworkReader) NetworkReaderExtensions.ReadTransform(NetworkReader) NetworkReaderExtensions.ReadGameObject(NetworkReader) NetworkReaderExtensions.ReadNetworkIdentity(NetworkReader) NetworkReaderExtensions.ReadUri(NetworkReader) NetworkReaderExtensions.ReadMessage<T>(NetworkReader, T)"
  },
  "api/Mirror.NetworkAuthenticator.html": {
    "href": "api/Mirror.NetworkAuthenticator.html",
    "title": "Class NetworkAuthenticator",
    "keywords": "Class NetworkAuthenticator Base class for implementing component-based authentication during the Connect phase Inheritance Object NetworkAuthenticator Namespace : Mirror Assembly : doc.dll Syntax public abstract class NetworkAuthenticator : MonoBehaviour Methods | Improve this Doc View Source OnClientAuthenticate(INetworkConnection) Called on client from OnClientAuthenticateInternal when a client needs to authenticate Declaration public virtual void OnClientAuthenticate(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Connection of the client. | Improve this Doc View Source OnServerAuthenticate(INetworkConnection) Called on server from OnServerAuthenticateInternal when a client needs to authenticate Declaration public virtual void OnServerAuthenticate(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Connection to client. Events | Improve this Doc View Source OnClientAuthenticated Notify subscribers on the client when the client is authenticated Declaration public event Action<INetworkConnection> OnClientAuthenticated Event Type Type Description Action < INetworkConnection > | Improve this Doc View Source OnServerAuthenticated Notify subscribers on the server when a client is authenticated Declaration public event Action<INetworkConnection> OnServerAuthenticated Event Type Type Description Action < INetworkConnection >"
  },
  "api/Mirror.NetworkTime.html": {
    "href": "api/Mirror.NetworkTime.html",
    "title": "Class NetworkTime",
    "keywords": "Class NetworkTime Synchronize time between the server and the clients Inheritance Object NetworkTime Namespace : Mirror Assembly : doc.dll Syntax public class NetworkTime : object Constructors | Improve this Doc View Source NetworkTime() Declaration public NetworkTime() Fields | Improve this Doc View Source PingFrequency how often are we sending ping messages used to calculate network time and RTT Declaration public float PingFrequency Field Value Type Description Single | Improve this Doc View Source PingWindowSize average out the last few results from Ping Declaration public int PingWindowSize Field Value Type Description Int32 Properties | Improve this Doc View Source Offset Clock difference in seconds between the client and the server Declaration public double Offset { get; } Property Value Type Description Double Remarks Note this value is always 0 at the server | Improve this Doc View Source Rtt how long in seconds does it take for a message to go to the server and come back Declaration public double Rtt { get; } Property Value Type Description Double | Improve this Doc View Source RttSd Measure the standard deviation of rtt the higher the number, the less accurate rtt is Declaration public double RttSd { get; } Property Value Type Description Double | Improve this Doc View Source RttVar measure variance of rtt the higher the number, the less accurate rtt is Declaration public double RttVar { get; } Property Value Type Description Double | Improve this Doc View Source Time The time in seconds since the server started. Declaration public double Time { get; } Property Value Type Description Double Remarks Note this value works in the client and the server the value is synchronized accross the network with high accuracy You should not cast this down to a float because the it loses too much accuracy when the server is up for a while I measured the accuracy of float and I got this: for the same day, accuracy is better than 1 ms after 1 day, accuracy goes down to 7 ms after 10 days, accuracy is 61 ms after 30 days , accuracy is 238 ms after 60 days, accuracy is 454 ms in other words, if the server is running for 2 months, and you cast down to float, then the time will jump in 0.4s intervals. | Improve this Doc View Source TimeSd standard deviation of time. The higher the variance, the less accurate the time is Declaration public double TimeSd { get; } Property Value Type Description Double | Improve this Doc View Source TimeVar Measurement of the variance of time. The higher the variance, the less accurate the time is Declaration public double TimeVar { get; } Property Value Type Description Double Methods | Improve this Doc View Source Reset() Declaration public void Reset()"
  },
  "api/Mirror.SyncSortedSet-1.html": {
    "href": "api/Mirror.SyncSortedSet-1.html",
    "title": "Class SyncSortedSet<T>",
    "keywords": "Class SyncSortedSet<T> Inheritance Object SyncSet <T> SyncSortedSet<T> Implements ISyncObject Inherited Members SyncSet<T>.objects SyncSet<T>.Count SyncSet<T>.IsReadOnly SyncSet<T>.OnAdd SyncSet<T>.OnClear SyncSet<T>.OnRemove SyncSet<T>.OnChange SyncSet<T>.Reset() SyncSet<T>.SerializeItem(NetworkWriter, T) SyncSet<T>.DeserializeItem(NetworkReader) SyncSet<T>.IsDirty SyncSet<T>.Flush() SyncSet<T>.OnSerializeAll(NetworkWriter) SyncSet<T>.OnSerializeDelta(NetworkWriter) SyncSet<T>.OnDeserializeAll(NetworkReader) SyncSet<T>.OnDeserializeDelta(NetworkReader) SyncSet<T>.Add(T) SyncSet<T>.Clear() SyncSet<T>.Contains(T) SyncSet<T>.CopyTo(T[], Int32) SyncSet<T>.Remove(T) SyncSet<T>.ExceptWith(IEnumerable<T>) SyncSet<T>.IntersectWith(IEnumerable<T>) SyncSet<T>.IsProperSubsetOf(IEnumerable<T>) SyncSet<T>.IsProperSupersetOf(IEnumerable<T>) SyncSet<T>.IsSubsetOf(IEnumerable<T>) SyncSet<T>.IsSupersetOf(IEnumerable<T>) SyncSet<T>.Overlaps(IEnumerable<T>) SyncSet<T>.SetEquals(IEnumerable<T>) SyncSet<T>.SymmetricExceptWith(IEnumerable<T>) SyncSet<T>.UnionWith(IEnumerable<T>) Namespace : Mirror Assembly : doc.dll Syntax public abstract class SyncSortedSet<T> : SyncSet<T>, ISyncObject Type Parameters Name Description T Constructors | Improve this Doc View Source SyncSortedSet(IComparer<T>) Declaration protected SyncSortedSet(IComparer<T> comparer = null) Parameters Type Name Description IComparer <T> comparer Methods | Improve this Doc View Source GetEnumerator() Declaration public SortedSet<T>.Enumerator GetEnumerator() Returns Type Description SortedSet.Enumerator <> Implements ISyncObject"
  },
  "api/Mirror.NetworkSceneChecker.html": {
    "href": "api/Mirror.NetworkSceneChecker.html",
    "title": "Class NetworkSceneChecker",
    "keywords": "Class NetworkSceneChecker Component that controls visibility of networked objects between scenes. Any object with this component on it will only be visible to other objects in the same scene This would be used when the server has multiple additive subscenes loaded to isolate players to their respective subscenes Inheritance Object NetworkBehaviour NetworkVisibility NetworkSceneChecker Inherited Members NetworkVisibility.OnSetHostVisibility(Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.Client NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRpc(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.GetDelegate(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkSceneChecker : NetworkVisibility Fields | Improve this Doc View Source forceHidden Flag to force this object to be hidden from all observers. If this object is a player object, it will not be hidden for that client. Declaration public bool forceHidden Field Value Type Description Boolean Methods | Improve this Doc View Source OnCheckObserver(INetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public override bool OnCheckObserver(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection of a player. Returns Type Description Boolean True if the player can see this object. Overrides NetworkVisibility.OnCheckObserver(INetworkConnection) | Improve this Doc View Source OnRebuildObservers(HashSet<INetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public override void OnRebuildObservers(HashSet<INetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < INetworkConnection > observers The new set of observers for this object. Boolean initialize True if the set of observers is being built for the first time. Overrides NetworkVisibility.OnRebuildObservers(HashSet<INetworkConnection>, Boolean) | Improve this Doc View Source OnStartServer() Declaration public void OnStartServer()"
  },
  "api/Mirror.PooledNetworkReader.html": {
    "href": "api/Mirror.PooledNetworkReader.html",
    "title": "Class PooledNetworkReader",
    "keywords": "Class PooledNetworkReader NetworkReader to be used with NetworkReaderPool Inheritance Object NetworkReader PooledNetworkReader Implements IDisposable Inherited Members NetworkReader.Position NetworkReader.Length NetworkReader.ReadByte() NetworkReader.ReadInt32() NetworkReader.ReadUInt32() NetworkReader.ReadInt64() NetworkReader.ReadUInt64() NetworkReader.ReadBytes(Byte[], Int32) NetworkReader.ReadBytesSegment(Int32) NetworkReader.ToString() Namespace : Mirror Assembly : doc.dll Syntax public class PooledNetworkReader : NetworkReader, IDisposable Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() Implements IDisposable Extension Methods NetworkReaderExtensions.ReadByte(NetworkReader) NetworkReaderExtensions.ReadSByte(NetworkReader) NetworkReaderExtensions.ReadChar(NetworkReader) NetworkReaderExtensions.ReadBoolean(NetworkReader) NetworkReaderExtensions.ReadInt16(NetworkReader) NetworkReaderExtensions.ReadUInt16(NetworkReader) NetworkReaderExtensions.ReadInt32(NetworkReader) NetworkReaderExtensions.ReadUInt32(NetworkReader) NetworkReaderExtensions.ReadInt64(NetworkReader) NetworkReaderExtensions.ReadUInt64(NetworkReader) NetworkReaderExtensions.ReadSingle(NetworkReader) NetworkReaderExtensions.ReadDouble(NetworkReader) NetworkReaderExtensions.ReadDecimal(NetworkReader) NetworkReaderExtensions.ReadString(NetworkReader) NetworkReaderExtensions.ReadBytesAndSize(NetworkReader) NetworkReaderExtensions.ReadBytesAndSizeSegment(NetworkReader) NetworkReaderExtensions.ReadPackedInt32(NetworkReader) NetworkReaderExtensions.ReadPackedUInt32(NetworkReader) NetworkReaderExtensions.ReadPackedInt64(NetworkReader) NetworkReaderExtensions.ReadPackedUInt64(NetworkReader) NetworkReaderExtensions.ReadVector2(NetworkReader) NetworkReaderExtensions.ReadVector3(NetworkReader) NetworkReaderExtensions.ReadVector4(NetworkReader) NetworkReaderExtensions.ReadVector2Int(NetworkReader) NetworkReaderExtensions.ReadVector3Int(NetworkReader) NetworkReaderExtensions.ReadColor(NetworkReader) NetworkReaderExtensions.ReadColor32(NetworkReader) NetworkReaderExtensions.ReadQuaternion(NetworkReader) NetworkReaderExtensions.ReadRect(NetworkReader) NetworkReaderExtensions.ReadPlane(NetworkReader) NetworkReaderExtensions.ReadRay(NetworkReader) NetworkReaderExtensions.ReadMatrix4x4(NetworkReader) NetworkReaderExtensions.ReadBytes(NetworkReader, Int32) NetworkReaderExtensions.ReadGuid(NetworkReader) NetworkReaderExtensions.ReadTransform(NetworkReader) NetworkReaderExtensions.ReadGameObject(NetworkReader) NetworkReaderExtensions.ReadNetworkIdentity(NetworkReader) NetworkReaderExtensions.ReadUri(NetworkReader) NetworkReaderExtensions.ReadMessage<T>(NetworkReader, T)"
  },
  "api/Mirror.SyncList-1.Enumerator.html": {
    "href": "api/Mirror.SyncList-1.Enumerator.html",
    "title": "Struct SyncList<T>.Enumerator",
    "keywords": "Struct SyncList<T>.Enumerator Implements IEnumerator <T> Namespace : Mirror Assembly : doc.dll Syntax public struct Enumerator : IEnumerator<T> Constructors | Improve this Doc View Source Enumerator(SyncList<T>) Declaration public Enumerator(SyncList<T> list) Parameters Type Name Description SyncList <T> list Properties | Improve this Doc View Source Current Declaration public T Current { get; } Property Value Type Description T Methods | Improve this Doc View Source Dispose() Declaration public void Dispose() | Improve this Doc View Source MoveNext() Declaration public bool MoveNext() Returns Type Description Boolean | Improve this Doc View Source Reset() Declaration public void Reset() Implements IEnumerator<>"
  },
  "api/Mirror.SyncListInt.html": {
    "href": "api/Mirror.SyncListInt.html",
    "title": "Class SyncListInt",
    "keywords": "Class SyncListInt Inheritance Object SyncList < Int32 > SyncListInt Implements IReadOnlyList < Int32 > ISyncObject Inherited Members SyncList<Int32>.Count SyncList<Int32>.IsReadOnly SyncList<Int32>.OnInsert SyncList<Int32>.OnClear SyncList<Int32>.OnRemove SyncList<Int32>.OnSet SyncList<Int32>.OnChange SyncList<Int32>.IsDirty SyncList<Int32>.Flush() SyncList<Int32>.Reset() SyncList<Int32>.OnSerializeAll(NetworkWriter) SyncList<Int32>.OnSerializeDelta(NetworkWriter) SyncList<Int32>.OnDeserializeAll(NetworkReader) SyncList<Int32>.OnDeserializeDelta(NetworkReader) SyncList<Int32>.Add(Int32) SyncList<Int32>.Clear() SyncList<Int32>.Contains(Int32) SyncList<Int32>.CopyTo(Int32[], Int32) SyncList<Int32>.IndexOf(Int32) SyncList<Int32>.FindIndex(Predicate<Int32>) SyncList<Int32>.Find(Predicate<Int32>) SyncList<Int32>.FindAll(Predicate<Int32>) SyncList<Int32>.Insert(Int32, Int32) SyncList<Int32>.Remove(Int32) SyncList<Int32>.RemoveAt(Int32) SyncList<Int32>.Item[Int32] SyncList<Int32>.GetEnumerator() Namespace : Mirror Assembly : doc.dll Syntax public class SyncListInt : SyncList<int>, IReadOnlyList<int>, ISyncObject Methods | Improve this Doc View Source DeserializeItem(NetworkReader) Declaration protected override int DeserializeItem(NetworkReader reader) Parameters Type Name Description NetworkReader reader Returns Type Description Int32 Overrides Mirror.SyncList<System.Int32>.DeserializeItem(Mirror.NetworkReader) | Improve this Doc View Source SerializeItem(NetworkWriter, Int32) Declaration protected override void SerializeItem(NetworkWriter writer, int item) Parameters Type Name Description NetworkWriter writer Int32 item Overrides Mirror.SyncList<System.Int32>.SerializeItem(Mirror.NetworkWriter, System.Int32) Implements IReadOnlyList<> ISyncObject"
  },
  "api/Mirror.NetworkBehaviour.CmdDelegate.html": {
    "href": "api/Mirror.NetworkBehaviour.CmdDelegate.html",
    "title": "Delegate NetworkBehaviour.CmdDelegate",
    "keywords": "Delegate NetworkBehaviour.CmdDelegate Delegate for Command functions. Namespace : Mirror Assembly : doc.dll Syntax public delegate void CmdDelegate(NetworkBehaviour obj, NetworkReader reader); Parameters Type Name Description NetworkBehaviour obj NetworkReader reader"
  },
  "api/Mirror.MessagePacker.html": {
    "href": "api/Mirror.MessagePacker.html",
    "title": "Class MessagePacker",
    "keywords": "Class MessagePacker Inheritance Object MessagePacker Namespace : Mirror Assembly : doc.dll Syntax public static class MessagePacker : object Methods | Improve this Doc View Source GetId(Type) Declaration public static int GetId(Type type) Parameters Type Name Description Type type Returns Type Description Int32 | Improve this Doc View Source GetId<T>() Declaration public static int GetId<T>() where T : IMessageBase Returns Type Description Int32 Type Parameters Name Description T | Improve this Doc View Source Pack<T>(T) Declaration public static byte[] Pack<T>(T message) where T : IMessageBase Parameters Type Name Description T message Returns Type Description Byte [] Type Parameters Name Description T | Improve this Doc View Source Pack<T>(T, NetworkWriter) Declaration public static void Pack<T>(T message, NetworkWriter writer) where T : IMessageBase Parameters Type Name Description T message NetworkWriter writer Type Parameters Name Description T | Improve this Doc View Source Unpack<T>(Byte[]) Declaration public static T Unpack<T>(byte[] data) where T : IMessageBase, new() Parameters Type Name Description Byte [] data Returns Type Description T Type Parameters Name Description T | Improve this Doc View Source UnpackId(NetworkReader) Declaration public static int UnpackId(NetworkReader messageReader) Parameters Type Name Description NetworkReader messageReader Returns Type Description Int32"
  },
  "api/Mirror.StringHash.html": {
    "href": "api/Mirror.StringHash.html",
    "title": "Class StringHash",
    "keywords": "Class StringHash Inheritance Object StringHash Namespace : Mirror Assembly : doc.dll Syntax public static class StringHash : object Methods | Improve this Doc View Source GetStableHashCode(String) Declaration public static int GetStableHashCode(this string text) Parameters Type Name Description String text Returns Type Description Int32"
  },
  "api/Mirror.ExponentialMovingAverage.html": {
    "href": "api/Mirror.ExponentialMovingAverage.html",
    "title": "Class ExponentialMovingAverage",
    "keywords": "Class ExponentialMovingAverage Inheritance Object ExponentialMovingAverage Namespace : Mirror Assembly : doc.dll Syntax public class ExponentialMovingAverage : object Constructors | Improve this Doc View Source ExponentialMovingAverage(Int32) Declaration public ExponentialMovingAverage(int n) Parameters Type Name Description Int32 n Properties | Improve this Doc View Source Value Declaration public double Value { get; } Property Value Type Description Double | Improve this Doc View Source Var Declaration public double Var { get; } Property Value Type Description Double Methods | Improve this Doc View Source Add(Double) Declaration public void Add(double newValue) Parameters Type Name Description Double newValue"
  },
  "api/Mirror.html": {
    "href": "api/Mirror.html",
    "title": "Namespace Mirror",
    "keywords": "Namespace Mirror Classes AsyncFallbackTransport AsyncMultiplexTransport AsyncQueue<T> AsyncTransport Base transport class, any transport should implement this class and it's abstract methods Channels ClientAttribute Prevents the server from running this method. Prints a warning if the server tries to execute this method. ClientCallbackAttribute Prevents the server from running this method. No warning is printed. ClientDataReceivedEvent ClientRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on clients. CommandAttribute Call this from a client to run this function on the server. Make sure to validate input etc. It's not possible to call this from a server. ExponentialMovingAverage ILoggerExtensions InvalidMessageException LogFactory MessageBase MessagePacker NetworkAnimator A component to synchronize Mecanim animation states for networked objects. NetworkAuthenticator Base class for implementing component-based authentication during the Connect phase NetworkBehaviour Base class which should be inherited by scripts which contain networking functionality. NetworkBehaviour.Invoker NetworkClient This is a network client class used by the networking system. It contains a NetworkConnection that is used to connect to a network server. The NetworkClient handle connection state, messages handlers, and connection configuration. There can be many NetworkClient instances in a process at a time, but only one that is connected to a game server ( NetworkServer ) that uses spawned objects. NetworkClient has an internal update function where it handles events from the transport layer. This includes asynchronous connect events, disconnect events and incoming data from a server. The NetworkManager has a NetworkClient instance that it uses for games that it starts, but the NetworkClient may be used by itself. NetworkClient.ClientSceneChangeEvent NetworkClient.NetworkConnectionEvent NetworkConnection A High level network connection. This is used for connections from client-to-server and for connection from server-to-client. NetworkDiagnostics Provides profiling information from mirror A profiler can subscribe to these events and present the data in a friendly way to the user NetworkIdentity The NetworkIdentity identifies objects across the network, between server and clients. Its primary data is a NetworkInstanceId which is allocated by the server and then set on clients. This is used in network communications to be able to lookup game objects on different machines. NetworkManager NetworkManagerHUD An extension for the NetworkManager that displays a default HUD for controlling the network state of the game. This component also shows useful internal state for the networking system in the inspector window of the editor. It allows users to view connections, networked objects, message handlers, and packet statistics. This information can be helpful when debugging networked games. NetworkMatchChecker Component that controls visibility of networked objects based on match id. Any object with this component on it will only be visible to other objects in the same match. This would be used to isolate players to their respective matches within a single game server instance. NetworkProximityChecker Component that controls visibility of networked objects for players. Any object with this component on it will not be visible to players more than a (configurable) distance away. NetworkReader Binary stream Reader. Supports simple types, buffers, arrays, structs, and nested types Use GetReader(Byte[]) to reduce memory allocation NetworkReaderExtensions NetworkReaderPool Pool of NetworkReaders Use this pool instead of NetworkReader to reduce memory allocation Use Capacity to change size of pool NetworkSceneChecker Component that controls visibility of networked objects between scenes. Any object with this component on it will only be visible to other objects in the same scene This would be used when the server has multiple additive subscenes loaded to isolate players to their respective subscenes NetworkServer The NetworkServer. NetworkServer.NetworkConnectionEvent NetworkServer.NetworkSceneEvent NetworkTime Synchronize time between the server and the clients NetworkTransform NetworkTransformBase NetworkTransformBase.DataPoint NetworkTransformChild A component to synchronize the position of child transforms of networked objects. There must be a NetworkTransform on the root object of the hierarchy. There can be multiple NetworkTransformChild components on an object. This does not use physics for synchronization, it simply synchronizes the localPosition and localRotation of the child transform and lerps towards the recieved values. NetworkVisibility NetworkWriter Binary stream Writer. Supports simple types, buffers, arrays, structs, and nested types Use GetWriter() to reduce memory allocation NetworkWriterExtensions NetworkWriterPool Pool of NetworkWriters Use this pool instead of NetworkWriter to reduce memory allocation Use Capacity to change size of pool PipeConnection A connection that is directly connected to another connection If you send data in one of them, you receive it on the other one PlayerSpawner Spawns a player as soon as the connection is authenticated PooledNetworkReader NetworkReader to be used with NetworkReaderPool PooledNetworkWriter NetworkWriter to be used with NetworkWriterPool SceneAttribute Converts a string property into a Scene property in the inspector ServerAttribute Prevents clients from running this method. Prints a warning if a client tries to execute this method. ServerCallbackAttribute Prevents clients from running this method. No warning is thrown. ServerDataReceivedEvent ShowInInspectorAttribute Used to show private SyncList in the inspector, Use instead of SerializeField for non Serializable types StringHash SyncDictionary<TKey, TValue> SyncEventAttribute SyncEvents are networked events like ClientRpc's, but instead of calling a function on the game object, they trigger Events instead. SyncHashSet<T> SyncIDictionary<TKey, TValue> SyncList<T> SyncListBool SyncListFloat SyncListInt SyncListString SyncListUInt SyncSet<T> SyncSortedSet<T> SyncVarAttribute SyncVars are used to synchronize a variable from the server to all clients automatically. Value must be changed on server, not directly by clients. Hook parameter allows you to define a client-side method to be invoked when the client gets an update from the server. TargetRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on a specific client. Transport UnityEventException UnityEventInt UnityEventIntException Structs AddPlayerMessage CommandMessage NetworkDiagnostics.MessageInfo Describes an outgoing message NetworkPingMessage NetworkPongMessage NotReadyMessage ObjectDestroyMessage ObjectHideMessage ObjectSpawnFinishedMessage ObjectSpawnStartedMessage ReadyMessage RemovePlayerMessage RpcMessage SceneMessage SpawnMessage SyncEventMessage SyncList<T>.Enumerator UpdateVarsMessage Interfaces IClientObjectManager IClientSceneManager IConnection IMessageBase IMessageHandler An object that can send and receive messages INetworkClient INetworkConnection A connection to a remote endpoint. May be from the server to client or from client to server INetworkManager INetworkServer IObjectOwner An object that can own networked objects IServerObjectManager ISyncObject IVisibilityTracker An object that can observe NetworkIdentities. this is useful for interest management Enums ConnectState MirrorInvokeType NetworkProximityChecker.CheckMethod Enumeration of methods to use to check proximity. PlayerSpawner.PlayerSpawnMethod Enumeration of methods of where to spawn player objects in multiplayer games. SceneOperation SyncMode Sync to everyone, or only to owner. Version Delegates NetworkBehaviour.CmdDelegate Delegate for Command functions. NetworkIdentity.ClientAuthorityCallback The delegate type for the clientAuthorityCallback. SpawnDelegate SpawnHandlerDelegate UnSpawnDelegate"
  },
  "api/Mirror.IObjectOwner.html": {
    "href": "api/Mirror.IObjectOwner.html",
    "title": "Interface IObjectOwner",
    "keywords": "Interface IObjectOwner An object that can own networked objects Namespace : Mirror Assembly : doc.dll Syntax public interface IObjectOwner Properties | Improve this Doc View Source Identity Declaration NetworkIdentity Identity { get; set; } Property Value Type Description NetworkIdentity Methods | Improve this Doc View Source AddOwnedObject(NetworkIdentity) Declaration void AddOwnedObject(NetworkIdentity networkIdentity) Parameters Type Name Description NetworkIdentity networkIdentity | Improve this Doc View Source DestroyOwnedObjects() Declaration void DestroyOwnedObjects() | Improve this Doc View Source RemoveOwnedObject(NetworkIdentity) Declaration void RemoveOwnedObject(NetworkIdentity networkIdentity) Parameters Type Name Description NetworkIdentity networkIdentity"
  },
  "api/Mirror.TargetRpcAttribute.html": {
    "href": "api/Mirror.TargetRpcAttribute.html",
    "title": "Class TargetRpcAttribute",
    "keywords": "Class TargetRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on a specific client. Inheritance Object TargetRpcAttribute Namespace : Mirror Assembly : doc.dll Syntax public class TargetRpcAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description Int32"
  },
  "api/Mirror.NetworkManager.html": {
    "href": "api/Mirror.NetworkManager.html",
    "title": "Class NetworkManager",
    "keywords": "Class NetworkManager Inheritance Object NetworkManager Implements INetworkManager Namespace : Mirror Assembly : doc.dll Syntax public class NetworkManager : MonoBehaviour, INetworkManager Fields | Improve this Doc View Source client Declaration public NetworkClient client Field Value Type Description NetworkClient | Improve this Doc View Source clientLoadedScene This is true if the client loaded a new scene when connecting to the server. This is set before OnClientConnect is called, so it can be checked there to perform different logic if a scene load occurred. Declaration public bool clientLoadedScene Field Value Type Description Boolean | Improve this Doc View Source dontDestroyOnLoad A flag to control whether the NetworkManager object is destroyed when the scene changes. This should be set if your game has a single NetworkManager that exists for the lifetime of the process. If there is a NetworkManager in each scene, then this should not be set. Declaration public bool dontDestroyOnLoad Field Value Type Description Boolean | Improve this Doc View Source loadingSceneAsync Declaration public AsyncOperation loadingSceneAsync Field Value Type Description AsyncOperation | Improve this Doc View Source networkSceneName The name of the current network scene. Declaration public string networkSceneName Field Value Type Description String Remarks This is populated if the NetworkManager is doing scene management. This should not be changed directly. Calls to ServerChangeScene() cause this to change. New clients that connect to a server will automatically load this scene. This is used to make sure that all scene changes are initialized by Mirror. Loading a scene manually wont set networkSceneName, so Mirror would still load it again on start. | Improve this Doc View Source OnStartHost This is invoked when a host is started. StartHost has multiple signatures, but they all cause this hook to be called. Declaration public UnityEvent OnStartHost Field Value Type Description UnityEvent | Improve this Doc View Source OnStopHost This is called when a host is stopped. Declaration public UnityEvent OnStopHost Field Value Type Description UnityEvent | Improve this Doc View Source server Declaration public NetworkServer server Field Value Type Description NetworkServer | Improve this Doc View Source serverTickRate Server Update frequency, per second. Use around 60Hz for fast paced games like Counter-Strike to minimize latency. Use around 30Hz for games like WoW to minimize computations. Use around 1-10Hz for slow paced games like EVE. Declaration public int serverTickRate Field Value Type Description Int32 | Improve this Doc View Source startOnHeadless Automatically invoke StartServer() If the application is a Server Build or run with the -batchMode command line arguement, StartServer is automatically invoked. Declaration public bool startOnHeadless Field Value Type Description Boolean | Improve this Doc View Source transport Declaration protected AsyncTransport transport Field Value Type Description AsyncTransport Properties | Improve this Doc View Source IsNetworkActive True if the server or client is started and running This is set True in StartServer / StartClient, and set False in StopServer / StopClient Declaration public bool IsNetworkActive { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source ConfigureServerFrameRate() Set the frame rate for a headless server. Override if you wish to disable the behavior or set your own tick rate. Declaration public virtual void ConfigureServerFrameRate() | Improve this Doc View Source LateUpdate() virtual so that inheriting classes' LateUpdate() can call base.LateUpdate() too Declaration public virtual void LateUpdate() | Improve this Doc View Source OnDestroy() virtual so that inheriting classes' OnDestroy() can call base.OnDestroy() too Declaration public virtual void OnDestroy() | Improve this Doc View Source OnValidate() virtual so that inheriting classes' OnValidate() can call base.OnValidate() too Declaration public virtual void OnValidate() | Improve this Doc View Source ServerChangeScene(String) This causes the server to switch scenes and sets the networkSceneName. Clients that connect to this server will automatically switch to this scene. This is called autmatically if onlineScene or offlineScene are set, but it can be called from user code to switch scenes again while the game is in progress. This automatically sets clients to be not-ready. The clients must call NetworkClient.Ready() again to participate in the new scene. Declaration public virtual void ServerChangeScene(string newSceneName) Parameters Type Name Description String newSceneName | Improve this Doc View Source Start() virtual so that inheriting classes' Start() can call base.Start() too Declaration public virtual void Start() | Improve this Doc View Source StartClient(String) This starts a network client. It uses the networkAddress property as the address to connect to. This makes the newly created client connect to the server immediately. Declaration public Task StartClient(string serverIp) Parameters Type Name Description String serverIp Returns Type Description Task | Improve this Doc View Source StartClient(Uri) This starts a network client. It uses the Uri parameter as the address to connect to. This makes the newly created client connect to the server immediately. Declaration public void StartClient(Uri uri) Parameters Type Name Description Uri uri location of the server to connect to | Improve this Doc View Source StartHost() This starts a network \"host\" - a server and client in the same application. The client returned from StartHost() is a special \"local\" client that communicates to the in-process server using a message queue instead of the real network. But in almost all other cases, it can be treated as a normal client. Declaration public Task StartHost() Returns Type Description Task | Improve this Doc View Source StartServer() This starts a new server. Declaration public Task StartServer() Returns Type Description Task | Improve this Doc View Source StopClient() Stops the client that the manager is using. Declaration public void StopClient() | Improve this Doc View Source StopHost() This stops both the client and the server that the manager is using. Declaration public void StopHost() | Improve this Doc View Source StopServer() Stops the server that the manager is using. Declaration public void StopServer() Implements INetworkManager"
  },
  "api/Mirror.NetworkProximityChecker.html": {
    "href": "api/Mirror.NetworkProximityChecker.html",
    "title": "Class NetworkProximityChecker",
    "keywords": "Class NetworkProximityChecker Component that controls visibility of networked objects for players. Any object with this component on it will not be visible to players more than a (configurable) distance away. Inheritance Object NetworkBehaviour NetworkVisibility NetworkProximityChecker Inherited Members NetworkVisibility.OnSetHostVisibility(Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.Client NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRpc(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.GetDelegate(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkProximityChecker : NetworkVisibility Fields | Improve this Doc View Source ActualCheckMethod Which method to use for checking proximity of players. Physics3D uses 3D physics to determine proximity. Physics2D uses 2D physics to determine proximity. Declaration public NetworkProximityChecker.CheckMethod ActualCheckMethod Field Value Type Description NetworkProximityChecker.CheckMethod | Improve this Doc View Source CastLayers Select only the Player's layer to avoid unnecessary SphereCasts against the Terrain, etc. ~0 means 'Everything'. Declaration public LayerMask CastLayers Field Value Type Description LayerMask | Improve this Doc View Source ForceHidden Flag to force this object to be hidden for players. If this object is a player object, it will not be hidden for that player. Declaration public bool ForceHidden Field Value Type Description Boolean | Improve this Doc View Source VisibilityRange The maximim range that objects will be visible at. Declaration public int VisibilityRange Field Value Type Description Int32 | Improve this Doc View Source VisibilityUpdateInterval How often (in seconds) that this object should update the list of observers that can see it. Declaration public float VisibilityUpdateInterval Field Value Type Description Single Methods | Improve this Doc View Source OnCheckObserver(INetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public override bool OnCheckObserver(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection of a player. Returns Type Description Boolean True if the player can see this object. Overrides NetworkVisibility.OnCheckObserver(INetworkConnection) | Improve this Doc View Source OnRebuildObservers(HashSet<INetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public override void OnRebuildObservers(HashSet<INetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < INetworkConnection > observers The new set of observers for this object. Boolean initialize True if the set of observers is being built for the first time. Overrides NetworkVisibility.OnRebuildObservers(HashSet<INetworkConnection>, Boolean)"
  },
  "api/Mirror.AsyncFallbackTransport.html": {
    "href": "api/Mirror.AsyncFallbackTransport.html",
    "title": "Class AsyncFallbackTransport",
    "keywords": "Class AsyncFallbackTransport Inheritance Object AsyncTransport AsyncFallbackTransport Namespace : Mirror Assembly : doc.dll Syntax public class AsyncFallbackTransport : AsyncTransport Fields | Improve this Doc View Source transports Declaration public AsyncTransport[] transports Field Value Type Description AsyncTransport [] Properties | Improve this Doc View Source Scheme Declaration public override string Scheme { get; } Property Value Type Description String Overrides AsyncTransport.Scheme Methods | Improve this Doc View Source AcceptAsync() Declaration public override Task<IConnection> AcceptAsync() Returns Type Description Task < IConnection > Overrides AsyncTransport.AcceptAsync() | Improve this Doc View Source ConnectAsync(Uri) Declaration public override Task<IConnection> ConnectAsync(Uri uri) Parameters Type Name Description Uri uri Returns Type Description Task < IConnection > Overrides AsyncTransport.ConnectAsync(Uri) | Improve this Doc View Source Disconnect() Declaration public override void Disconnect() Overrides AsyncTransport.Disconnect() | Improve this Doc View Source ListenAsync() Declaration public override Task ListenAsync() Returns Type Description Task Overrides AsyncTransport.ListenAsync() | Improve this Doc View Source ServerUri() Declaration public override Uri ServerUri() Returns Type Description Uri Overrides AsyncTransport.ServerUri()"
  },
  "api/Mirror.Transport.html": {
    "href": "api/Mirror.Transport.html",
    "title": "Class Transport",
    "keywords": "Class Transport Inheritance Object Transport Namespace : Mirror Assembly : doc.dll Syntax public abstract class Transport : MonoBehaviour Fields | Improve this Doc View Source OnClientDataReceived Notify subscribers when this client receive data from the server Declaration public ClientDataReceivedEvent OnClientDataReceived Field Value Type Description ClientDataReceivedEvent | Improve this Doc View Source OnClientDisconnected Notify subscribers when this client disconnects from the server Declaration public UnityEvent OnClientDisconnected Field Value Type Description UnityEvent | Improve this Doc View Source OnClientError Notify subscribers when this clianet encounters an error communicating with the server Declaration public UnityEventException OnClientError Field Value Type Description UnityEventException | Improve this Doc View Source OnServerConnected Notify subscribers when a client connects to this server Declaration public UnityEventInt OnServerConnected Field Value Type Description UnityEventInt | Improve this Doc View Source OnServerDataReceived Notify subscribers when this server receives data from the client Declaration public ServerDataReceivedEvent OnServerDataReceived Field Value Type Description ServerDataReceivedEvent | Improve this Doc View Source OnServerDisconnected Notify subscribers when a client disconnects from this server Declaration public UnityEventInt OnServerDisconnected Field Value Type Description UnityEventInt | Improve this Doc View Source OnServerError Notify subscribers when this server has some problem communicating with the client Declaration public UnityEventIntException OnServerError Field Value Type Description UnityEventIntException Methods | Improve this Doc View Source Available() Is this transport available in the current platform? Some transports might only be available in mobile Many will not work in webgl Example usage: return Application.platform == RuntimePlatform.WebGLPlayer Declaration public abstract bool Available() Returns Type Description Boolean True if this transport works in the current platform | Improve this Doc View Source ClientConnectAsync(String) Establish a connection to a server Declaration public abstract Task ClientConnectAsync(string address) Parameters Type Name Description String address The IP address or FQDN of the server we are trying to connect to Returns Type Description Task | Improve this Doc View Source ClientConnectAsync(Uri) Establish a connection to a server Declaration public virtual Task ClientConnectAsync(Uri uri) Parameters Type Name Description Uri uri The address of the server we are trying to connect to Returns Type Description Task | Improve this Doc View Source ClientConnected() Determines if we are currently connected to the server Declaration public abstract bool ClientConnected() Returns Type Description Boolean True if a connection has been established to the server | Improve this Doc View Source ClientDisconnect() Disconnect this client from the server Declaration public abstract void ClientDisconnect() | Improve this Doc View Source ClientSend(Int32, ArraySegment<Byte>) Send data to the server Declaration public abstract bool ClientSend(int channelId, ArraySegment<byte> segment) Parameters Type Name Description Int32 channelId The channel to use. 0 is the default channel, but some transports might want to provide unreliable, encrypted, compressed, or any other feature as new channels ArraySegment < Byte > segment The data to send to the server. Will be recycled after returning, so either use it directly or copy it internally. This allows for allocation-free sends! Returns Type Description Boolean true if the send was successful | Improve this Doc View Source GetMaxPacketSize(Int32) The maximum packet size for a given channel. Unreliable transports usually can only deliver small packets. Reliable fragmented channels can usually deliver large ones. GetMaxPacketSize needs to return a value at all times. Even if the Transport isn't running, or isn't Available(). This is because Fallback and Multiplex transports need to find the smallest possible packet size at runtime. Declaration public abstract int GetMaxPacketSize(int channelId = null) Parameters Type Name Description Int32 channelId channel id Returns Type Description Int32 the size in bytes that can be sent via the provided channel | Improve this Doc View Source OnApplicationQuit() called when quitting the application by closing the window / pressing stop in the editor virtual so that inheriting classes' OnApplicationQuit() can call base.OnApplicationQuit() too Declaration public virtual void OnApplicationQuit() | Improve this Doc View Source ServerActive() Determines if the server is up and running Declaration public abstract bool ServerActive() Returns Type Description Boolean true if the transport is ready for connections from clients | Improve this Doc View Source ServerDisconnect(Int32) Disconnect a client from this server. Useful to kick people out. Declaration public abstract void ServerDisconnect(int connectionId) Parameters Type Name Description Int32 connectionId the id of the client to disconnect | Improve this Doc View Source ServerGetClientAddress(Int32) Get the client address Declaration public abstract EndPoint ServerGetClientAddress(int connectionId) Parameters Type Name Description Int32 connectionId id of the client Returns Type Description EndPoint address of the client | Improve this Doc View Source ServerSend(List<Int32>, Int32, ArraySegment<Byte>) Send data to one or multiple clients. We provide a list, so that transports can make use of multicasting, and avoid allocations where possible. We don't provide a single ServerSend function to reduce complexity. Simply overwrite this one in your Transport. Declaration public abstract bool ServerSend(List<int> connectionIds, int channelId, ArraySegment<byte> segment) Parameters Type Name Description List < Int32 > connectionIds The list of client connection ids to send the data to Int32 channelId The channel to be used. Transports can use channels to implement other features such as unreliable, encryption, compression, etc... ArraySegment < Byte > segment Returns Type Description Boolean true if the data was sent to all clients | Improve this Doc View Source ServerStart() Start listening for clients Declaration public abstract void ServerStart() | Improve this Doc View Source ServerStop() Stop listening for clients and disconnect all existing clients Declaration public abstract void ServerStop() | Improve this Doc View Source ServerUri() Retrieves the address of this server. Useful for network discovery Declaration public abstract Uri ServerUri() Returns Type Description Uri the url at which this server can be reached | Improve this Doc View Source Shutdown() Shut down the transport, both as client and server Declaration public abstract void Shutdown() | Improve this Doc View Source Update() Declaration public void Update()"
  },
  "api/Mirror.ServerCallbackAttribute.html": {
    "href": "api/Mirror.ServerCallbackAttribute.html",
    "title": "Class ServerCallbackAttribute",
    "keywords": "Class ServerCallbackAttribute Prevents clients from running this method. No warning is thrown. Inheritance Object ServerCallbackAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ServerCallbackAttribute : Attribute"
  },
  "api/Mirror.UpdateVarsMessage.html": {
    "href": "api/Mirror.UpdateVarsMessage.html",
    "title": "Struct UpdateVarsMessage",
    "keywords": "Struct UpdateVarsMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct UpdateVarsMessage : IMessageBase Fields | Improve this Doc View Source netId Declaration public uint netId Field Value Type Description UInt32 | Improve this Doc View Source payload Declaration public ArraySegment<byte> payload Field Value Type Description ArraySegment < Byte > Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.ClientRpcAttribute.html": {
    "href": "api/Mirror.ClientRpcAttribute.html",
    "title": "Class ClientRpcAttribute",
    "keywords": "Class ClientRpcAttribute The server uses a Remote Procedure Call (RPC) to run this function on clients. Inheritance Object ClientRpcAttribute Namespace : Mirror Assembly : doc.dll Syntax public class ClientRpcAttribute : Attribute Fields | Improve this Doc View Source channel Declaration public int channel Field Value Type Description Int32"
  },
  "api/Mirror.NetworkManagerHUD.html": {
    "href": "api/Mirror.NetworkManagerHUD.html",
    "title": "Class NetworkManagerHUD",
    "keywords": "Class NetworkManagerHUD An extension for the NetworkManager that displays a default HUD for controlling the network state of the game. This component also shows useful internal state for the networking system in the inspector window of the editor. It allows users to view connections, networked objects, message handlers, and packet statistics. This information can be helpful when debugging networked games. Inheritance Object NetworkManagerHUD Namespace : Mirror Assembly : doc.dll Syntax public class NetworkManagerHUD : MonoBehaviour Fields | Improve this Doc View Source offsetX The horizontal offset in pixels to draw the HUD runtime GUI at. Declaration public int offsetX Field Value Type Description Int32 | Improve this Doc View Source offsetY The vertical offset in pixels to draw the HUD runtime GUI at. Declaration public int offsetY Field Value Type Description Int32 | Improve this Doc View Source serverIp The IP address we're connecting to. Declaration public string serverIp Field Value Type Description String | Improve this Doc View Source showGUI Whether to show the default control HUD at runtime. Declaration public bool showGUI Field Value Type Description Boolean"
  },
  "api/Mirror.IMessageBase.html": {
    "href": "api/Mirror.IMessageBase.html",
    "title": "Interface IMessageBase",
    "keywords": "Interface IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public interface IMessageBase Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer"
  },
  "api/Mirror.ServerDataReceivedEvent.html": {
    "href": "api/Mirror.ServerDataReceivedEvent.html",
    "title": "Class ServerDataReceivedEvent",
    "keywords": "Class ServerDataReceivedEvent Inheritance Object ServerDataReceivedEvent Namespace : Mirror Assembly : doc.dll Syntax public class ServerDataReceivedEvent : UnityEvent<int, ArraySegment<byte>, int>"
  },
  "api/Mirror.AsyncTcp.AsyncTcpTransport.html": {
    "href": "api/Mirror.AsyncTcp.AsyncTcpTransport.html",
    "title": "Class AsyncTcpTransport",
    "keywords": "Class AsyncTcpTransport Inheritance Object AsyncTransport AsyncTcpTransport Namespace : Mirror.AsyncTcp Assembly : doc.dll Syntax public class AsyncTcpTransport : AsyncTransport Fields | Improve this Doc View Source Port Declaration public int Port Field Value Type Description Int32 Properties | Improve this Doc View Source Scheme Declaration public override string Scheme { get; } Property Value Type Description String Overrides AsyncTransport.Scheme Methods | Improve this Doc View Source AcceptAsync() Declaration public override Task<IConnection> AcceptAsync() Returns Type Description Task < IConnection > Overrides AsyncTransport.AcceptAsync() | Improve this Doc View Source ConnectAsync(Uri) Declaration public override Task<IConnection> ConnectAsync(Uri uri) Parameters Type Name Description Uri uri Returns Type Description Task < IConnection > Overrides AsyncTransport.ConnectAsync(Uri) | Improve this Doc View Source Disconnect() Declaration public override void Disconnect() Overrides AsyncTransport.Disconnect() | Improve this Doc View Source ListenAsync() Declaration public override Task ListenAsync() Returns Type Description Task Overrides AsyncTransport.ListenAsync() | Improve this Doc View Source OnApplicationQuit() Declaration public void OnApplicationQuit() | Improve this Doc View Source ServerUri() Declaration public override Uri ServerUri() Returns Type Description Uri Overrides AsyncTransport.ServerUri()"
  },
  "api/Mirror.AsyncMultiplexTransport.html": {
    "href": "api/Mirror.AsyncMultiplexTransport.html",
    "title": "Class AsyncMultiplexTransport",
    "keywords": "Class AsyncMultiplexTransport Inheritance Object AsyncTransport AsyncMultiplexTransport Namespace : Mirror Assembly : doc.dll Syntax public class AsyncMultiplexTransport : AsyncTransport Fields | Improve this Doc View Source transports Declaration public AsyncTransport[] transports Field Value Type Description AsyncTransport [] Properties | Improve this Doc View Source Scheme Declaration public override string Scheme { get; } Property Value Type Description String Overrides AsyncTransport.Scheme Methods | Improve this Doc View Source AcceptAsync() Declaration public override Task<IConnection> AcceptAsync() Returns Type Description Task < IConnection > Overrides AsyncTransport.AcceptAsync() | Improve this Doc View Source ConnectAsync(Uri) Declaration public override Task<IConnection> ConnectAsync(Uri uri) Parameters Type Name Description Uri uri Returns Type Description Task < IConnection > Overrides AsyncTransport.ConnectAsync(Uri) | Improve this Doc View Source Disconnect() Declaration public override void Disconnect() Overrides AsyncTransport.Disconnect() | Improve this Doc View Source ListenAsync() Declaration public override Task ListenAsync() Returns Type Description Task Overrides AsyncTransport.ListenAsync() | Improve this Doc View Source ServerUri() Declaration public override Uri ServerUri() Returns Type Description Uri Overrides AsyncTransport.ServerUri()"
  },
  "api/Mirror.Discovery.NetworkDiscoveryHUD.html": {
    "href": "api/Mirror.Discovery.NetworkDiscoveryHUD.html",
    "title": "Class NetworkDiscoveryHUD",
    "keywords": "Class NetworkDiscoveryHUD Inheritance Object NetworkDiscoveryHUD Namespace : Mirror.Discovery Assembly : doc.dll Syntax public class NetworkDiscoveryHUD : MonoBehaviour Fields | Improve this Doc View Source networkDiscovery Declaration public NetworkDiscovery networkDiscovery Field Value Type Description NetworkDiscovery | Improve this Doc View Source networkManager Declaration public NetworkManager networkManager Field Value Type Description NetworkManager Methods | Improve this Doc View Source OnDiscoveredServer(ServerResponse) Declaration public void OnDiscoveredServer(ServerResponse info) Parameters Type Name Description ServerResponse info"
  },
  "api/Mirror.SceneOperation.html": {
    "href": "api/Mirror.SceneOperation.html",
    "title": "Enum SceneOperation",
    "keywords": "Enum SceneOperation Namespace : Mirror Assembly : doc.dll Syntax public enum SceneOperation : byte Fields Name Description LoadAdditive Normal UnloadAdditive"
  },
  "api/Mirror.UnityEventIntException.html": {
    "href": "api/Mirror.UnityEventIntException.html",
    "title": "Class UnityEventIntException",
    "keywords": "Class UnityEventIntException Inheritance Object UnityEventIntException Namespace : Mirror Assembly : doc.dll Syntax public class UnityEventIntException : UnityEvent<int, Exception>"
  },
  "api/Mirror.NetworkPongMessage.html": {
    "href": "api/Mirror.NetworkPongMessage.html",
    "title": "Struct NetworkPongMessage",
    "keywords": "Struct NetworkPongMessage Implements IMessageBase Namespace : Mirror Assembly : doc.dll Syntax public struct NetworkPongMessage : IMessageBase Fields | Improve this Doc View Source clientTime Declaration public double clientTime Field Value Type Description Double | Improve this Doc View Source serverTime Declaration public double serverTime Field Value Type Description Double Methods | Improve this Doc View Source Deserialize(NetworkReader) Declaration public void Deserialize(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source Serialize(NetworkWriter) Declaration public void Serialize(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer Implements IMessageBase"
  },
  "api/Mirror.NetworkMatchChecker.html": {
    "href": "api/Mirror.NetworkMatchChecker.html",
    "title": "Class NetworkMatchChecker",
    "keywords": "Class NetworkMatchChecker Component that controls visibility of networked objects based on match id. Any object with this component on it will only be visible to other objects in the same match. This would be used to isolate players to their respective matches within a single game server instance. Inheritance Object NetworkBehaviour NetworkVisibility NetworkMatchChecker Inherited Members NetworkVisibility.OnSetHostVisibility(Boolean) NetworkBehaviour.syncMode NetworkBehaviour.syncInterval NetworkBehaviour.IsServer NetworkBehaviour.IsClient NetworkBehaviour.IsLocalClient NetworkBehaviour.IsLocalPlayer NetworkBehaviour.IsServerOnly NetworkBehaviour.IsClientOnly NetworkBehaviour.HasAuthority NetworkBehaviour.NetId NetworkBehaviour.Server NetworkBehaviour.Client NetworkBehaviour.ConnectionToServer NetworkBehaviour.ConnectionToClient NetworkBehaviour.NetworkTime NetworkBehaviour.SyncVarDirtyBits NetworkBehaviour.GetSyncVarHookGuard(UInt64) NetworkBehaviour.SetSyncVarHookGuard(UInt64, Boolean) NetworkBehaviour.syncObjects NetworkBehaviour.NetIdentity NetworkBehaviour.ComponentIndex NetworkBehaviour.InitSyncObject(ISyncObject) NetworkBehaviour.SendCommandInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeCommand(Int32, NetworkReader) NetworkBehaviour.SendRpcInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.SendTargetRpcInternal(INetworkConnection, Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeRpc(Int32, NetworkReader) NetworkBehaviour.SendEventInternal(Type, String, NetworkWriter, Int32) NetworkBehaviour.InvokeSyncEvent(Int32, NetworkReader) NetworkBehaviour.RegisterDelegate(Type, String, MirrorInvokeType, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterCommandDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterRpcDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.RegisterEventDelegate(Type, String, NetworkBehaviour.CmdDelegate) NetworkBehaviour.GetRpcHandler(Int32) NetworkBehaviour.GetDelegate(Int32) NetworkBehaviour.SyncVarGameObjectEqual(GameObject, UInt32) NetworkBehaviour.SetSyncVarGameObject(GameObject, GameObject, UInt64, UInt32) NetworkBehaviour.GetSyncVarGameObject(UInt32, GameObject) NetworkBehaviour.SyncVarNetworkIdentityEqual(NetworkIdentity, UInt32) NetworkBehaviour.SetSyncVarNetworkIdentity(NetworkIdentity, NetworkIdentity, UInt64, UInt32) NetworkBehaviour.GetSyncVarNetworkIdentity(UInt32, NetworkIdentity) NetworkBehaviour.SyncVarEqual<T>(T, T) NetworkBehaviour.SetSyncVar<T>(T, T, UInt64) NetworkBehaviour.SetDirtyBit(UInt64) NetworkBehaviour.ClearAllDirtyBits() NetworkBehaviour.OnSerialize(NetworkWriter, Boolean) NetworkBehaviour.OnDeserialize(NetworkReader, Boolean) NetworkBehaviour.SerializeSyncVars(NetworkWriter, Boolean) NetworkBehaviour.DeserializeSyncVars(NetworkReader, Boolean) NetworkBehaviour.SerializeObjectsAll(NetworkWriter) NetworkBehaviour.SerializeObjectsDelta(NetworkWriter) Namespace : Mirror Assembly : doc.dll Syntax public class NetworkMatchChecker : NetworkVisibility Fields | Improve this Doc View Source currentMatchDebug Declaration public string currentMatchDebug Field Value Type Description String Properties | Improve this Doc View Source Identity Declaration public NetworkIdentity Identity { get; } Property Value Type Description NetworkIdentity | Improve this Doc View Source matchId Set this to the same value on all networked objects that belong to a given match Declaration public Guid matchId { get; set; } Property Value Type Description Guid Methods | Improve this Doc View Source Awake() Declaration public void Awake() | Improve this Doc View Source OnCheckObserver(INetworkConnection) Callback used by the visibility system to determine if an observer (player) can see this object. If this function returns true, the network connection will be added as an observer. Declaration public override bool OnCheckObserver(INetworkConnection conn) Parameters Type Name Description INetworkConnection conn Network connection of a player. Returns Type Description Boolean True if the player can see this object. Overrides NetworkVisibility.OnCheckObserver(INetworkConnection) | Improve this Doc View Source OnRebuildObservers(HashSet<INetworkConnection>, Boolean) Callback used by the visibility system to (re)construct the set of observers that can see this object. Implementations of this callback should add network connections of players that can see this object to the observers set. Declaration public override void OnRebuildObservers(HashSet<INetworkConnection> observers, bool initialize) Parameters Type Name Description HashSet < INetworkConnection > observers The new set of observers for this object. Boolean initialize True if the set of observers is being built for the first time. Overrides NetworkVisibility.OnRebuildObservers(HashSet<INetworkConnection>, Boolean) | Improve this Doc View Source OnStartServer() Declaration public void OnStartServer()"
  },
  "api/Mirror.ISyncObject.html": {
    "href": "api/Mirror.ISyncObject.html",
    "title": "Interface ISyncObject",
    "keywords": "Interface ISyncObject Namespace : Mirror Assembly : doc.dll Syntax public interface ISyncObject Properties | Improve this Doc View Source IsDirty Declaration bool IsDirty { get; } Property Value Type Description Boolean Methods | Improve this Doc View Source Flush() Declaration void Flush() | Improve this Doc View Source OnDeserializeAll(NetworkReader) Declaration void OnDeserializeAll(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnDeserializeDelta(NetworkReader) Declaration void OnDeserializeDelta(NetworkReader reader) Parameters Type Name Description NetworkReader reader | Improve this Doc View Source OnSerializeAll(NetworkWriter) Declaration void OnSerializeAll(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source OnSerializeDelta(NetworkWriter) Declaration void OnSerializeDelta(NetworkWriter writer) Parameters Type Name Description NetworkWriter writer | Improve this Doc View Source Reset() Resets the SyncObject so that it can be re-used Declaration void Reset()"
  }
}